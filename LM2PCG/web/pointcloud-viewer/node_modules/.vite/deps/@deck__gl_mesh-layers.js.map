{
  "version": 3,
  "sources": ["../../@deck.gl/mesh-layers/src/utils/matrix.ts", "../../@deck.gl/mesh-layers/src/simple-mesh-layer/simple-mesh-layer-uniforms.ts", "../../@deck.gl/mesh-layers/src/simple-mesh-layer/simple-mesh-layer-vertex.glsl.ts", "../../@deck.gl/mesh-layers/src/simple-mesh-layer/simple-mesh-layer-fragment.glsl.ts", "../../@deck.gl/mesh-layers/src/simple-mesh-layer/simple-mesh-layer.ts", "../../@loaders.gl/textures/dist/lib/utils/version.js", "../../@loaders.gl/textures/dist/lib/parsers/basis-module-loader.js", "../../@loaders.gl/textures/dist/lib/gl-extensions.js", "../../@loaders.gl/textures/dist/lib/utils/texture-formats.js", "../../ktx-parse/src/constants.ts", "../../ktx-parse/src/container.ts", "../../ktx-parse/src/buffer-reader.ts", "../../ktx-parse/src/constants-internal.ts", "../../ktx-parse/src/util.ts", "../../ktx-parse/src/read.ts", "../../ktx-parse/src/write.ts", "../../@loaders.gl/textures/dist/lib/utils/extract-mipmap-images.js", "../../@loaders.gl/textures/dist/lib/utils/ktx-format-helper.js", "../../@loaders.gl/textures/dist/lib/parsers/parse-ktx.js", "../../@loaders.gl/textures/dist/lib/parsers/parse-basis.js", "../../@loaders.gl/textures/dist/basis-loader.js", "../../@loaders.gl/textures/dist/lib/parsers/parse-dds.js", "../../@loaders.gl/textures/dist/lib/parsers/parse-pvr.js", "../../@loaders.gl/textures/dist/lib/parsers/parse-compressed-texture.js", "../../@loaders.gl/textures/dist/compressed-texture-loader.js", "../../@loaders.gl/textures/dist/lib/parsers/parse-npy.js", "../../@loaders.gl/textures/dist/npy-loader.js", "../../@luma.gl/gltf/src/webgl-to-webgpu/convert-webgl-sampler.ts", "../../@luma.gl/gltf/src/parsers/parse-pbr-material.ts", "../../@luma.gl/gltf/src/webgl-to-webgpu/convert-webgl-topology.ts", "../../@luma.gl/gltf/src/gltf/create-gltf-model.ts", "../../@luma.gl/gltf/src/parsers/parse-gltf.ts", "../../@luma.gl/gltf/src/gltf/animations/interpolate.ts", "../../@luma.gl/gltf/src/gltf/gltf-animator.ts", "../../@luma.gl/gltf/src/webgl-to-webgpu/convert-webgl-attribute.ts", "../../@luma.gl/gltf/src/parsers/parse-gltf-animations.ts", "../../@luma.gl/gltf/src/utils/deep-copy.ts", "../../@luma.gl/gltf/src/gltf/create-scenegraph-from-gltf.ts", "../../@loaders.gl/gltf/dist/lib/extensions/EXT_mesh_features.js", "../../@loaders.gl/gltf/dist/lib/utils/assert.js", "../../@loaders.gl/gltf/dist/lib/gltf-utils/gltf-constants.js", "../../@loaders.gl/gltf/dist/lib/gltf-utils/gltf-utils.js", "../../@loaders.gl/gltf/dist/lib/gltf-utils/get-typed-array.js", "../../@loaders.gl/gltf/dist/lib/api/gltf-scenegraph.js", "../../@loaders.gl/gltf/dist/lib/extensions/utils/3d-tiles-utils.js", "../../@loaders.gl/gltf/dist/lib/extensions/EXT_structural_metadata.js", "../../@loaders.gl/gltf/dist/lib/extensions/deprecated/EXT_feature_metadata.js", "../../@loaders.gl/gltf/dist/lib/utils/version.js", "../../@loaders.gl/gltf/dist/lib/parsers/parse-glb.js", "../../@loaders.gl/gltf/dist/lib/gltf-utils/resolve-url.js", "../../@loaders.gl/gltf/dist/lib/extensions/EXT_meshopt_compression.js", "../../@loaders.gl/gltf/dist/meshopt/meshopt-decoder.js", "../../@loaders.gl/gltf/dist/lib/extensions/EXT_texture_webp.js", "../../@loaders.gl/gltf/dist/lib/extensions/KHR_texture_basisu.js", "../../@loaders.gl/gltf/dist/lib/extensions/KHR_draco_mesh_compression.js", "../../@loaders.gl/draco/dist/lib/utils/version.js", "../../@loaders.gl/draco/dist/draco-loader.js", "../../@loaders.gl/draco/dist/lib/utils/get-draco-schema.js", "../../@loaders.gl/draco/dist/lib/draco-parser.js", "../../@loaders.gl/draco/dist/lib/draco-module-loader.js", "../../@loaders.gl/draco/dist/index.js", "../../@loaders.gl/gltf/dist/lib/gltf-utils/gltf-attribute-utils.js", "../../@loaders.gl/gltf/dist/lib/extensions/KHR_texture_transform.js", "../../@loaders.gl/gltf/dist/lib/extensions/deprecated/KHR_lights_punctual.js", "../../@loaders.gl/gltf/dist/lib/extensions/deprecated/KHR_materials_unlit.js", "../../@loaders.gl/gltf/dist/lib/extensions/deprecated/KHR_techniques_webgl.js", "../../@loaders.gl/gltf/dist/lib/api/gltf-extensions.js", "../../@loaders.gl/gltf/dist/lib/extensions/KHR_binary_gltf.js", "../../@loaders.gl/gltf/dist/lib/api/normalize-gltf-v1.js", "../../@loaders.gl/gltf/dist/lib/parsers/parse-gltf.js", "../../@loaders.gl/gltf/dist/gltf-loader.js", "../../@loaders.gl/gltf/dist/lib/api/post-process-gltf.js", "../../@deck.gl/mesh-layers/src/scenegraph-layer/gltf-utils.ts", "../../@deck.gl/mesh-layers/src/scenegraph-layer/scenegraph-layer-uniforms.ts", "../../@deck.gl/mesh-layers/src/scenegraph-layer/scenegraph-layer-vertex.glsl.ts", "../../@deck.gl/mesh-layers/src/scenegraph-layer/scenegraph-layer-fragment.glsl.ts", "../../@deck.gl/mesh-layers/src/scenegraph-layer/scenegraph-layer.ts"],
  "sourcesContent": ["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {COORDINATE_SYSTEM, createIterable} from '@deck.gl/core';\n\n/* eslint-disable max-statements, complexity, camelcase */\nconst RADIAN_PER_DEGREE = Math.PI / 180;\nconst modelMatrix = new Float32Array(16);\nconst valueArray = new Float32Array(12);\n\nfunction calculateTransformMatrix(targetMatrix, orientation, scale) {\n  const pitch = orientation[0] * RADIAN_PER_DEGREE;\n  const yaw = orientation[1] * RADIAN_PER_DEGREE;\n  const roll = orientation[2] * RADIAN_PER_DEGREE;\n\n  const sr = Math.sin(roll);\n  const sp = Math.sin(pitch);\n  const sw = Math.sin(yaw);\n\n  const cr = Math.cos(roll);\n  const cp = Math.cos(pitch);\n  const cw = Math.cos(yaw);\n\n  const scx = scale[0];\n  const scy = scale[1];\n  const scz = scale[2];\n\n  targetMatrix[0] = scx * cw * cp; // 0,0\n  targetMatrix[1] = scx * sw * cp; // 1,0\n  targetMatrix[2] = scx * -sp; // 2,0\n  targetMatrix[3] = scy * (-sw * cr + cw * sp * sr); // 0,1\n  targetMatrix[4] = scy * (cw * cr + sw * sp * sr); // 1,1\n  targetMatrix[5] = scy * cp * sr; // 2,1\n  targetMatrix[6] = scz * (sw * sr + cw * sp * cr); // 0,2\n  targetMatrix[7] = scz * (-cw * sr + sw * sp * cr); // 1,2\n  targetMatrix[8] = scz * cp * cr; // 2,2\n}\n\nfunction getExtendedMat3FromMat4(mat4) {\n  mat4[0] = mat4[0];\n  mat4[1] = mat4[1];\n  mat4[2] = mat4[2];\n  mat4[3] = mat4[4];\n  mat4[4] = mat4[5];\n  mat4[5] = mat4[6];\n  mat4[6] = mat4[8];\n  mat4[7] = mat4[9];\n  mat4[8] = mat4[10];\n  mat4[9] = mat4[12];\n  mat4[10] = mat4[13];\n  mat4[11] = mat4[14];\n\n  return mat4.subarray(0, 12);\n}\n\nexport const MATRIX_ATTRIBUTES = {\n  size: 12,\n  accessor: ['getOrientation', 'getScale', 'getTranslation', 'getTransformMatrix'],\n  shaderAttributes: {\n    instanceModelMatrixCol0: {\n      size: 3,\n      elementOffset: 0\n    },\n    instanceModelMatrixCol1: {\n      size: 3,\n      elementOffset: 3\n    },\n    instanceModelMatrixCol2: {\n      size: 3,\n      elementOffset: 6\n    },\n    instanceTranslation: {\n      size: 3,\n      elementOffset: 9\n    }\n  } as const,\n\n  update(attribute, {startRow, endRow}) {\n    // @ts-expect-error: \"this\" will be bound to a layer when this  function is called\n    const {data, getOrientation, getScale, getTranslation, getTransformMatrix} = this.props;\n\n    const arrayMatrix = Array.isArray(getTransformMatrix);\n    const constantMatrix = arrayMatrix && getTransformMatrix.length === 16;\n    const constantScale = Array.isArray(getScale);\n    const constantOrientation = Array.isArray(getOrientation);\n    const constantTranslation = Array.isArray(getTranslation);\n\n    const hasMatrix = constantMatrix || (!arrayMatrix && Boolean(getTransformMatrix(data[0])));\n\n    if (hasMatrix) {\n      attribute.constant = constantMatrix;\n    } else {\n      attribute.constant = constantOrientation && constantScale && constantTranslation;\n    }\n\n    const instanceModelMatrixData = attribute.value;\n\n    if (attribute.constant) {\n      let matrix;\n\n      if (hasMatrix) {\n        modelMatrix.set(getTransformMatrix);\n        matrix = getExtendedMat3FromMat4(modelMatrix);\n      } else {\n        matrix = valueArray;\n\n        const orientation = getOrientation;\n        const scale = getScale;\n\n        calculateTransformMatrix(matrix, orientation, scale);\n        matrix.set(getTranslation, 9);\n      }\n\n      attribute.value = new Float32Array(matrix);\n    } else {\n      let i = startRow * attribute.size;\n      const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n      for (const object of iterable) {\n        objectInfo.index++;\n        let matrix;\n\n        if (hasMatrix) {\n          modelMatrix.set(\n            constantMatrix ? getTransformMatrix : getTransformMatrix(object, objectInfo)\n          );\n          matrix = getExtendedMat3FromMat4(modelMatrix);\n        } else {\n          matrix = valueArray;\n\n          const orientation = constantOrientation\n            ? getOrientation\n            : getOrientation(object, objectInfo);\n          const scale = constantScale ? getScale : getScale(object, objectInfo);\n\n          calculateTransformMatrix(matrix, orientation, scale);\n          matrix.set(constantTranslation ? getTranslation : getTranslation(object, objectInfo), 9);\n        }\n\n        instanceModelMatrixData[i++] = matrix[0];\n        instanceModelMatrixData[i++] = matrix[1];\n        instanceModelMatrixData[i++] = matrix[2];\n        instanceModelMatrixData[i++] = matrix[3];\n        instanceModelMatrixData[i++] = matrix[4];\n        instanceModelMatrixData[i++] = matrix[5];\n        instanceModelMatrixData[i++] = matrix[6];\n        instanceModelMatrixData[i++] = matrix[7];\n        instanceModelMatrixData[i++] = matrix[8];\n        instanceModelMatrixData[i++] = matrix[9];\n        instanceModelMatrixData[i++] = matrix[10];\n        instanceModelMatrixData[i++] = matrix[11];\n      }\n    }\n  }\n};\n\n// only apply composeModelMatrix when in cartesian or meter_offsets coordinate system\n// with `composeModelMatrix` enabled, the rotation part of the layer's modelMatrix will be composed to instance's transformations\n// since rotating latitude and longitude can not provide meaningful results, hence `composeModelMatrix` is disabled\n// when in LNGLAT and LNGLAT_OFFSET coordinates.\nexport function shouldComposeModelMatrix(viewport, coordinateSystem) {\n  return (\n    coordinateSystem === COORDINATE_SYSTEM.CARTESIAN ||\n    coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS ||\n    (coordinateSystem === COORDINATE_SYSTEM.DEFAULT && !viewport.isGeospatial)\n  );\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Texture} from '@luma.gl/core';\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\nconst uniformBlock = `\\\nuniform simpleMeshUniforms {\n  float sizeScale;\n  bool composeModelMatrix;\n  bool hasTexture;\n  bool flatShading;\n} simpleMesh;\n`;\n\nexport type SimpleMeshProps = {\n  sizeScale?: number;\n  composeModelMatrix?: boolean;\n  hasTexture?: boolean;\n  flatShading?: boolean;\n  sampler?: Texture;\n};\n\nexport const simpleMeshUniforms = {\n  name: 'simpleMesh',\n  vs: uniformBlock,\n  fs: uniformBlock,\n  uniformTypes: {\n    sizeScale: 'f32',\n    composeModelMatrix: 'f32',\n    hasTexture: 'f32',\n    flatShading: 'f32'\n  }\n} as const satisfies ShaderModule<SimpleMeshProps>;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport default `#version 300 es\n#define SHADER_NAME simple-mesh-layer-vs\n\n// Primitive attributes\nin vec3 positions;\nin vec3 normals;\nin vec3 colors;\nin vec2 texCoords;\n\n// Instance attributes\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin vec3 instanceModelMatrixCol0;\nin vec3 instanceModelMatrixCol1;\nin vec3 instanceModelMatrixCol2;\nin vec3 instanceTranslation;\n\n// Outputs to fragment shader\nout vec2 vTexCoord;\nout vec3 cameraPosition;\nout vec3 normals_commonspace;\nout vec4 position_commonspace;\nout vec4 vColor;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = instancePickingColors;\n\n  vTexCoord = texCoords;\n  cameraPosition = project.cameraPosition;\n  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);\n\n  mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);\n  vec3 pos = (instanceModelMatrix * positions) * simpleMesh.sizeScale + instanceTranslation;\n\n  if (simpleMesh.composeModelMatrix) {\n    DECKGL_FILTER_SIZE(pos, geometry);\n    // using instancePositions as world coordinates\n    // when using globe mode, this branch does not re-orient the model to align with the surface of the earth\n    // call project_normal before setting position to avoid rotation\n    normals_commonspace = project_normal(instanceModelMatrix * normals);\n    geometry.worldPosition += pos;\n    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);\n    geometry.position = position_commonspace;\n  }\n  else {\n    pos = project_size(pos);\n    DECKGL_FILTER_SIZE(pos, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);\n    geometry.position = position_commonspace;\n    normals_commonspace = project_normal(instanceModelMatrix * normals);\n  }\n\n  geometry.normal = normals_commonspace;\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport default `#version 300 es\n#define SHADER_NAME simple-mesh-layer-fs\n\nprecision highp float;\n\nuniform sampler2D sampler;\n\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  geometry.uv = vTexCoord;\n\n  vec3 normal;\n  if (simpleMesh.flatShading) {\n\n  normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n  } else {\n    normal = normals_commonspace;\n  }\n\n  vec4 color = simpleMesh.hasTexture ? texture(sampler, vTexCoord) : vColor;\n  DECKGL_FILTER_COLOR(color, geometry);\n\n  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\n  fragColor = vec4(lightColor, color.a * layer.opacity);\n}\n`;\n", "// Note: This file will either be moved back to deck.gl or reformatted to web-monorepo standards\n// Disabling lint temporarily to facilitate copying code in and out of this repo\n/* eslint-disable */\n\n// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Layer, project32, picking, DefaultProps, log, LayerContext, Material} from '@deck.gl/core';\nimport {SamplerProps, Texture} from '@luma.gl/core';\nimport {Model, Geometry} from '@luma.gl/engine';\nimport {ParsedPBRMaterial} from '@luma.gl/gltf';\nimport {phongMaterial} from '@luma.gl/shadertools';\n\nimport {MATRIX_ATTRIBUTES, shouldComposeModelMatrix} from '../utils/matrix';\n\nimport {simpleMeshUniforms, SimpleMeshProps} from './simple-mesh-layer-uniforms';\nimport vs from './simple-mesh-layer-vertex.glsl';\nimport fs from './simple-mesh-layer-fragment.glsl';\n\nimport type {\n  LayerProps,\n  LayerDataSource,\n  UpdateParameters,\n  Accessor,\n  Position,\n  Color,\n  TextureSource\n} from '@deck.gl/core';\nimport type {MeshAttribute, MeshAttributes} from '@loaders.gl/schema';\nimport type {Geometry as GeometryType} from '@luma.gl/engine';\nimport {getMeshBoundingBox} from '@loaders.gl/schema';\n\nfunction normalizeGeometryAttributes(attributes: MeshAttributes): MeshAttributes {\n  const positionAttribute = attributes.positions || attributes.POSITION;\n  log.assert(positionAttribute, 'no \"postions\" or \"POSITION\" attribute in mesh');\n\n  const vertexCount = positionAttribute.value.length / positionAttribute.size;\n  let colorAttribute = attributes.COLOR_0 || attributes.colors;\n  if (!colorAttribute) {\n    colorAttribute = {size: 3, value: new Float32Array(vertexCount * 3).fill(1)};\n  }\n  let normalAttribute = attributes.NORMAL || attributes.normals;\n  if (!normalAttribute) {\n    normalAttribute = {size: 3, value: new Float32Array(vertexCount * 3).fill(0)};\n  }\n  let texCoordAttribute = attributes.TEXCOORD_0 || attributes.texCoords;\n  if (!texCoordAttribute) {\n    texCoordAttribute = {size: 2, value: new Float32Array(vertexCount * 2).fill(0)};\n  }\n\n  return {\n    positions: positionAttribute,\n    colors: colorAttribute,\n    normals: normalAttribute,\n    texCoords: texCoordAttribute\n  };\n}\n\n/*\n * Convert mesh data into geometry\n * @returns {Geometry} geometry\n */\nfunction getGeometry(data: Mesh): Geometry {\n  if (data instanceof Geometry) {\n    // @ts-expect-error data.attributes is readonly\n    data.attributes = normalizeGeometryAttributes(data.attributes);\n    return data;\n  } else if ((data as any).attributes) {\n    return new Geometry({\n      ...data,\n      topology: 'triangle-list',\n      attributes: normalizeGeometryAttributes((data as any).attributes)\n    });\n  } else {\n    return new Geometry({\n      topology: 'triangle-list',\n      attributes: normalizeGeometryAttributes(data as MeshAttributes)\n    });\n  }\n}\n\nconst DEFAULT_COLOR: [number, number, number, number] = [0, 0, 0, 255];\n\ntype Mesh =\n  | GeometryType\n  | {\n      attributes: MeshAttributes;\n      indices?: MeshAttribute;\n    }\n  | MeshAttributes;\n\ntype _SimpleMeshLayerProps<DataT> = {\n  data: LayerDataSource<DataT>;\n  mesh: string | Mesh | Promise<Mesh> | null;\n  texture?: string | TextureSource | Promise<TextureSource>;\n  /** Customize the [texture parameters](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter). */\n  textureParameters?: SamplerProps | null;\n\n  /** Anchor position accessor. */\n  getPosition?: Accessor<DataT, Position>;\n  /** Color value or accessor.\n   * If `mesh` does not contain vertex colors, use this color to render each object.\n   * If `mesh` contains vertex colors, then the two colors are mixed together.\n   * Use `[255, 255, 255]` to use the original mesh colors.\n   * If `texture` is assigned, then both colors will be ignored.\n   * @default [0, 0, 0, 255]\n   */\n  getColor?: Accessor<DataT, Color>;\n  /**\n   * Orientation in [pitch, yaw, roll] in degrees.\n   * @see https://en.wikipedia.org/wiki/Euler_angles\n   * @default [0, 0, 0]\n   */\n  getOrientation?: Accessor<DataT, [number, number, number]>;\n  /**\n   * Scaling factor of the model along each axis.\n   * @default [1, 1, 1]\n   */\n  getScale?: Accessor<DataT, [number, number, number]>;\n  /**\n   * Translation from the anchor point, [x, y, z] in meters.\n   * @default [0, 0, 0]\n   */\n  getTranslation?: Accessor<DataT, [number, number, number]>;\n  /**\n   * TransformMatrix. If specified, `getOrientation`, `getScale` and `getTranslation` are ignored.\n   */\n  getTransformMatrix?: Accessor<DataT, number[]>;\n  /**\n   * Multiplier to scale each geometry by.\n   * @default 1\n   */\n  sizeScale?: number;\n\n  /**\n   * (Experimental) If rendering only one instance of the mesh, set this to false to treat mesh positions\n   * as deltas of the world coordinates of the anchor.\n   * E.g. in LNGLAT coordinates, mesh positions are interpreted as meter offsets by default.\n   * setting _instanced to false interpreted mesh positions as lnglat deltas.\n   * @default true\n   */\n  _instanced?: boolean; // TODO - formalize API\n  /**\n   * Whether to render the mesh in wireframe mode.\n   * @default false\n   */\n  wireframe?: boolean;\n  /**\n   * Material props for lighting effect.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting#constructing-a-material-instance\n   */\n  material?: Material;\n};\n\nexport type SimpleMeshLayerProps<DataT = unknown> = _SimpleMeshLayerProps<DataT> & LayerProps;\n\nconst defaultProps: DefaultProps<SimpleMeshLayerProps> = {\n  mesh: {type: 'object', value: null, async: true},\n  texture: {type: 'image', value: null, async: true},\n  sizeScale: {type: 'number', value: 1, min: 0},\n\n  // _instanced is a hack to use world position instead of meter offsets in mesh\n  // TODO - formalize API\n  _instanced: true,\n  // NOTE(Tarek): Quick and dirty wireframe. Just draws\n  // the same mesh with LINE_STRIPS. Won't follow edges\n  // of the original mesh.\n  wireframe: false,\n  // Optional material for 'lighting' shader module\n  material: true,\n  getPosition: {type: 'accessor', value: (x: any) => x.position},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n\n  // yaw, pitch and roll are in degrees\n  // https://en.wikipedia.org/wiki/Euler_angles\n  // [pitch, yaw, roll]\n  getOrientation: {type: 'accessor', value: [0, 0, 0]},\n  getScale: {type: 'accessor', value: [1, 1, 1]},\n  getTranslation: {type: 'accessor', value: [0, 0, 0]},\n  // 4x4 matrix\n  getTransformMatrix: {type: 'accessor', value: []},\n\n  textureParameters: {type: 'object', ignore: true, value: null}\n};\n\n/** Render a number of instances of an arbitrary 3D geometry. */\nexport default class SimpleMeshLayer<DataT = any, ExtraPropsT extends {} = {}> extends Layer<\n  ExtraPropsT & Required<_SimpleMeshLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'SimpleMeshLayer';\n\n  state!: {\n    parsedPBRMaterial?: ParsedPBRMaterial;\n    model?: Model;\n    emptyTexture: Texture;\n    hasNormals?: boolean;\n    positionBounds?: [number[], number[]] | null;\n  };\n\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, phongMaterial, picking, simpleMeshUniforms]\n    });\n  }\n\n  getBounds(): [number[], number[]] | null {\n    if (this.props._instanced) {\n      return super.getBounds();\n    }\n    let result = this.state.positionBounds;\n    if (result) {\n      return result;\n    }\n    const {mesh} = this.props;\n    if (!mesh) {\n      return null;\n    }\n    // @ts-ignore Detect if mesh is generated by loaders.gl\n    result = mesh.header?.boundingBox;\n\n    if (!result) {\n      // Otherwise, calculate bounding box from positions\n      const {attributes} = getGeometry(mesh as Mesh);\n      attributes.POSITION = attributes.POSITION || attributes.positions;\n\n      //@ts-expect-error\n      result = getMeshBoundingBox(attributes);\n    }\n\n    this.state.positionBounds = result;\n    return result;\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    // attributeManager is always defined in a primitive layer\n    attributeManager!.addInstanced({\n      instancePositions: {\n        transition: true,\n        type: 'float64',\n        fp64: this.use64bitPositions(),\n        size: 3,\n        accessor: 'getPosition'\n      },\n      instanceColors: {\n        type: 'unorm8',\n        transition: true,\n        size: this.props.colorFormat.length,\n        accessor: 'getColor',\n        defaultValue: [0, 0, 0, 255]\n      },\n      instanceModelMatrix: MATRIX_ATTRIBUTES\n    });\n\n    this.setState({\n      // Avoid luma.gl's missing uniform warning\n      // TODO - add feature to luma.gl to specify ignored uniforms?\n      emptyTexture: this.context.device.createTexture({\n        data: new Uint8Array(4),\n        width: 1,\n        height: 1\n      })\n    });\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    super.updateState(params);\n\n    const {props, oldProps, changeFlags} = params;\n    if (props.mesh !== oldProps.mesh || changeFlags.extensionsChanged) {\n      this.state.positionBounds = null;\n      this.state.model?.destroy();\n      if (props.mesh) {\n        this.state.model = this.getModel(props.mesh as Mesh);\n\n        const attributes = (props.mesh as any).attributes || props.mesh;\n        this.setState({\n          hasNormals: Boolean(attributes.NORMAL || attributes.normals)\n        });\n      }\n      // attributeManager is always defined in a primitive layer\n      this.getAttributeManager()!.invalidateAll();\n    }\n\n    if (props.texture !== oldProps.texture && props.texture instanceof Texture) {\n      this.setTexture(props.texture);\n    }\n\n    if (this.state.model) {\n      this.state.model.setTopology(this.props.wireframe ? 'line-strip' : 'triangle-list');\n    }\n  }\n\n  finalizeState(context: LayerContext) {\n    super.finalizeState(context);\n\n    this.state.emptyTexture.delete();\n  }\n\n  draw({uniforms}) {\n    const {model} = this.state;\n    if (!model) {\n      return;\n    }\n\n    const {viewport, renderPass} = this.context;\n    const {sizeScale, coordinateSystem, _instanced} = this.props;\n\n    const simpleMeshProps: SimpleMeshProps = {\n      sizeScale,\n      composeModelMatrix: !_instanced || shouldComposeModelMatrix(viewport, coordinateSystem),\n      flatShading: !this.state.hasNormals\n    };\n    model.shaderInputs.setProps({simpleMesh: simpleMeshProps});\n    model.draw(renderPass);\n  }\n\n  get isLoaded(): boolean {\n    return Boolean(this.state?.model && super.isLoaded);\n  }\n\n  protected getModel(mesh: Mesh): Model {\n    const model = new Model(this.context.device, {\n      ...this.getShaders(),\n      id: this.props.id,\n      bufferLayout: this.getAttributeManager()!.getBufferLayouts(),\n      geometry: getGeometry(mesh),\n      isInstanced: true\n    });\n\n    const {texture} = this.props;\n    const {emptyTexture} = this.state;\n    const simpleMeshProps: SimpleMeshProps = {\n      sampler: (texture as Texture) || emptyTexture,\n      hasTexture: Boolean(texture)\n    };\n    model.shaderInputs.setProps({simpleMesh: simpleMeshProps});\n    return model;\n  }\n\n  private setTexture(texture: Texture): void {\n    const {emptyTexture, model} = this.state;\n\n    // props.mesh may not be ready at this time.\n    // The sampler will be set when `getModel` is called\n    if (model) {\n      const simpleMeshProps: SimpleMeshProps = {\n        sampler: texture || emptyTexture,\n        hasTexture: Boolean(texture)\n      };\n      model.shaderInputs.setProps({simpleMesh: simpleMeshProps});\n    }\n  }\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof \"4.3.3\" !== 'undefined' ? \"4.3.3\" : 'latest';\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { registerJSModules, getJSModuleOrNull } from '@loaders.gl/loader-utils';\nimport { loadLibrary } from '@loaders.gl/worker-utils';\nexport const BASIS_EXTERNAL_LIBRARIES = {\n    /** Basis transcoder, javascript wrapper part */\n    TRANSCODER: 'basis_transcoder.js',\n    /** Basis transcoder, compiled web assembly part */\n    TRANSCODER_WASM: 'basis_transcoder.wasm',\n    /** Basis encoder, javascript wrapper part */\n    ENCODER: 'basis_encoder.js',\n    /** Basis encoder, compiled web assembly part */\n    ENCODER_WASM: 'basis_encoder.wasm'\n};\nlet loadBasisTranscoderPromise;\n/**\n * Loads wasm transcoder module\n * @param options\n * @returns {BasisFile} promise\n */\nexport async function loadBasisTranscoderModule(options) {\n    registerJSModules(options.modules);\n    const basis = getJSModuleOrNull('basis');\n    if (basis) {\n        return basis;\n    }\n    loadBasisTranscoderPromise ||= loadBasisTranscoder(options);\n    return await loadBasisTranscoderPromise;\n}\n/**\n * Loads wasm transcoder module\n * @param options\n * @returns {BasisFile} promise\n */\nasync function loadBasisTranscoder(options) {\n    let BASIS = null;\n    let wasmBinary = null;\n    [BASIS, wasmBinary] = await Promise.all([\n        await loadLibrary(BASIS_EXTERNAL_LIBRARIES.TRANSCODER, 'textures', options),\n        await loadLibrary(BASIS_EXTERNAL_LIBRARIES.TRANSCODER_WASM, 'textures', options)\n    ]);\n    // Depends on how import happened...\n    // @ts-ignore TS2339: Property does not exist on type\n    BASIS = BASIS || globalThis.BASIS;\n    return await initializeBasisTranscoderModule(BASIS, wasmBinary);\n}\n/**\n * Initialize wasm transcoder module\n * @param BasisModule - js part of the module\n * @param wasmBinary - wasm part of the module\n * @returns {BasisFile} promise\n */\nfunction initializeBasisTranscoderModule(BasisModule, wasmBinary) {\n    const options = {};\n    if (wasmBinary) {\n        options.wasmBinary = wasmBinary;\n    }\n    return new Promise((resolve) => {\n        // if you try to return BasisModule the browser crashes!\n        BasisModule(options).then((module) => {\n            const { BasisFile, initializeBasis } = module;\n            initializeBasis();\n            resolve({ BasisFile });\n        });\n    });\n}\nlet loadBasisEncoderPromise;\n/**\n * Loads wasm encoder module\n * @param options\n * @returns {BasisFile, KTX2File} promise\n */\nexport async function loadBasisEncoderModule(options) {\n    const modules = options.modules || {};\n    if (modules.basisEncoder) {\n        return modules.basisEncoder;\n    }\n    loadBasisEncoderPromise = loadBasisEncoderPromise || loadBasisEncoder(options);\n    return await loadBasisEncoderPromise;\n}\n/**\n * Loads wasm encoder module\n * @param options\n * @returns {BasisFile, KTX2File} promise\n */\nasync function loadBasisEncoder(options) {\n    let BASIS_ENCODER = null;\n    let wasmBinary = null;\n    [BASIS_ENCODER, wasmBinary] = await Promise.all([\n        await loadLibrary(BASIS_EXTERNAL_LIBRARIES.ENCODER, 'textures', options),\n        await loadLibrary(BASIS_EXTERNAL_LIBRARIES.ENCODER_WASM, 'textures', options)\n    ]);\n    // Depends on how import happened...\n    // @ts-ignore TS2339: Property does not exist on type\n    BASIS_ENCODER = BASIS_ENCODER || globalThis.BASIS;\n    return await initializeBasisEncoderModule(BASIS_ENCODER, wasmBinary);\n}\n/**\n * Initialize wasm transcoder module\n * @param BasisEncoderModule - js part of the module\n * @param wasmBinary - wasm part of the module\n * @returns {BasisFile, KTX2File} promise\n */\nfunction initializeBasisEncoderModule(BasisEncoderModule, wasmBinary) {\n    const options = {};\n    if (wasmBinary) {\n        options.wasmBinary = wasmBinary;\n    }\n    return new Promise((resolve) => {\n        // if you try to return BasisModule the browser crashes!\n        BasisEncoderModule(options).then((module) => {\n            const { BasisFile, KTX2File, initializeBasis, BasisEncoder } = module;\n            initializeBasis();\n            resolve({ BasisFile, KTX2File, BasisEncoder });\n        });\n    });\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/* eslint-disable camelcase */\nexport const GL_EXTENSIONS_CONSTANTS = {\n    // WEBGL_compressed_texture_s3tc\n    COMPRESSED_RGB_S3TC_DXT1_EXT: 0x83f0,\n    COMPRESSED_RGBA_S3TC_DXT1_EXT: 0x83f1,\n    COMPRESSED_RGBA_S3TC_DXT3_EXT: 0x83f2,\n    COMPRESSED_RGBA_S3TC_DXT5_EXT: 0x83f3,\n    // WEBGL_compressed_texture_es3\n    COMPRESSED_R11_EAC: 0x9270,\n    COMPRESSED_SIGNED_R11_EAC: 0x9271,\n    COMPRESSED_RG11_EAC: 0x9272,\n    COMPRESSED_SIGNED_RG11_EAC: 0x9273,\n    COMPRESSED_RGB8_ETC2: 0x9274,\n    COMPRESSED_RGBA8_ETC2_EAC: 0x9275,\n    COMPRESSED_SRGB8_ETC2: 0x9276,\n    COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 0x9277,\n    COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9278,\n    COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9279,\n    // WEBGL_compressed_texture_pvrtc\n    COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 0x8c00,\n    COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 0x8c02,\n    COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 0x8c01,\n    COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 0x8c03,\n    // WEBGL_compressed_texture_etc1\n    COMPRESSED_RGB_ETC1_WEBGL: 0x8d64,\n    // WEBGL_compressed_texture_atc\n    COMPRESSED_RGB_ATC_WEBGL: 0x8c92,\n    COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 0x8c93,\n    COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 0x87ee,\n    // WEBGL_compressed_texture_astc\n    COMPRESSED_RGBA_ASTC_4X4_KHR: 0x93b0,\n    COMPRESSED_RGBA_ASTC_5X4_KHR: 0x93b1,\n    COMPRESSED_RGBA_ASTC_5X5_KHR: 0x93b2,\n    COMPRESSED_RGBA_ASTC_6X5_KHR: 0x93b3,\n    COMPRESSED_RGBA_ASTC_6X6_KHR: 0x93b4,\n    COMPRESSED_RGBA_ASTC_8X5_KHR: 0x93b5,\n    COMPRESSED_RGBA_ASTC_8X6_KHR: 0x93b6,\n    COMPRESSED_RGBA_ASTC_8X8_KHR: 0x93b7,\n    COMPRESSED_RGBA_ASTC_10X5_KHR: 0x93b8,\n    COMPRESSED_RGBA_ASTC_10X6_KHR: 0x93b9,\n    COMPRESSED_RGBA_ASTC_10X8_KHR: 0x93ba,\n    COMPRESSED_RGBA_ASTC_10X10_KHR: 0x93bb,\n    COMPRESSED_RGBA_ASTC_12X10_KHR: 0x93bc,\n    COMPRESSED_RGBA_ASTC_12X12_KHR: 0x93bd,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 0x93d0,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 0x93d1,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 0x93d2,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 0x93d3,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 0x93d4,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 0x93d5,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 0x93d6,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 0x93d7,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 0x93d8,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 0x93d9,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 0x93da,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 0x93db,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 0x93dc,\n    COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 0x93dd,\n    // EXT_texture_compression_rgtc\n    COMPRESSED_RED_RGTC1_EXT: 0x8dbb,\n    COMPRESSED_SIGNED_RED_RGTC1_EXT: 0x8dbc,\n    COMPRESSED_RED_GREEN_RGTC2_EXT: 0x8dbd,\n    COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 0x8dbe,\n    // WEBGL_compressed_texture_s3tc_srgb\n    COMPRESSED_SRGB_S3TC_DXT1_EXT: 0x8c4c,\n    COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 0x8c4d,\n    COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 0x8c4e,\n    COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 0x8c4f\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst BROWSER_PREFIXES = ['', 'WEBKIT_', 'MOZ_'];\nconst WEBGL_EXTENSIONS = {\n    /* eslint-disable camelcase */\n    WEBGL_compressed_texture_s3tc: 'dxt',\n    WEBGL_compressed_texture_s3tc_srgb: 'dxt-srgb',\n    WEBGL_compressed_texture_etc1: 'etc1',\n    WEBGL_compressed_texture_etc: 'etc2',\n    WEBGL_compressed_texture_pvrtc: 'pvrtc',\n    WEBGL_compressed_texture_atc: 'atc',\n    WEBGL_compressed_texture_astc: 'astc',\n    EXT_texture_compression_rgtc: 'rgtc'\n    /* eslint-enable camelcase */\n};\nlet formats = null;\n/**\n * Returns a list of formats.\n * Creates a temporary WebGLRenderingContext if none is provided.\n *\n * @param gl - Optional context.\n */\nexport function getSupportedGPUTextureFormats(gl) {\n    if (!formats) {\n        gl = gl || getWebGLContext() || undefined;\n        formats = new Set();\n        for (const prefix of BROWSER_PREFIXES) {\n            for (const extension in WEBGL_EXTENSIONS) {\n                if (gl && gl.getExtension(`${prefix}${extension}`)) {\n                    const gpuTextureFormat = WEBGL_EXTENSIONS[extension];\n                    formats.add(gpuTextureFormat);\n                }\n            }\n        }\n    }\n    return formats;\n}\n/**\n * @returns {WebGLRenderingContext?}\n */\nfunction getWebGLContext() {\n    try {\n        const canvas = document.createElement('canvas');\n        return canvas.getContext('webgl');\n    }\n    catch (error) {\n        return null;\n    }\n}\n", "///////////////////////////////////////////////////\n// KTX2 Header.\n///////////////////////////////////////////////////\n\nexport const KHR_SUPERCOMPRESSION_NONE = 0;\nexport const KHR_SUPERCOMPRESSION_BASISLZ = 1;\nexport const KHR_SUPERCOMPRESSION_ZSTD = 2;\nexport const KHR_SUPERCOMPRESSION_ZLIB = 3;\n\nexport type Supercompression =\n\t| typeof KHR_SUPERCOMPRESSION_NONE\n\t| typeof KHR_SUPERCOMPRESSION_BASISLZ\n\t| typeof KHR_SUPERCOMPRESSION_ZSTD\n\t| typeof KHR_SUPERCOMPRESSION_ZLIB;\n\n///////////////////////////////////////////////////\n// Data Format Descriptor (DFD).\n///////////////////////////////////////////////////\n\nexport const KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT = 0;\nexport const KHR_DF_VENDORID_KHRONOS = 0;\nexport const KHR_DF_VERSION = 2;\n\nexport const KHR_DF_MODEL_UNSPECIFIED = 0;\nexport const KHR_DF_MODEL_RGBSDA = 1;\n// ...\nexport const KHR_DF_MODEL_ETC1 = 160;\nexport const KHR_DF_MODEL_ETC2 = 161;\nexport const KHR_DF_MODEL_ASTC = 162;\nexport const KHR_DF_MODEL_ETC1S = 163;\nexport const KHR_DF_MODEL_UASTC = 166;\n\nexport const KHR_DF_FLAG_ALPHA_STRAIGHT = 0;\nexport const KHR_DF_FLAG_ALPHA_PREMULTIPLIED = 1;\n\nexport const KHR_DF_TRANSFER_UNSPECIFIED = 0;\nexport const KHR_DF_TRANSFER_LINEAR = 1;\nexport const KHR_DF_TRANSFER_SRGB = 2;\nexport const KHR_DF_TRANSFER_ITU = 3;\nexport const KHR_DF_TRANSFER_NTSC = 4;\nexport const KHR_DF_TRANSFER_SLOG = 5;\nexport const KHR_DF_TRANSFER_SLOG2 = 6;\nexport const KHR_DF_TRANSFER_BT1886 = 7;\nexport const KHR_DF_TRANSFER_HLG_OETF = 8;\nexport const KHR_DF_TRANSFER_HLG_EOTF = 9;\nexport const KHR_DF_TRANSFER_PQ_EOTF = 10;\nexport const KHR_DF_TRANSFER_PQ_OETF = 11;\nexport const KHR_DF_TRANSFER_DCIP3 = 12;\nexport const KHR_DF_TRANSFER_PAL_OETF = 13;\nexport const KHR_DF_TRANSFER_PAL625_EOTF = 14;\nexport const KHR_DF_TRANSFER_ST240 = 15;\nexport const KHR_DF_TRANSFER_ACESCC = 16;\nexport const KHR_DF_TRANSFER_ACESCCT = 17;\nexport const KHR_DF_TRANSFER_ADOBERGB = 18;\n\nexport type Transfer =\n\t| typeof KHR_DF_TRANSFER_UNSPECIFIED\n\t| typeof KHR_DF_TRANSFER_LINEAR\n\t| typeof KHR_DF_TRANSFER_SRGB\n\t| typeof KHR_DF_TRANSFER_ITU\n\t| typeof KHR_DF_TRANSFER_NTSC\n\t| typeof KHR_DF_TRANSFER_SLOG\n\t| typeof KHR_DF_TRANSFER_SLOG2\n\t| typeof KHR_DF_TRANSFER_BT1886\n\t| typeof KHR_DF_TRANSFER_HLG_OETF\n\t| typeof KHR_DF_TRANSFER_HLG_EOTF\n\t| typeof KHR_DF_TRANSFER_PQ_EOTF\n\t| typeof KHR_DF_TRANSFER_PQ_OETF\n\t| typeof KHR_DF_TRANSFER_DCIP3\n\t| typeof KHR_DF_TRANSFER_PAL_OETF\n\t| typeof KHR_DF_TRANSFER_PAL625_EOTF\n\t| typeof KHR_DF_TRANSFER_ST240\n\t| typeof KHR_DF_TRANSFER_ACESCC\n\t| typeof KHR_DF_TRANSFER_ACESCCT\n\t| typeof KHR_DF_TRANSFER_ADOBERGB;\n\nexport const KHR_DF_PRIMARIES_UNSPECIFIED = 0;\nexport const KHR_DF_PRIMARIES_BT709 = 1;\nexport const KHR_DF_PRIMARIES_BT601_EBU = 2;\nexport const KHR_DF_PRIMARIES_BT601_SMPTE = 3;\nexport const KHR_DF_PRIMARIES_BT2020 = 4;\nexport const KHR_DF_PRIMARIES_CIEXYZ = 5;\nexport const KHR_DF_PRIMARIES_ACES = 6;\nexport const KHR_DF_PRIMARIES_ACESCC = 7;\nexport const KHR_DF_PRIMARIES_NTSC1953 = 8;\nexport const KHR_DF_PRIMARIES_PAL525 = 9;\nexport const KHR_DF_PRIMARIES_DISPLAYP3 = 10;\nexport const KHR_DF_PRIMARIES_ADOBERGB = 11;\n\nexport type Primaries =\n\t| typeof KHR_DF_PRIMARIES_UNSPECIFIED\n\t| typeof KHR_DF_PRIMARIES_BT709\n\t| typeof KHR_DF_PRIMARIES_BT601_EBU\n\t| typeof KHR_DF_PRIMARIES_BT601_SMPTE\n\t| typeof KHR_DF_PRIMARIES_BT2020\n\t| typeof KHR_DF_PRIMARIES_CIEXYZ\n\t| typeof KHR_DF_PRIMARIES_ACES\n\t| typeof KHR_DF_PRIMARIES_ACESCC\n\t| typeof KHR_DF_PRIMARIES_NTSC1953\n\t| typeof KHR_DF_PRIMARIES_PAL525\n\t| typeof KHR_DF_PRIMARIES_DISPLAYP3\n\t| typeof KHR_DF_PRIMARIES_ADOBERGB;\n\nexport const KHR_DF_CHANNEL_RGBSDA_RED = 0;\nexport const KHR_DF_CHANNEL_RGBSDA_GREEN = 1;\nexport const KHR_DF_CHANNEL_RGBSDA_BLUE = 2;\nexport const KHR_DF_CHANNEL_RGBSDA_STENCIL = 13;\nexport const KHR_DF_CHANNEL_RGBSDA_DEPTH = 14;\nexport const KHR_DF_CHANNEL_RGBSDA_ALPHA = 15;\n\nexport type Channel =\n\t| typeof KHR_DF_CHANNEL_RGBSDA_RED\n\t| typeof KHR_DF_CHANNEL_RGBSDA_GREEN\n\t| typeof KHR_DF_CHANNEL_RGBSDA_BLUE\n\t| typeof KHR_DF_CHANNEL_RGBSDA_STENCIL\n\t| typeof KHR_DF_CHANNEL_RGBSDA_DEPTH\n\t| typeof KHR_DF_CHANNEL_RGBSDA_ALPHA;\n\nexport const KHR_DF_SAMPLE_DATATYPE_FLOAT = 0x80;\nexport const KHR_DF_SAMPLE_DATATYPE_SIGNED = 0x40;\nexport const KHR_DF_SAMPLE_DATATYPE_EXPONENT = 0x20;\nexport const KHR_DF_SAMPLE_DATATYPE_LINEAR = 0x10;\n\nexport type SampleDatatype =\n\t| typeof KHR_DF_SAMPLE_DATATYPE_FLOAT\n\t| typeof KHR_DF_SAMPLE_DATATYPE_SIGNED\n\t| typeof KHR_DF_SAMPLE_DATATYPE_EXPONENT\n\t| typeof KHR_DF_SAMPLE_DATATYPE_LINEAR;\n\n///////////////////////////////////////////////////\n// VK FORMAT.\n///////////////////////////////////////////////////\n\nexport const VK_FORMAT_UNDEFINED = 0;\nexport const VK_FORMAT_R4G4_UNORM_PACK8 = 1;\nexport const VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2;\nexport const VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3;\nexport const VK_FORMAT_R5G6B5_UNORM_PACK16 = 4;\nexport const VK_FORMAT_B5G6R5_UNORM_PACK16 = 5;\nexport const VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6;\nexport const VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7;\nexport const VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8;\nexport const VK_FORMAT_R8_UNORM = 9;\nexport const VK_FORMAT_R8_SNORM = 10;\nexport const VK_FORMAT_R8_UINT = 13;\nexport const VK_FORMAT_R8_SINT = 14;\nexport const VK_FORMAT_R8_SRGB = 15;\nexport const VK_FORMAT_R8G8_UNORM = 16;\nexport const VK_FORMAT_R8G8_SNORM = 17;\nexport const VK_FORMAT_R8G8_UINT = 20;\nexport const VK_FORMAT_R8G8_SINT = 21;\nexport const VK_FORMAT_R8G8_SRGB = 22;\nexport const VK_FORMAT_R8G8B8_UNORM = 23;\nexport const VK_FORMAT_R8G8B8_SNORM = 24;\nexport const VK_FORMAT_R8G8B8_UINT = 27;\nexport const VK_FORMAT_R8G8B8_SINT = 28;\nexport const VK_FORMAT_R8G8B8_SRGB = 29;\nexport const VK_FORMAT_B8G8R8_UNORM = 30;\nexport const VK_FORMAT_B8G8R8_SNORM = 31;\nexport const VK_FORMAT_B8G8R8_UINT = 34;\nexport const VK_FORMAT_B8G8R8_SINT = 35;\nexport const VK_FORMAT_B8G8R8_SRGB = 36;\nexport const VK_FORMAT_R8G8B8A8_UNORM = 37;\nexport const VK_FORMAT_R8G8B8A8_SNORM = 38;\nexport const VK_FORMAT_R8G8B8A8_UINT = 41;\nexport const VK_FORMAT_R8G8B8A8_SINT = 42;\nexport const VK_FORMAT_R8G8B8A8_SRGB = 43;\nexport const VK_FORMAT_B8G8R8A8_UNORM = 44;\nexport const VK_FORMAT_B8G8R8A8_SNORM = 45;\nexport const VK_FORMAT_B8G8R8A8_UINT = 48;\nexport const VK_FORMAT_B8G8R8A8_SINT = 49;\nexport const VK_FORMAT_B8G8R8A8_SRGB = 50;\nexport const VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58;\nexport const VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59;\nexport const VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62;\nexport const VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63;\nexport const VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64;\nexport const VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65;\nexport const VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68;\nexport const VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69;\nexport const VK_FORMAT_R16_UNORM = 70;\nexport const VK_FORMAT_R16_SNORM = 71;\nexport const VK_FORMAT_R16_UINT = 74;\nexport const VK_FORMAT_R16_SINT = 75;\nexport const VK_FORMAT_R16_SFLOAT = 76;\nexport const VK_FORMAT_R16G16_UNORM = 77;\nexport const VK_FORMAT_R16G16_SNORM = 78;\nexport const VK_FORMAT_R16G16_UINT = 81;\nexport const VK_FORMAT_R16G16_SINT = 82;\nexport const VK_FORMAT_R16G16_SFLOAT = 83;\nexport const VK_FORMAT_R16G16B16_UNORM = 84;\nexport const VK_FORMAT_R16G16B16_SNORM = 85;\nexport const VK_FORMAT_R16G16B16_UINT = 88;\nexport const VK_FORMAT_R16G16B16_SINT = 89;\nexport const VK_FORMAT_R16G16B16_SFLOAT = 90;\nexport const VK_FORMAT_R16G16B16A16_UNORM = 91;\nexport const VK_FORMAT_R16G16B16A16_SNORM = 92;\nexport const VK_FORMAT_R16G16B16A16_UINT = 95;\nexport const VK_FORMAT_R16G16B16A16_SINT = 96;\nexport const VK_FORMAT_R16G16B16A16_SFLOAT = 97;\nexport const VK_FORMAT_R32_UINT = 98;\nexport const VK_FORMAT_R32_SINT = 99;\nexport const VK_FORMAT_R32_SFLOAT = 100;\nexport const VK_FORMAT_R32G32_UINT = 101;\nexport const VK_FORMAT_R32G32_SINT = 102;\nexport const VK_FORMAT_R32G32_SFLOAT = 103;\nexport const VK_FORMAT_R32G32B32_UINT = 104;\nexport const VK_FORMAT_R32G32B32_SINT = 105;\nexport const VK_FORMAT_R32G32B32_SFLOAT = 106;\nexport const VK_FORMAT_R32G32B32A32_UINT = 107;\nexport const VK_FORMAT_R32G32B32A32_SINT = 108;\nexport const VK_FORMAT_R32G32B32A32_SFLOAT = 109;\nexport const VK_FORMAT_R64_UINT = 110;\nexport const VK_FORMAT_R64_SINT = 111;\nexport const VK_FORMAT_R64_SFLOAT = 112;\nexport const VK_FORMAT_R64G64_UINT = 113;\nexport const VK_FORMAT_R64G64_SINT = 114;\nexport const VK_FORMAT_R64G64_SFLOAT = 115;\nexport const VK_FORMAT_R64G64B64_UINT = 116;\nexport const VK_FORMAT_R64G64B64_SINT = 117;\nexport const VK_FORMAT_R64G64B64_SFLOAT = 118;\nexport const VK_FORMAT_R64G64B64A64_UINT = 119;\nexport const VK_FORMAT_R64G64B64A64_SINT = 120;\nexport const VK_FORMAT_R64G64B64A64_SFLOAT = 121;\nexport const VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122;\nexport const VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123;\nexport const VK_FORMAT_D16_UNORM = 124;\nexport const VK_FORMAT_X8_D24_UNORM_PACK32 = 125;\nexport const VK_FORMAT_D32_SFLOAT = 126;\nexport const VK_FORMAT_S8_UINT = 127;\nexport const VK_FORMAT_D16_UNORM_S8_UINT = 128;\nexport const VK_FORMAT_D24_UNORM_S8_UINT = 129;\nexport const VK_FORMAT_D32_SFLOAT_S8_UINT = 130;\nexport const VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131;\nexport const VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132;\nexport const VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133;\nexport const VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134;\nexport const VK_FORMAT_BC2_UNORM_BLOCK = 135;\nexport const VK_FORMAT_BC2_SRGB_BLOCK = 136;\nexport const VK_FORMAT_BC3_UNORM_BLOCK = 137;\nexport const VK_FORMAT_BC3_SRGB_BLOCK = 138;\nexport const VK_FORMAT_BC4_UNORM_BLOCK = 139;\nexport const VK_FORMAT_BC4_SNORM_BLOCK = 140;\nexport const VK_FORMAT_BC5_UNORM_BLOCK = 141;\nexport const VK_FORMAT_BC5_SNORM_BLOCK = 142;\nexport const VK_FORMAT_BC6H_UFLOAT_BLOCK = 143;\nexport const VK_FORMAT_BC6H_SFLOAT_BLOCK = 144;\nexport const VK_FORMAT_BC7_UNORM_BLOCK = 145;\nexport const VK_FORMAT_BC7_SRGB_BLOCK = 146;\nexport const VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147;\nexport const VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148;\nexport const VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149;\nexport const VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150;\nexport const VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151;\nexport const VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152;\nexport const VK_FORMAT_EAC_R11_UNORM_BLOCK = 153;\nexport const VK_FORMAT_EAC_R11_SNORM_BLOCK = 154;\nexport const VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155;\nexport const VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156;\nexport const VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157;\nexport const VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158;\nexport const VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159;\nexport const VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160;\nexport const VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161;\nexport const VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162;\nexport const VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163;\nexport const VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164;\nexport const VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165;\nexport const VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166;\nexport const VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167;\nexport const VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168;\nexport const VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169;\nexport const VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170;\nexport const VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171;\nexport const VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172;\nexport const VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173;\nexport const VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174;\nexport const VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175;\nexport const VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176;\nexport const VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177;\nexport const VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178;\nexport const VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179;\nexport const VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180;\nexport const VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181;\nexport const VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182;\nexport const VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183;\nexport const VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184;\nexport const VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007;\nexport const VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008;\nexport const VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009;\nexport const VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010;\nexport const VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011;\nexport const VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017;\nexport const VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018;\nexport const VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019;\nexport const VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020;\nexport const VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021;\nexport const VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000;\nexport const VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001;\nexport const VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002;\nexport const VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003;\nexport const VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004;\nexport const VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005;\nexport const VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006;\nexport const VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007;\nexport const VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT = 1000066000;\nexport const VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT = 1000066001;\nexport const VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT = 1000066002;\nexport const VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT = 1000066003;\nexport const VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT = 1000066004;\nexport const VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT = 1000066005;\nexport const VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT = 1000066006;\nexport const VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT = 1000066007;\nexport const VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT = 1000066008;\nexport const VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT = 1000066009;\nexport const VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT = 1000066010;\nexport const VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT = 1000066011;\nexport const VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT = 1000066012;\nexport const VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT = 1000066013;\nexport const VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT = 1000340000;\nexport const VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT = 1000340001;\n\nexport type VKFormat =\n\t| typeof VK_FORMAT_UNDEFINED\n\t| typeof VK_FORMAT_R4G4_UNORM_PACK8\n\t| typeof VK_FORMAT_R4G4B4A4_UNORM_PACK16\n\t| typeof VK_FORMAT_B4G4R4A4_UNORM_PACK16\n\t| typeof VK_FORMAT_R5G6B5_UNORM_PACK16\n\t| typeof VK_FORMAT_B5G6R5_UNORM_PACK16\n\t| typeof VK_FORMAT_R5G5B5A1_UNORM_PACK16\n\t| typeof VK_FORMAT_B5G5R5A1_UNORM_PACK16\n\t| typeof VK_FORMAT_A1R5G5B5_UNORM_PACK16\n\t| typeof VK_FORMAT_R8_UNORM\n\t| typeof VK_FORMAT_R8_SNORM\n\t| typeof VK_FORMAT_R8_UINT\n\t| typeof VK_FORMAT_R8_SINT\n\t| typeof VK_FORMAT_R8_SRGB\n\t| typeof VK_FORMAT_R8G8_UNORM\n\t| typeof VK_FORMAT_R8G8_SNORM\n\t| typeof VK_FORMAT_R8G8_UINT\n\t| typeof VK_FORMAT_R8G8_SINT\n\t| typeof VK_FORMAT_R8G8_SRGB\n\t| typeof VK_FORMAT_R8G8B8_UNORM\n\t| typeof VK_FORMAT_R8G8B8_SNORM\n\t| typeof VK_FORMAT_R8G8B8_UINT\n\t| typeof VK_FORMAT_R8G8B8_SINT\n\t| typeof VK_FORMAT_R8G8B8_SRGB\n\t| typeof VK_FORMAT_B8G8R8_UNORM\n\t| typeof VK_FORMAT_B8G8R8_SNORM\n\t| typeof VK_FORMAT_B8G8R8_UINT\n\t| typeof VK_FORMAT_B8G8R8_SINT\n\t| typeof VK_FORMAT_B8G8R8_SRGB\n\t| typeof VK_FORMAT_R8G8B8A8_UNORM\n\t| typeof VK_FORMAT_R8G8B8A8_SNORM\n\t| typeof VK_FORMAT_R8G8B8A8_UINT\n\t| typeof VK_FORMAT_R8G8B8A8_SINT\n\t| typeof VK_FORMAT_R8G8B8A8_SRGB\n\t| typeof VK_FORMAT_B8G8R8A8_UNORM\n\t| typeof VK_FORMAT_B8G8R8A8_SNORM\n\t| typeof VK_FORMAT_B8G8R8A8_UINT\n\t| typeof VK_FORMAT_B8G8R8A8_SINT\n\t| typeof VK_FORMAT_B8G8R8A8_SRGB\n\t| typeof VK_FORMAT_A2R10G10B10_UNORM_PACK32\n\t| typeof VK_FORMAT_A2R10G10B10_SNORM_PACK32\n\t| typeof VK_FORMAT_A2R10G10B10_UINT_PACK32\n\t| typeof VK_FORMAT_A2R10G10B10_SINT_PACK32\n\t| typeof VK_FORMAT_A2B10G10R10_UNORM_PACK32\n\t| typeof VK_FORMAT_A2B10G10R10_SNORM_PACK32\n\t| typeof VK_FORMAT_A2B10G10R10_UINT_PACK32\n\t| typeof VK_FORMAT_A2B10G10R10_SINT_PACK32\n\t| typeof VK_FORMAT_R16_UNORM\n\t| typeof VK_FORMAT_R16_SNORM\n\t| typeof VK_FORMAT_R16_UINT\n\t| typeof VK_FORMAT_R16_SINT\n\t| typeof VK_FORMAT_R16_SFLOAT\n\t| typeof VK_FORMAT_R16G16_UNORM\n\t| typeof VK_FORMAT_R16G16_SNORM\n\t| typeof VK_FORMAT_R16G16_UINT\n\t| typeof VK_FORMAT_R16G16_SINT\n\t| typeof VK_FORMAT_R16G16_SFLOAT\n\t| typeof VK_FORMAT_R16G16B16_UNORM\n\t| typeof VK_FORMAT_R16G16B16_SNORM\n\t| typeof VK_FORMAT_R16G16B16_UINT\n\t| typeof VK_FORMAT_R16G16B16_SINT\n\t| typeof VK_FORMAT_R16G16B16_SFLOAT\n\t| typeof VK_FORMAT_R16G16B16A16_UNORM\n\t| typeof VK_FORMAT_R16G16B16A16_SNORM\n\t| typeof VK_FORMAT_R16G16B16A16_UINT\n\t| typeof VK_FORMAT_R16G16B16A16_SINT\n\t| typeof VK_FORMAT_R16G16B16A16_SFLOAT\n\t| typeof VK_FORMAT_R32_UINT\n\t| typeof VK_FORMAT_R32_SINT\n\t| typeof VK_FORMAT_R32_SFLOAT\n\t| typeof VK_FORMAT_R32G32_UINT\n\t| typeof VK_FORMAT_R32G32_SINT\n\t| typeof VK_FORMAT_R32G32_SFLOAT\n\t| typeof VK_FORMAT_R32G32B32_UINT\n\t| typeof VK_FORMAT_R32G32B32_SINT\n\t| typeof VK_FORMAT_R32G32B32_SFLOAT\n\t| typeof VK_FORMAT_R32G32B32A32_UINT\n\t| typeof VK_FORMAT_R32G32B32A32_SINT\n\t| typeof VK_FORMAT_R32G32B32A32_SFLOAT\n\t| typeof VK_FORMAT_R64_UINT\n\t| typeof VK_FORMAT_R64_SINT\n\t| typeof VK_FORMAT_R64_SFLOAT\n\t| typeof VK_FORMAT_R64G64_UINT\n\t| typeof VK_FORMAT_R64G64_SINT\n\t| typeof VK_FORMAT_R64G64_SFLOAT\n\t| typeof VK_FORMAT_R64G64B64_UINT\n\t| typeof VK_FORMAT_R64G64B64_SINT\n\t| typeof VK_FORMAT_R64G64B64_SFLOAT\n\t| typeof VK_FORMAT_R64G64B64A64_UINT\n\t| typeof VK_FORMAT_R64G64B64A64_SINT\n\t| typeof VK_FORMAT_R64G64B64A64_SFLOAT\n\t| typeof VK_FORMAT_B10G11R11_UFLOAT_PACK32\n\t| typeof VK_FORMAT_E5B9G9R9_UFLOAT_PACK32\n\t| typeof VK_FORMAT_D16_UNORM\n\t| typeof VK_FORMAT_X8_D24_UNORM_PACK32\n\t| typeof VK_FORMAT_D32_SFLOAT\n\t| typeof VK_FORMAT_S8_UINT\n\t| typeof VK_FORMAT_D16_UNORM_S8_UINT\n\t| typeof VK_FORMAT_D24_UNORM_S8_UINT\n\t| typeof VK_FORMAT_D32_SFLOAT_S8_UINT\n\t| typeof VK_FORMAT_BC1_RGB_UNORM_BLOCK\n\t| typeof VK_FORMAT_BC1_RGB_SRGB_BLOCK\n\t| typeof VK_FORMAT_BC1_RGBA_UNORM_BLOCK\n\t| typeof VK_FORMAT_BC1_RGBA_SRGB_BLOCK\n\t| typeof VK_FORMAT_BC2_UNORM_BLOCK\n\t| typeof VK_FORMAT_BC2_SRGB_BLOCK\n\t| typeof VK_FORMAT_BC3_UNORM_BLOCK\n\t| typeof VK_FORMAT_BC3_SRGB_BLOCK\n\t| typeof VK_FORMAT_BC4_UNORM_BLOCK\n\t| typeof VK_FORMAT_BC4_SNORM_BLOCK\n\t| typeof VK_FORMAT_BC5_UNORM_BLOCK\n\t| typeof VK_FORMAT_BC5_SNORM_BLOCK\n\t| typeof VK_FORMAT_BC6H_UFLOAT_BLOCK\n\t| typeof VK_FORMAT_BC6H_SFLOAT_BLOCK\n\t| typeof VK_FORMAT_BC7_UNORM_BLOCK\n\t| typeof VK_FORMAT_BC7_SRGB_BLOCK\n\t| typeof VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK\n\t| typeof VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK\n\t| typeof VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK\n\t| typeof VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK\n\t| typeof VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK\n\t| typeof VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK\n\t| typeof VK_FORMAT_EAC_R11_UNORM_BLOCK\n\t| typeof VK_FORMAT_EAC_R11_SNORM_BLOCK\n\t| typeof VK_FORMAT_EAC_R11G11_UNORM_BLOCK\n\t| typeof VK_FORMAT_EAC_R11G11_SNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_4x4_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_4x4_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_5x4_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_5x4_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_5x5_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_5x5_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_6x5_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_6x5_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_6x6_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_6x6_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_8x5_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_8x5_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_8x6_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_8x6_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_8x8_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_8x8_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_10x5_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_10x5_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_10x6_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_10x6_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_10x8_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_10x8_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_10x10_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_10x10_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_12x10_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_12x10_SRGB_BLOCK\n\t| typeof VK_FORMAT_ASTC_12x12_UNORM_BLOCK\n\t| typeof VK_FORMAT_ASTC_12x12_SRGB_BLOCK\n\t| typeof VK_FORMAT_R10X6_UNORM_PACK16\n\t| typeof VK_FORMAT_R10X6G10X6_UNORM_2PACK16\n\t| typeof VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16\n\t| typeof VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16\n\t| typeof VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16\n\t| typeof VK_FORMAT_R12X4_UNORM_PACK16\n\t| typeof VK_FORMAT_R12X4G12X4_UNORM_2PACK16\n\t| typeof VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16\n\t| typeof VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16\n\t| typeof VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16\n\t| typeof VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG\n\t| typeof VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG\n\t| typeof VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG\n\t| typeof VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG\n\t| typeof VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG\n\t| typeof VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG\n\t| typeof VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG\n\t| typeof VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG\n\t| typeof VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT\n\t| typeof VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT\n\t| typeof VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT;\n", "import {\n\tKHR_DF_FLAG_ALPHA_STRAIGHT,\n\tKHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT,\n\tKHR_DF_MODEL_UNSPECIFIED,\n\tKHR_DF_PRIMARIES_BT709,\n\tKHR_DF_TRANSFER_SRGB,\n\tKHR_DF_VENDORID_KHRONOS,\n\tKHR_DF_VERSION,\n\tKHR_SUPERCOMPRESSION_NONE,\n\tSupercompression,\n\tVKFormat,\n\tVK_FORMAT_UNDEFINED,\n} from './constants.js';\n\n/**\n * Represents an unpacked KTX 2.0 texture container. Data for individual mip levels are stored in\n * the `.levels` array, typically compressed in Basis Universal formats. Additional properties\n * provide metadata required to process, transcode, and upload these textures.\n */\nexport class KTX2Container {\n\t/**\n\t * Specifies the image format using Vulkan VkFormat enum values. When using Basis Universal\n\t * texture formats, `vkFormat` must be VK_FORMAT_UNDEFINED.\n\t */\n\tpublic vkFormat: VKFormat = VK_FORMAT_UNDEFINED;\n\n\t/**\n\t * Size of the data type in bytes used to upload the data to a graphics API. When `vkFormat` is\n\t * VK_FORMAT_UNDEFINED, `typeSize` must be 1.\n\t */\n\tpublic typeSize = 1;\n\n\t/** Width of the texture image for level 0, in pixels. */\n\tpublic pixelWidth = 0;\n\n\t/** Height of the texture image for level 0, in pixels. */\n\tpublic pixelHeight = 0;\n\n\t/** Depth of the texture image for level 0, in pixels (3D textures only). */\n\tpublic pixelDepth = 0;\n\n\t/** Number of array elements (array textures only). */\n\tpublic layerCount = 0;\n\n\t/**\n\t * Number of cubemap faces. For cubemaps and cubemap arrays, `faceCount` must be 6. For all\n\t * other textures, `faceCount` must be 1. Cubemap faces are stored in +X, -X, +Y, -Y, +Z, -Z\n\t * order.\n\t */\n\tpublic faceCount = 1;\n\n\t/** Indicates which supercompression scheme has been applied to mip level images, if any. */\n\tpublic supercompressionScheme: Supercompression = KHR_SUPERCOMPRESSION_NONE;\n\n\t/** Mip levels, ordered largest (original) to smallest (~1px). */\n\tpublic levels: KTX2Level[] = [];\n\n\t/** Data Format Descriptor. */\n\tpublic dataFormatDescriptor: KTX2DataFormatDescriptorBasicFormat[] = [\n\t\t{\n\t\t\tvendorId: KHR_DF_VENDORID_KHRONOS,\n\t\t\tdescriptorType: KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT,\n\t\t\tdescriptorBlockSize: 0,\n\t\t\tversionNumber: KHR_DF_VERSION,\n\t\t\tcolorModel: KHR_DF_MODEL_UNSPECIFIED,\n\t\t\tcolorPrimaries: KHR_DF_PRIMARIES_BT709,\n\t\t\ttransferFunction: KHR_DF_TRANSFER_SRGB,\n\t\t\tflags: KHR_DF_FLAG_ALPHA_STRAIGHT,\n\t\t\ttexelBlockDimension: [0, 0, 0, 0],\n\t\t\tbytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],\n\t\t\tsamples: [],\n\t\t},\n\t];\n\n\t/** Key/Value Data. */\n\tpublic keyValue: { [key: string]: string | Uint8Array } = {};\n\n\t/** Supercompression Global Data. */\n\tpublic globalData: KTX2GlobalDataBasisLZ | null = null;\n}\n\n///////////////////////////////////////////////////\n// Mip Levels.\n///////////////////////////////////////////////////\n\nexport interface KTX2Level {\n\t/** Compressed data of the mip level. */\n\tlevelData: Uint8Array;\n\n\t/**\n\t * Size of the mip level after reflation from supercompression, if applicable. When\n\t * `supercompressionType` is BASISLZ, `uncompressedByteLength` must be 0. When\n\t * `supercompressionType` is `NONE`, `uncompressedByteLength` must match the `levelData` byte\n\t * length.\n\t *\n\t * _**NOTICE:** this implies that for formats such as UASTC, `uncompressedByteLength` may\n\t * indicate size after ZSTD reflation (and of transcoded ASTC data), but does _not_ indicate\n\t * size of decoded RGBA32 pixels._\n\t */\n\tuncompressedByteLength: number;\n}\n\n///////////////////////////////////////////////////\n// Data Format Descriptor (DFD).\n///////////////////////////////////////////////////\n\nexport interface KTX2DataFormatDescriptorBasicFormat {\n\tvendorId: number;\n\tdescriptorType: number;\n\tversionNumber: number;\n\t/** @deprecated Inferred. */\n\tdescriptorBlockSize: number;\n\tcolorModel: number;\n\tcolorPrimaries: number;\n\ttransferFunction: number;\n\tflags: number;\n\ttexelBlockDimension: [number, number, number, number];\n\tbytesPlane: [number, number, number, number, number, number, number, number];\n\tsamples: KTX2BasicFormatSample[];\n}\n\nexport interface KTX2BasicFormatSample {\n\tbitOffset: number;\n\tbitLength: number;\n\t/** @deprecated Renamed to 'channelType'. */\n\tchannelID?: number;\n\tchannelType: number;\n\tsamplePosition: number[];\n\tsampleLower: number;\n\tsampleUpper: number;\n}\n\n///////////////////////////////////////////////////\n// Supercompression Global Data.\n///////////////////////////////////////////////////\n\nexport interface KTX2GlobalDataBasisLZ {\n\tendpointCount: number;\n\tselectorCount: number;\n\timageDescs: KTX2GlobalDataBasisLZImageDesc[];\n\tendpointsData: Uint8Array;\n\tselectorsData: Uint8Array;\n\ttablesData: Uint8Array;\n\textendedData: Uint8Array;\n}\n\ninterface KTX2GlobalDataBasisLZImageDesc {\n\timageFlags: number;\n\trgbSliceByteOffset: number;\n\trgbSliceByteLength: number;\n\talphaSliceByteOffset: number;\n\talphaSliceByteLength: number;\n}\n", "export class BufferReader {\n\tprivate _dataView: DataView;\n\tprivate _littleEndian: boolean;\n\tpublic _offset: number;\n\n\tconstructor(data: Uint8Array, byteOffset: number, byteLength: number, littleEndian: boolean) {\n\t\tthis._dataView = new DataView(data.buffer, data.byteOffset + byteOffset, byteLength);\n\t\tthis._littleEndian = littleEndian;\n\t\tthis._offset = 0;\n\t}\n\n\t_nextUint8() {\n\t\tconst value = this._dataView.getUint8(this._offset);\n\t\tthis._offset += 1;\n\t\treturn value;\n\t}\n\n\t_nextUint16() {\n\t\tconst value = this._dataView.getUint16(this._offset, this._littleEndian);\n\t\tthis._offset += 2;\n\t\treturn value;\n\t}\n\n\t_nextUint32() {\n\t\tconst value = this._dataView.getUint32(this._offset, this._littleEndian);\n\t\tthis._offset += 4;\n\t\treturn value;\n\t}\n\n\t_nextUint64() {\n\t\tconst left = this._dataView.getUint32(this._offset, this._littleEndian);\n\t\tconst right = this._dataView.getUint32(this._offset + 4, this._littleEndian);\n\t\t// TODO(cleanup): Just test this...\n\t\t// const value = this._littleEndian ? left + (2 ** 32 * right) : (2 ** 32 * left) + right;\n\t\tconst value = left + 2 ** 32 * right;\n\t\tthis._offset += 8;\n\t\treturn value;\n\t}\n\n\t_nextInt32() {\n\t\tconst value = this._dataView.getInt32(this._offset, this._littleEndian);\n\t\tthis._offset += 4;\n\t\treturn value;\n\t}\n\n\t_nextUint8Array(len: number) {\n\t\tconst value = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._offset, len);\n\t\tthis._offset += len;\n\t\treturn value;\n\t}\n\n\t_skip(bytes: number) {\n\t\tthis._offset += bytes;\n\t\treturn this;\n\t}\n\n\t_scan(maxByteLength: number, term = 0x00): Uint8Array {\n\t\tconst byteOffset = this._offset;\n\t\tlet byteLength = 0;\n\t\twhile (this._dataView.getUint8(this._offset) !== term && byteLength < maxByteLength) {\n\t\t\tbyteLength++;\n\t\t\tthis._offset++;\n\t\t}\n\n\t\tif (byteLength < maxByteLength) this._offset++;\n\n\t\treturn new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + byteOffset, byteLength);\n\t}\n}\n", "///////////////////////////////////////////////////\n// Common.\n///////////////////////////////////////////////////\n\n// Injected at compile time, from $npm_package_version.\ndeclare const PACKAGE_VERSION: string;\n\nexport const KTX_WRITER = `KTX-Parse v${PACKAGE_VERSION}`;\n\nexport const NUL = new Uint8Array([0x00]);\n\nexport type vec3 = [number, number, number];\nexport type vec2 = [number, number, number];\n\n///////////////////////////////////////////////////\n// KTX2 Header.\n///////////////////////////////////////////////////\n\nexport const KTX2_ID = [\n\t// '', 'K', 'T', 'X', '2', '0', '', '\\r', '\\n', '\\x1A', '\\n'\n\t0xab, 0x4b, 0x54, 0x58, 0x20, 0x32, 0x30, 0xbb, 0x0d, 0x0a, 0x1a, 0x0a,\n];\n\nexport const HEADER_BYTE_LENGTH = 68; // 13 * 4 + 2 * 8\n", "import { vec3 } from './constants-internal.js';\nimport {\n\tVKFormat,\n\tVK_FORMAT_ASTC_10x10_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_10x10_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_10x5_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_10x5_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_10x6_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_10x6_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_10x8_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_10x8_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_12x10_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_12x10_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_12x12_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_12x12_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_4x4_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_4x4_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_5x4_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_5x4_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_5x5_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_5x5_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_6x5_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_6x5_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_6x6_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_6x6_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_8x5_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_8x5_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_8x6_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_8x6_UNORM_BLOCK,\n\tVK_FORMAT_ASTC_8x8_SRGB_BLOCK,\n\tVK_FORMAT_ASTC_8x8_UNORM_BLOCK,\n\tVK_FORMAT_BC1_RGB_UNORM_BLOCK,\n\tVK_FORMAT_BC7_SRGB_BLOCK,\n\tVK_FORMAT_EAC_R11G11_SNORM_BLOCK,\n\tVK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,\n\tVK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG,\n\tVK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG,\n\tVK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG,\n\tVK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG,\n\tVK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG,\n\tVK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG,\n\tVK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG,\n\tVK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG,\n\tVK_FORMAT_UNDEFINED,\n} from './constants.js';\nimport type { KTX2Container } from './container.js';\n\n/** Encodes text to an ArrayBuffer. */\nexport function encodeText(text: string): Uint8Array {\n\treturn new TextEncoder().encode(text);\n}\n\n/** Decodes an ArrayBuffer to text. */\nexport function decodeText(buffer: Uint8Array): string {\n\treturn new TextDecoder().decode(buffer);\n}\n\n/** Concatenates N ArrayBuffers. */\nexport function concat(buffers: (ArrayBuffer | Uint8Array)[]): Uint8Array {\n\tlet totalByteLength = 0;\n\tfor (const buffer of buffers) {\n\t\ttotalByteLength += buffer.byteLength;\n\t}\n\n\tconst result = new Uint8Array(totalByteLength);\n\tlet byteOffset = 0;\n\n\tfor (const buffer of buffers) {\n\t\tresult.set(new Uint8Array(buffer), byteOffset);\n\t\tbyteOffset += buffer.byteLength;\n\t}\n\n\treturn result;\n}\n\n/** Returns the least common multiple (LCM) for two positive integers. */\nexport function leastCommonMultiple(a: number, b: number): number {\n\tconst max = Math.max(a, b);\n\tconst min = Math.min(a, b);\n\tlet lcm = max;\n\n\twhile (lcm % min !== 0) {\n\t\tlcm += max;\n\t}\n\n\treturn lcm;\n}\n\n/**\n * Returns amount of padding, in bytes, required to pad a value V to N-byte\n * boundaries. Both V and N must be positive integers.\n */\nexport function getPadding(v: number, n = 4): number {\n\treturn Math.ceil(v / n) * n - v;\n}\n\n/** Returns byte length per texel block. */\nexport function getBlockByteLength(container: KTX2Container): number {\n\treturn container.levels[0].levelData.byteLength / getBlockCount(container, 0);\n}\n\n/**\n * Returns total number of blocks for given level. For VK_FORMAT_UNDEFINED, DFD is required.\n *\n * References:\n * - https://github.khronos.org/KTX-Specification/ktxspec.v2.html#levelImages\n */\nexport function getBlockCount(container: KTX2Container, levelIndex: number): number {\n\tlet blockCount = 1;\n\n\tconst pixelDimensions = [container.pixelWidth, container.pixelHeight, container.pixelDepth];\n\tconst blockDimensions = getBlockDimensions(container);\n\n\tfor (let i = 0; i < 3; i++) {\n\t\tif (pixelDimensions[i] > 0) {\n\t\t\tconst dimBlockCount = Math.ceil(\n\t\t\t\tMath.floor(pixelDimensions[i] * Math.pow(2, -levelIndex)) / blockDimensions[i],\n\t\t\t);\n\t\t\tblockCount *= Math.max(1, dimBlockCount);\n\t\t}\n\t}\n\n\tif (container.layerCount > 0) {\n\t\tblockCount *= container.layerCount;\n\t}\n\n\tif (container.faceCount > 0) {\n\t\tblockCount *= container.faceCount;\n\t}\n\n\treturn blockCount;\n}\n\n/**\n * Given a KTX2 container, returns block dimensions as [width, height, depth]. Requires valid DFD.\n */\nexport function getBlockDimensions(container: KTX2Container): vec3 {\n\tconst [x, y, z] = container.dataFormatDescriptor[0].texelBlockDimension;\n\treturn [x + 1, y + 1, z + 1];\n}\n\n/**\n * Given `vkFormat`, returns block dimensions as [width, height, depth]. Does not support\n * VK_FORMAT_UNDEFINED.\n *\n * References:\n * - https://github.khronos.org/KTX-Specification/ktxspec.v2.html#_mippadding\n * - https://registry.khronos.org/vulkan/specs/1.2-extensions/html/vkspec.html#formats-compatibility\n */\nexport function getBlockDimensionsByVKFormat(vkFormat: VKFormat): vec3 {\n\tif (vkFormat === VK_FORMAT_UNDEFINED) {\n\t\tthrow new Error('Unknown block dimensions for VK_FORMAT_UNDEFINED.');\n\t} else if (vkFormat >= VK_FORMAT_BC1_RGB_UNORM_BLOCK && vkFormat <= VK_FORMAT_BC7_SRGB_BLOCK) {\n\t\treturn [4, 4, 1];\n\t} else if (vkFormat >= VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK && vkFormat <= VK_FORMAT_EAC_R11G11_SNORM_BLOCK) {\n\t\treturn [4, 4, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_4x4_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_4x4_SRGB_BLOCK) {\n\t\treturn [4, 4, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_5x4_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_5x4_SRGB_BLOCK) {\n\t\treturn [5, 4, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_5x5_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_5x5_SRGB_BLOCK) {\n\t\treturn [5, 5, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_6x5_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_6x5_SRGB_BLOCK) {\n\t\treturn [6, 5, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_6x6_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_6x6_SRGB_BLOCK) {\n\t\treturn [6, 6, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_8x5_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_8x5_SRGB_BLOCK) {\n\t\treturn [8, 5, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_8x6_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_8x6_SRGB_BLOCK) {\n\t\treturn [8, 6, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_8x8_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_8x8_SRGB_BLOCK) {\n\t\treturn [8, 8, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_10x5_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_10x5_SRGB_BLOCK) {\n\t\treturn [10, 5, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_10x6_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_10x6_SRGB_BLOCK) {\n\t\treturn [10, 6, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_10x8_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_10x8_SRGB_BLOCK) {\n\t\treturn [10, 8, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_10x10_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_10x10_SRGB_BLOCK) {\n\t\treturn [10, 10, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_12x10_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_12x10_SRGB_BLOCK) {\n\t\treturn [12, 10, 1];\n\t} else if (vkFormat === VK_FORMAT_ASTC_12x12_UNORM_BLOCK || vkFormat === VK_FORMAT_ASTC_12x12_SRGB_BLOCK) {\n\t\treturn [12, 12, 1];\n\t} else if (\n\t\tvkFormat === VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG ||\n\t\tvkFormat === VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG ||\n\t\tvkFormat === VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG ||\n\t\tvkFormat === VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG\n\t) {\n\t\treturn [8, 4, 1];\n\t} else if (\n\t\tvkFormat === VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG ||\n\t\tvkFormat === VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG ||\n\t\tvkFormat === VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG ||\n\t\tvkFormat === VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG\n\t) {\n\t\treturn [4, 4, 1];\n\t} else {\n\t\treturn [1, 1, 1];\n\t}\n}\n", "import { BufferReader } from './buffer-reader.js';\nimport { KHR_DF_SAMPLE_DATATYPE_SIGNED, Supercompression, VKFormat } from './constants.js';\nimport { KTX2_ID } from './constants-internal.js';\nimport { KTX2Container, KTX2DataFormatDescriptorBasicFormat } from './container.js';\nimport { decodeText } from './util.js';\n\n/**\n * Parses a KTX 2.0 file, returning an unpacked {@link KTX2Container} instance with all associated\n * data. The container's mip levels and other binary data are pointers into the original file, not\n * copies, so the original file should not be overwritten after reading.\n *\n * @param data Bytes of KTX 2.0 file, as Uint8Array or Buffer.\n */\nexport function read(data: Uint8Array): KTX2Container {\n\t///////////////////////////////////////////////////\n\t// KTX 2.0 Identifier.\n\t///////////////////////////////////////////////////\n\n\tconst id = new Uint8Array(data.buffer, data.byteOffset, KTX2_ID.length);\n\tif (\n\t\tid[0] !== KTX2_ID[0] || // ''\n\t\tid[1] !== KTX2_ID[1] || // 'K'\n\t\tid[2] !== KTX2_ID[2] || // 'T'\n\t\tid[3] !== KTX2_ID[3] || // 'X'\n\t\tid[4] !== KTX2_ID[4] || // ' '\n\t\tid[5] !== KTX2_ID[5] || // '2'\n\t\tid[6] !== KTX2_ID[6] || // '0'\n\t\tid[7] !== KTX2_ID[7] || // ''\n\t\tid[8] !== KTX2_ID[8] || // '\\r'\n\t\tid[9] !== KTX2_ID[9] || // '\\n'\n\t\tid[10] !== KTX2_ID[10] || // '\\x1A'\n\t\tid[11] !== KTX2_ID[11] // '\\n'\n\t) {\n\t\tthrow new Error('Missing KTX 2.0 identifier.');\n\t}\n\n\tconst container = new KTX2Container();\n\n\t///////////////////////////////////////////////////\n\t// Header.\n\t///////////////////////////////////////////////////\n\n\tconst headerByteLength = 17 * Uint32Array.BYTES_PER_ELEMENT;\n\tconst headerReader = new BufferReader(data, KTX2_ID.length, headerByteLength, true);\n\n\tcontainer.vkFormat = headerReader._nextUint32() as VKFormat;\n\tcontainer.typeSize = headerReader._nextUint32();\n\tcontainer.pixelWidth = headerReader._nextUint32();\n\tcontainer.pixelHeight = headerReader._nextUint32();\n\tcontainer.pixelDepth = headerReader._nextUint32();\n\tcontainer.layerCount = headerReader._nextUint32();\n\tcontainer.faceCount = headerReader._nextUint32();\n\n\tconst levelCount = headerReader._nextUint32();\n\n\tcontainer.supercompressionScheme = headerReader._nextUint32() as Supercompression;\n\n\tconst dfdByteOffset = headerReader._nextUint32();\n\tconst dfdByteLength = headerReader._nextUint32();\n\tconst kvdByteOffset = headerReader._nextUint32();\n\tconst kvdByteLength = headerReader._nextUint32();\n\tconst sgdByteOffset = headerReader._nextUint64();\n\tconst sgdByteLength = headerReader._nextUint64();\n\n\t///////////////////////////////////////////////////\n\t// Level Index.\n\t///////////////////////////////////////////////////\n\n\tconst levelByteLength = levelCount * 3 * 8;\n\tconst levelReader = new BufferReader(data, KTX2_ID.length + headerByteLength, levelByteLength, true);\n\n\tfor (let i = 0; i < levelCount; i++) {\n\t\tcontainer.levels.push({\n\t\t\tlevelData: new Uint8Array(\n\t\t\t\tdata.buffer,\n\t\t\t\tdata.byteOffset + levelReader._nextUint64(),\n\t\t\t\tlevelReader._nextUint64(),\n\t\t\t),\n\t\t\tuncompressedByteLength: levelReader._nextUint64(),\n\t\t});\n\t}\n\n\t///////////////////////////////////////////////////\n\t// Data Format Descriptor (DFD).\n\t///////////////////////////////////////////////////\n\n\tconst dfdReader = new BufferReader(data, dfdByteOffset, dfdByteLength, true);\n\n\tconst dfd: KTX2DataFormatDescriptorBasicFormat = {\n\t\tvendorId: dfdReader._skip(4 /* totalSize */)._nextUint16(),\n\t\tdescriptorType: dfdReader._nextUint16(),\n\t\tversionNumber: dfdReader._nextUint16(),\n\t\tdescriptorBlockSize: dfdReader._nextUint16(),\n\t\tcolorModel: dfdReader._nextUint8(),\n\t\tcolorPrimaries: dfdReader._nextUint8(),\n\t\ttransferFunction: dfdReader._nextUint8(),\n\t\tflags: dfdReader._nextUint8(),\n\t\ttexelBlockDimension: [\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t],\n\t\tbytesPlane: [\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t],\n\t\tsamples: [],\n\t};\n\n\tconst sampleStart = 6;\n\tconst sampleWords = 4;\n\tconst numSamples = (dfd.descriptorBlockSize / 4 - sampleStart) / sampleWords;\n\n\tfor (let i = 0; i < numSamples; i++) {\n\t\tconst sample = {\n\t\t\tbitOffset: dfdReader._nextUint16(),\n\t\t\tbitLength: dfdReader._nextUint8(),\n\t\t\tchannelType: dfdReader._nextUint8(),\n\t\t\tsamplePosition: [\n\t\t\t\tdfdReader._nextUint8(),\n\t\t\t\tdfdReader._nextUint8(),\n\t\t\t\tdfdReader._nextUint8(),\n\t\t\t\tdfdReader._nextUint8(),\n\t\t\t],\n\t\t\tsampleLower: -Infinity,\n\t\t\tsampleUpper: Infinity,\n\t\t};\n\n\t\tif (sample.channelType & KHR_DF_SAMPLE_DATATYPE_SIGNED) {\n\t\t\tsample.sampleLower = dfdReader._nextInt32();\n\t\t\tsample.sampleUpper = dfdReader._nextInt32();\n\t\t} else {\n\t\t\tsample.sampleLower = dfdReader._nextUint32();\n\t\t\tsample.sampleUpper = dfdReader._nextUint32();\n\t\t}\n\n\t\tdfd.samples[i] = sample;\n\t}\n\n\tcontainer.dataFormatDescriptor.length = 0;\n\tcontainer.dataFormatDescriptor.push(dfd);\n\n\t///////////////////////////////////////////////////\n\t// Key/Value Data (KVD).\n\t///////////////////////////////////////////////////\n\n\tconst kvdReader = new BufferReader(data, kvdByteOffset, kvdByteLength, true);\n\n\twhile (kvdReader._offset < kvdByteLength) {\n\t\tconst keyValueByteLength = kvdReader._nextUint32();\n\t\tconst keyData = kvdReader._scan(keyValueByteLength);\n\t\tconst key = decodeText(keyData);\n\n\t\tcontainer.keyValue[key] = kvdReader._nextUint8Array(keyValueByteLength - keyData.byteLength - 1);\n\n\t\tif (key.match(/^ktx/i)) {\n\t\t\tconst text = decodeText(container.keyValue[key] as Uint8Array);\n\t\t\tcontainer.keyValue[key] = text.substring(0, text.lastIndexOf('\\x00'));\n\t\t}\n\n\t\tconst kvPadding = keyValueByteLength % 4 ? 4 - (keyValueByteLength % 4) : 0; // align(4)\n\t\t// 4-byte alignment.\n\t\tkvdReader._skip(kvPadding);\n\t}\n\n\t///////////////////////////////////////////////////\n\t// Supercompression Global Data (SGD).\n\t///////////////////////////////////////////////////\n\n\tif (sgdByteLength <= 0) return container;\n\n\tconst sgdReader = new BufferReader(data, sgdByteOffset, sgdByteLength, true);\n\n\tconst endpointCount = sgdReader._nextUint16();\n\tconst selectorCount = sgdReader._nextUint16();\n\tconst endpointsByteLength = sgdReader._nextUint32();\n\tconst selectorsByteLength = sgdReader._nextUint32();\n\tconst tablesByteLength = sgdReader._nextUint32();\n\tconst extendedByteLength = sgdReader._nextUint32();\n\n\tconst imageDescs = [];\n\tfor (let i = 0; i < levelCount; i++) {\n\t\timageDescs.push({\n\t\t\timageFlags: sgdReader._nextUint32(),\n\t\t\trgbSliceByteOffset: sgdReader._nextUint32(),\n\t\t\trgbSliceByteLength: sgdReader._nextUint32(),\n\t\t\talphaSliceByteOffset: sgdReader._nextUint32(),\n\t\t\talphaSliceByteLength: sgdReader._nextUint32(),\n\t\t});\n\t}\n\n\tconst endpointsByteOffset = sgdByteOffset + sgdReader._offset;\n\tconst selectorsByteOffset = endpointsByteOffset + endpointsByteLength;\n\tconst tablesByteOffset = selectorsByteOffset + selectorsByteLength;\n\tconst extendedByteOffset = tablesByteOffset + tablesByteLength;\n\n\tconst endpointsData = new Uint8Array(data.buffer, data.byteOffset + endpointsByteOffset, endpointsByteLength);\n\tconst selectorsData = new Uint8Array(data.buffer, data.byteOffset + selectorsByteOffset, selectorsByteLength);\n\tconst tablesData = new Uint8Array(data.buffer, data.byteOffset + tablesByteOffset, tablesByteLength);\n\tconst extendedData = new Uint8Array(data.buffer, data.byteOffset + extendedByteOffset, extendedByteLength);\n\n\tcontainer.globalData = {\n\t\tendpointCount,\n\t\tselectorCount,\n\t\timageDescs,\n\t\tendpointsData,\n\t\tselectorsData,\n\t\ttablesData,\n\t\textendedData,\n\t};\n\n\treturn container;\n}\n", "import { HEADER_BYTE_LENGTH, KTX2_ID, KTX_WRITER, NUL } from './constants-internal.js';\nimport {\n\tKHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT,\n\tKHR_DF_SAMPLE_DATATYPE_SIGNED,\n\tKHR_SUPERCOMPRESSION_NONE,\n} from './constants.js';\nimport { KTX2Container } from './container.js';\nimport { concat, encodeText, getBlockByteLength, getPadding, leastCommonMultiple } from './util.js';\n\ninterface WriteOptions {\n\tkeepWriter?: boolean;\n}\nconst DEFAULT_OPTIONS: WriteOptions = { keepWriter: false };\n\n/**\n * Serializes a {@link KTX2Container} instance to a KTX 2.0 file. Mip levels and other binary data\n * are copied into the resulting Uint8Array, so the original container can safely be edited or\n * destroyed after it is serialized.\n *\n * Options:\n * - keepWriter: If true, 'KTXWriter' key/value field is written as provided by the container.\n * \t\tOtherwise, a string for the current ktx-parse version is generated. Default: false.\n *\n * @param container\n * @param options\n */\nexport function write(container: KTX2Container, options: WriteOptions = {}): Uint8Array {\n\toptions = { ...DEFAULT_OPTIONS, ...options };\n\n\t///////////////////////////////////////////////////\n\t// Supercompression Global Data (SGD).\n\t///////////////////////////////////////////////////\n\n\tlet sgdBuffer = new ArrayBuffer(0);\n\tif (container.globalData) {\n\t\tconst sgdHeaderBuffer = new ArrayBuffer(20 + container.globalData.imageDescs.length * 5 * 4);\n\t\tconst sgdHeaderView = new DataView(sgdHeaderBuffer);\n\t\tsgdHeaderView.setUint16(0, container.globalData.endpointCount, true);\n\t\tsgdHeaderView.setUint16(2, container.globalData.selectorCount, true);\n\t\tsgdHeaderView.setUint32(4, container.globalData.endpointsData.byteLength, true);\n\t\tsgdHeaderView.setUint32(8, container.globalData.selectorsData.byteLength, true);\n\t\tsgdHeaderView.setUint32(12, container.globalData.tablesData.byteLength, true);\n\t\tsgdHeaderView.setUint32(16, container.globalData.extendedData.byteLength, true);\n\n\t\tfor (let i = 0; i < container.globalData.imageDescs.length; i++) {\n\t\t\tconst imageDesc = container.globalData.imageDescs[i];\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 0, imageDesc.imageFlags, true);\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 4, imageDesc.rgbSliceByteOffset, true);\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 8, imageDesc.rgbSliceByteLength, true);\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 12, imageDesc.alphaSliceByteOffset, true);\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 16, imageDesc.alphaSliceByteLength, true);\n\t\t}\n\n\t\tsgdBuffer = concat([\n\t\t\tsgdHeaderBuffer,\n\t\t\tcontainer.globalData.endpointsData,\n\t\t\tcontainer.globalData.selectorsData,\n\t\t\tcontainer.globalData.tablesData,\n\t\t\tcontainer.globalData.extendedData,\n\t\t]);\n\t}\n\n\t///////////////////////////////////////////////////\n\t// Key/Value Data (KVD).\n\t///////////////////////////////////////////////////\n\n\tconst keyValueData: Uint8Array[] = [];\n\tlet keyValue = container.keyValue;\n\n\tif (!options.keepWriter) {\n\t\tkeyValue = { ...container.keyValue, KTXwriter: KTX_WRITER };\n\t}\n\n\tfor (const key in keyValue) {\n\t\tconst value = keyValue[key];\n\t\tconst keyData = encodeText(key);\n\t\tconst valueData = typeof value === 'string' ? concat([encodeText(value), NUL]) : value;\n\t\tconst kvByteLength = keyData.byteLength + 1 + valueData.byteLength;\n\t\tconst kvPadding = getPadding(kvByteLength, 4); // align(4)\n\t\tkeyValueData.push(\n\t\t\tconcat([\n\t\t\t\tnew Uint32Array([kvByteLength]),\n\t\t\t\tkeyData,\n\t\t\t\tNUL,\n\t\t\t\tvalueData,\n\t\t\t\tnew Uint8Array(kvPadding).fill(0x00), // align(4)\n\t\t\t]),\n\t\t);\n\t}\n\n\tconst kvdBuffer = concat(keyValueData);\n\n\t///////////////////////////////////////////////////\n\t// Data Format Descriptor (DFD).\n\t///////////////////////////////////////////////////\n\n\tif (\n\t\tcontainer.dataFormatDescriptor.length !== 1 ||\n\t\tcontainer.dataFormatDescriptor[0].descriptorType !== KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT\n\t) {\n\t\tthrow new Error('Only BASICFORMAT Data Format Descriptor output supported.');\n\t}\n\n\tconst dfd = container.dataFormatDescriptor[0];\n\n\tconst dfdBuffer = new ArrayBuffer(28 + dfd.samples.length * 16);\n\tconst dfdView = new DataView(dfdBuffer);\n\tconst descriptorBlockSize = 24 + dfd.samples.length * 16;\n\n\tdfdView.setUint32(0, dfdBuffer.byteLength, true);\n\tdfdView.setUint16(4, dfd.vendorId, true);\n\tdfdView.setUint16(6, dfd.descriptorType, true);\n\tdfdView.setUint16(8, dfd.versionNumber, true);\n\tdfdView.setUint16(10, descriptorBlockSize, true);\n\n\tdfdView.setUint8(12, dfd.colorModel);\n\tdfdView.setUint8(13, dfd.colorPrimaries);\n\tdfdView.setUint8(14, dfd.transferFunction);\n\tdfdView.setUint8(15, dfd.flags);\n\n\tif (!Array.isArray(dfd.texelBlockDimension)) {\n\t\tthrow new Error('texelBlockDimension is now an array. For dimensionality `d`, set `d - 1`.');\n\t}\n\n\tdfdView.setUint8(16, dfd.texelBlockDimension[0]);\n\tdfdView.setUint8(17, dfd.texelBlockDimension[1]);\n\tdfdView.setUint8(18, dfd.texelBlockDimension[2]);\n\tdfdView.setUint8(19, dfd.texelBlockDimension[3]);\n\n\tfor (let i = 0; i < 8; i++) dfdView.setUint8(20 + i, dfd.bytesPlane[i]);\n\n\tfor (let i = 0; i < dfd.samples.length; i++) {\n\t\tconst sample = dfd.samples[i];\n\t\tconst sampleByteOffset = 28 + i * 16;\n\n\t\tif (sample.channelID) {\n\t\t\tthrow new Error('channelID has been renamed to channelType.');\n\t\t}\n\n\t\tdfdView.setUint16(sampleByteOffset + 0, sample.bitOffset, true);\n\t\tdfdView.setUint8(sampleByteOffset + 2, sample.bitLength);\n\t\tdfdView.setUint8(sampleByteOffset + 3, sample.channelType);\n\n\t\tdfdView.setUint8(sampleByteOffset + 4, sample.samplePosition[0]);\n\t\tdfdView.setUint8(sampleByteOffset + 5, sample.samplePosition[1]);\n\t\tdfdView.setUint8(sampleByteOffset + 6, sample.samplePosition[2]);\n\t\tdfdView.setUint8(sampleByteOffset + 7, sample.samplePosition[3]);\n\n\t\tif (sample.channelType & KHR_DF_SAMPLE_DATATYPE_SIGNED) {\n\t\t\tdfdView.setInt32(sampleByteOffset + 8, sample.sampleLower, true);\n\t\t\tdfdView.setInt32(sampleByteOffset + 12, sample.sampleUpper, true);\n\t\t} else {\n\t\t\tdfdView.setUint32(sampleByteOffset + 8, sample.sampleLower, true);\n\t\t\tdfdView.setUint32(sampleByteOffset + 12, sample.sampleUpper, true);\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////\n\t// Data alignment.\n\t///////////////////////////////////////////////////\n\n\tconst dfdByteOffset = KTX2_ID.length + HEADER_BYTE_LENGTH + container.levels.length * 3 * 8;\n\tconst kvdByteOffset = dfdByteOffset + dfdBuffer.byteLength;\n\tlet sgdByteOffset = sgdBuffer.byteLength > 0 ? kvdByteOffset + kvdBuffer.byteLength : 0;\n\tif (sgdByteOffset % 8) sgdByteOffset += 8 - (sgdByteOffset % 8); // align(8)\n\n\t///////////////////////////////////////////////////\n\t// Level Index.\n\t///////////////////////////////////////////////////\n\n\tconst levelData: Uint8Array[] = [];\n\tconst levelIndex = new DataView(new ArrayBuffer(container.levels.length * 3 * 8));\n\tconst levelDataByteOffsets = new Uint32Array(container.levels.length);\n\n\tlet levelAlign = 0;\n\tif (container.supercompressionScheme === KHR_SUPERCOMPRESSION_NONE) {\n\t\tlevelAlign = leastCommonMultiple(getBlockByteLength(container), 4);\n\t}\n\n\t// Level data is ordered small  large.\n\tlet levelDataByteOffset = (sgdByteOffset || kvdByteOffset + kvdBuffer.byteLength) + sgdBuffer.byteLength;\n\tfor (let i = container.levels.length - 1; i >= 0; i--) {\n\t\t// Level padding.\n\t\tif (levelDataByteOffset % levelAlign) {\n\t\t\tconst paddingBytes = getPadding(levelDataByteOffset, levelAlign);\n\t\t\tlevelData.push(new Uint8Array(paddingBytes));\n\t\t\tlevelDataByteOffset += paddingBytes;\n\t\t}\n\n\t\t// Level data.\n\t\tconst level = container.levels[i];\n\t\tlevelData.push(level.levelData);\n\t\tlevelDataByteOffsets[i] = levelDataByteOffset;\n\t\tlevelDataByteOffset += level.levelData.byteLength;\n\t}\n\n\t// Level index is ordered large  small.\n\tfor (let i = 0; i < container.levels.length; i++) {\n\t\tconst level = container.levels[i];\n\t\tlevelIndex.setBigUint64(i * 24 + 0, BigInt(levelDataByteOffsets[i]), true);\n\t\tlevelIndex.setBigUint64(i * 24 + 8, BigInt(level.levelData.byteLength), true);\n\t\tlevelIndex.setBigUint64(i * 24 + 16, BigInt(level.uncompressedByteLength), true);\n\t}\n\n\t///////////////////////////////////////////////////\n\t// Header.\n\t///////////////////////////////////////////////////\n\n\tconst headerBuffer = new ArrayBuffer(HEADER_BYTE_LENGTH);\n\tconst headerView = new DataView(headerBuffer);\n\theaderView.setUint32(0, container.vkFormat, true);\n\theaderView.setUint32(4, container.typeSize, true);\n\theaderView.setUint32(8, container.pixelWidth, true);\n\theaderView.setUint32(12, container.pixelHeight, true);\n\theaderView.setUint32(16, container.pixelDepth, true);\n\theaderView.setUint32(20, container.layerCount, true);\n\theaderView.setUint32(24, container.faceCount, true);\n\theaderView.setUint32(28, container.levels.length, true);\n\theaderView.setUint32(32, container.supercompressionScheme, true);\n\n\theaderView.setUint32(36, dfdByteOffset, true);\n\theaderView.setUint32(40, dfdBuffer.byteLength, true);\n\theaderView.setUint32(44, kvdByteOffset, true);\n\theaderView.setUint32(48, kvdBuffer.byteLength, true);\n\theaderView.setBigUint64(52, BigInt(sgdBuffer.byteLength > 0 ? sgdByteOffset : 0), true);\n\theaderView.setBigUint64(60, BigInt(sgdBuffer.byteLength), true);\n\n\t///////////////////////////////////////////////////\n\t// Compose.\n\t///////////////////////////////////////////////////\n\n\treturn new Uint8Array(\n\t\tconcat([\n\t\t\tnew Uint8Array(KTX2_ID).buffer,\n\t\t\theaderBuffer,\n\t\t\tlevelIndex.buffer,\n\t\t\tdfdBuffer,\n\t\t\tkvdBuffer,\n\t\t\tsgdByteOffset > 0\n\t\t\t\t? new ArrayBuffer(sgdByteOffset - (kvdByteOffset + kvdBuffer.byteLength)) // align(8)\n\t\t\t\t: new ArrayBuffer(0),\n\t\t\tsgdBuffer,\n\t\t\t...levelData,\n\t\t]),\n\t);\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/**\n * Extract mipmap images from compressed texture buffer\n * @param data - binary data of compressed texture or Array of level objects\n * @param options.mipMapLevels - number of mipmap level inside image\n * @param options.width - width of 0 - level\n * @param options.height - height of 0 - level\n * @param options.sizeFunction - format-related function to calculate level size in bytes\n * @param options.internalFormat - WebGL compatible format code\n * @returns Array of the texture levels\n */\nexport function extractMipmapImages(data, options) {\n    const images = new Array(options.mipMapLevels);\n    let levelWidth = options.width;\n    let levelHeight = options.height;\n    let offset = 0;\n    for (let i = 0; i < options.mipMapLevels; ++i) {\n        // @ts-expect-error\n        const levelSize = getLevelSize(options, levelWidth, levelHeight, data, i);\n        // @ts-expect-error\n        const levelData = getLevelData(data, i, offset, levelSize);\n        images[i] = {\n            compressed: true,\n            format: options.internalFormat,\n            data: levelData,\n            width: levelWidth,\n            height: levelHeight,\n            levelSize\n        };\n        levelWidth = Math.max(1, levelWidth >> 1);\n        levelHeight = Math.max(1, levelHeight >> 1);\n        offset += levelSize;\n    }\n    return images;\n}\nfunction getLevelData(data, index, offset, levelSize) {\n    if (!Array.isArray(data)) {\n        return new Uint8Array(data.buffer, data.byteOffset + offset, levelSize);\n    }\n    return data[index].levelData;\n}\nfunction getLevelSize(options, levelWidth, levelHeight, data, index) {\n    if (!Array.isArray(data)) {\n        return options.sizeFunction(levelWidth, levelHeight);\n    }\n    return options.sizeFunction(data[index]);\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { GL_EXTENSIONS_CONSTANTS } from \"../gl-extensions.js\";\nconst VULKAN_TO_WEBGL_FORMAT_MAP = {\n    131: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT,\n    132: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_S3TC_DXT1_EXT,\n    133: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n    134: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,\n    135: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n    136: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,\n    137: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n    138: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,\n    139: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RED_RGTC1_EXT,\n    140: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_RED_RGTC1_EXT,\n    141: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RED_GREEN_RGTC2_EXT,\n    142: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT,\n    147: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_ETC2,\n    148: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ETC2,\n    149: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n    150: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n    151: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA8_ETC2_EAC,\n    152: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,\n    153: GL_EXTENSIONS_CONSTANTS.COMPRESSED_R11_EAC,\n    154: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_R11_EAC,\n    155: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RG11_EAC,\n    156: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_RG11_EAC,\n    // @ts-ignore\n    157: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4x4_KHR,\n    // @ts-ignore\n    158: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,\n    // @ts-ignore\n    159: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x4_KHR,\n    // @ts-ignore\n    160: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR,\n    // @ts-ignore\n    161: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x5_KHR,\n    // @ts-ignore\n    162: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,\n    // @ts-ignore\n    163: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x5_KHR,\n    // @ts-ignore\n    164: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,\n    // @ts-ignore\n    165: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x6_KHR,\n    // @ts-ignore\n    166: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,\n    // @ts-ignore\n    167: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x5_KHR,\n    // @ts-ignore\n    168: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,\n    // @ts-ignore\n    169: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x6_KHR,\n    // @ts-ignore\n    170: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,\n    // @ts-ignore\n    171: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x8_KHR,\n    // @ts-ignore\n    172: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,\n    // @ts-ignore\n    173: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x5_KHR,\n    // @ts-ignore\n    174: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,\n    // @ts-ignore\n    175: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x6_KHR,\n    // @ts-ignore\n    176: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,\n    // @ts-ignore\n    177: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x8_KHR,\n    // @ts-ignore\n    178: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,\n    // @ts-ignore\n    179: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x10_KHR,\n    // @ts-ignore\n    180: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,\n    // @ts-ignore\n    181: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x10_KHR,\n    // @ts-ignore\n    182: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,\n    // @ts-ignore\n    183: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x12_KHR,\n    // @ts-ignore\n    184: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR,\n    1000054000: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG,\n    1000054001: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,\n    // @ts-ignore\n    1000066000: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4x4_KHR,\n    // @ts-ignore\n    1000066001: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x4_KHR,\n    // @ts-ignore\n    1000066002: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x5_KHR,\n    // @ts-ignore\n    1000066003: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x5_KHR,\n    // @ts-ignore\n    1000066004: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x6_KHR,\n    // @ts-ignore\n    1000066005: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x5_KHR,\n    // @ts-ignore\n    1000066006: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x6_KHR,\n    // @ts-ignore\n    1000066007: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x8_KHR,\n    // @ts-ignore\n    1000066008: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x5_KHR,\n    // @ts-ignore\n    1000066009: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x6_KHR,\n    // @ts-ignore\n    1000066010: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x8_KHR,\n    // @ts-ignore\n    1000066011: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x10_KHR,\n    // @ts-ignore\n    1000066012: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x10_KHR,\n    // @ts-ignore\n    1000066013: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x12_KHR\n};\n/**\n * Returns WebGl format based on Vulkan format\n * Vulkan to WebGl format mapping provided here http://github.khronos.org/KTX-Specification/#formatMapping\n * Vulkan name to format number mapping provided here: https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFormat.html\n * @param vkFormat\n * @returns WebGL / OpenGL constant\n */\nexport function mapVkFormatToWebGL(vkFormat) {\n    return VULKAN_TO_WEBGL_FORMAT_MAP[vkFormat];\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { read } from 'ktx-parse';\nimport { extractMipmapImages } from \"../utils/extract-mipmap-images.js\";\nimport { mapVkFormatToWebGL } from \"../utils/ktx-format-helper.js\";\nconst KTX2_ID = [\n    // '', 'K', 'T', 'X', '2', '0', '', '\\r', '\\n', '\\x1A', '\\n'\n    0xab, 0x4b, 0x54, 0x58, 0x20, 0x32, 0x30, 0xbb, 0x0d, 0x0a, 0x1a, 0x0a\n];\n// eslint-disable-next-line complexity\nexport function isKTX(data) {\n    // const id = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n    const id = new Uint8Array(data);\n    const notKTX = id.byteLength < KTX2_ID.length ||\n        id[0] !== KTX2_ID[0] || // ''\n        id[1] !== KTX2_ID[1] || // 'K'\n        id[2] !== KTX2_ID[2] || // 'T'\n        id[3] !== KTX2_ID[3] || // 'X'\n        id[4] !== KTX2_ID[4] || // ' '\n        id[5] !== KTX2_ID[5] || // '2'\n        id[6] !== KTX2_ID[6] || // '0'\n        id[7] !== KTX2_ID[7] || // ''\n        id[8] !== KTX2_ID[8] || // '\\r'\n        id[9] !== KTX2_ID[9] || // '\\n'\n        id[10] !== KTX2_ID[10] || // '\\x1A'\n        id[11] !== KTX2_ID[11]; // '\\n'\n    return !notKTX;\n}\nexport function parseKTX(arrayBuffer) {\n    const uint8Array = new Uint8Array(arrayBuffer);\n    const ktx = read(uint8Array);\n    const mipMapLevels = Math.max(1, ktx.levels.length);\n    const width = ktx.pixelWidth;\n    const height = ktx.pixelHeight;\n    const internalFormat = mapVkFormatToWebGL(ktx.vkFormat);\n    return extractMipmapImages(ktx.levels, {\n        mipMapLevels,\n        width,\n        height,\n        sizeFunction: (level) => level.uncompressedByteLength,\n        internalFormat\n    });\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { loadBasisEncoderModule, loadBasisTranscoderModule } from \"./basis-module-loader.js\";\nimport { GL_EXTENSIONS_CONSTANTS } from \"../gl-extensions.js\";\nimport { getSupportedGPUTextureFormats } from \"../utils/texture-formats.js\";\nimport { isKTX } from \"./parse-ktx.js\";\nconst OutputFormat = {\n    etc1: {\n        basisFormat: 0,\n        compressed: true,\n        format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL\n    },\n    etc2: { basisFormat: 1, compressed: true },\n    bc1: {\n        basisFormat: 2,\n        compressed: true,\n        format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT\n    },\n    bc3: {\n        basisFormat: 3,\n        compressed: true,\n        format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT\n    },\n    bc4: { basisFormat: 4, compressed: true },\n    bc5: { basisFormat: 5, compressed: true },\n    'bc7-m6-opaque-only': { basisFormat: 6, compressed: true },\n    'bc7-m5': { basisFormat: 7, compressed: true },\n    'pvrtc1-4-rgb': {\n        basisFormat: 8,\n        compressed: true,\n        format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG\n    },\n    'pvrtc1-4-rgba': {\n        basisFormat: 9,\n        compressed: true,\n        format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\n    },\n    'astc-4x4': {\n        basisFormat: 10,\n        compressed: true,\n        format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR\n    },\n    'atc-rgb': { basisFormat: 11, compressed: true },\n    'atc-rgba-interpolated-alpha': { basisFormat: 12, compressed: true },\n    rgba32: { basisFormat: 13, compressed: false },\n    rgb565: { basisFormat: 14, compressed: false },\n    bgr565: { basisFormat: 15, compressed: false },\n    rgba4444: { basisFormat: 16, compressed: false }\n};\n/**\n * parse data with a Binomial Basis_Universal module\n * @param data\n * @param options\n * @returns compressed texture data\n */\nexport async function parseBasis(data, options) {\n    if (options.basis.containerFormat === 'auto') {\n        if (isKTX(data)) {\n            const fileConstructors = await loadBasisEncoderModule(options);\n            return parseKTX2File(fileConstructors.KTX2File, data, options);\n        }\n        const { BasisFile } = await loadBasisTranscoderModule(options);\n        return parseBasisFile(BasisFile, data, options);\n    }\n    switch (options.basis.module) {\n        case 'encoder':\n            const fileConstructors = await loadBasisEncoderModule(options);\n            switch (options.basis.containerFormat) {\n                case 'ktx2':\n                    return parseKTX2File(fileConstructors.KTX2File, data, options);\n                case 'basis':\n                default:\n                    return parseBasisFile(fileConstructors.BasisFile, data, options);\n            }\n        case 'transcoder':\n        default:\n            const { BasisFile } = await loadBasisTranscoderModule(options);\n            return parseBasisFile(BasisFile, data, options);\n    }\n}\n/**\n * Parse *.basis file data\n * @param BasisFile - initialized transcoder module\n * @param data\n * @param options\n * @returns compressed texture data\n */\nfunction parseBasisFile(BasisFile, data, options) {\n    const basisFile = new BasisFile(new Uint8Array(data));\n    try {\n        if (!basisFile.startTranscoding()) {\n            throw new Error('Failed to start basis transcoding');\n        }\n        const imageCount = basisFile.getNumImages();\n        const images = [];\n        for (let imageIndex = 0; imageIndex < imageCount; imageIndex++) {\n            const levelsCount = basisFile.getNumLevels(imageIndex);\n            const levels = [];\n            for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {\n                levels.push(transcodeImage(basisFile, imageIndex, levelIndex, options));\n            }\n            images.push(levels);\n        }\n        return images;\n    }\n    finally {\n        basisFile.close();\n        basisFile.delete();\n    }\n}\n/**\n * Parse the particular level image of a basis file\n * @param basisFile\n * @param imageIndex\n * @param levelIndex\n * @param options\n * @returns compressed texture data\n */\nfunction transcodeImage(basisFile, imageIndex, levelIndex, options) {\n    const width = basisFile.getImageWidth(imageIndex, levelIndex);\n    const height = basisFile.getImageHeight(imageIndex, levelIndex);\n    // See https://github.com/BinomialLLC/basis_universal/pull/83\n    const hasAlpha = basisFile.getHasAlpha( /* imageIndex, levelIndex */);\n    // Check options for output format etc\n    const { compressed, format, basisFormat } = getBasisOptions(options, hasAlpha);\n    const decodedSize = basisFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, basisFormat);\n    const decodedData = new Uint8Array(decodedSize);\n    if (!basisFile.transcodeImage(decodedData, imageIndex, levelIndex, basisFormat, 0, 0)) {\n        throw new Error('failed to start Basis transcoding');\n    }\n    return {\n        // standard loaders.gl image category payload\n        width,\n        height,\n        data: decodedData,\n        compressed,\n        format,\n        // Additional fields\n        // Add levelSize field.\n        hasAlpha\n    };\n}\n/**\n * Parse *.ktx2 file data\n * @param KTX2File\n * @param data\n * @param options\n * @returns compressed texture data\n */\nfunction parseKTX2File(KTX2File, data, options) {\n    const ktx2File = new KTX2File(new Uint8Array(data));\n    try {\n        if (!ktx2File.startTranscoding()) {\n            throw new Error('failed to start KTX2 transcoding');\n        }\n        const levelsCount = ktx2File.getLevels();\n        const levels = [];\n        for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {\n            levels.push(transcodeKTX2Image(ktx2File, levelIndex, options));\n        }\n        return [levels];\n    }\n    finally {\n        ktx2File.close();\n        ktx2File.delete();\n    }\n}\n/**\n * Parse the particular level image of a ktx2 file\n * @param ktx2File\n * @param levelIndex\n * @param options\n * @returns\n */\nfunction transcodeKTX2Image(ktx2File, levelIndex, options) {\n    const { alphaFlag, height, width } = ktx2File.getImageLevelInfo(levelIndex, 0, 0);\n    // Check options for output format etc\n    const { compressed, format, basisFormat } = getBasisOptions(options, alphaFlag);\n    const decodedSize = ktx2File.getImageTranscodedSizeInBytes(levelIndex, 0 /* layerIndex */, 0 /* faceIndex */, basisFormat);\n    const decodedData = new Uint8Array(decodedSize);\n    if (!ktx2File.transcodeImage(decodedData, levelIndex, 0 /* layerIndex */, 0 /* faceIndex */, basisFormat, 0, -1 /* channel0 */, -1 /* channel1 */)) {\n        throw new Error('Failed to transcode KTX2 image');\n    }\n    return {\n        // standard loaders.gl image category payload\n        width,\n        height,\n        data: decodedData,\n        compressed,\n        // Additional fields\n        levelSize: decodedSize,\n        hasAlpha: alphaFlag,\n        format\n    };\n}\n/**\n * Get BasisFormat by loader format option\n * @param options\n * @param hasAlpha\n * @returns BasisFormat data\n */\nfunction getBasisOptions(options, hasAlpha) {\n    let format = options && options.basis && options.basis.format;\n    if (format === 'auto') {\n        format = selectSupportedBasisFormat();\n    }\n    if (typeof format === 'object') {\n        format = hasAlpha ? format.alpha : format.noAlpha;\n    }\n    format = format.toLowerCase();\n    return OutputFormat[format];\n}\n/**\n * Select transcode format from the list of supported formats\n * @returns key for OutputFormat map\n */\nexport function selectSupportedBasisFormat() {\n    const supportedFormats = getSupportedGPUTextureFormats();\n    if (supportedFormats.has('astc')) {\n        return 'astc-4x4';\n    }\n    else if (supportedFormats.has('dxt')) {\n        return {\n            alpha: 'bc3',\n            noAlpha: 'bc1'\n        };\n    }\n    else if (supportedFormats.has('pvrtc')) {\n        return {\n            alpha: 'pvrtc1-4-rgba',\n            noAlpha: 'pvrtc1-4-rgb'\n        };\n    }\n    else if (supportedFormats.has('etc1')) {\n        return 'etc1';\n    }\n    else if (supportedFormats.has('etc2')) {\n        return 'etc2';\n    }\n    return 'rgb565';\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { VERSION } from \"./lib/utils/version.js\";\nimport { parseBasis } from \"./lib/parsers/parse-basis.js\";\n/**\n * Worker loader for Basis super compressed textures\n */\nexport const BasisWorkerLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'Basis',\n    id: 'basis',\n    module: 'textures',\n    version: VERSION,\n    worker: true,\n    extensions: ['basis', 'ktx2'],\n    mimeTypes: ['application/octet-stream', 'image/ktx2'],\n    tests: ['sB'],\n    binary: true,\n    options: {\n        basis: {\n            format: 'auto',\n            libraryPath: 'libs/',\n            containerFormat: 'auto',\n            module: 'transcoder'\n        }\n    }\n};\n/**\n * Loader for Basis super compressed textures\n */\nexport const BasisLoader = {\n    ...BasisWorkerLoader,\n    parse: parseBasis\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { assert } from '@loaders.gl/loader-utils';\nimport { GL_EXTENSIONS_CONSTANTS } from \"../gl-extensions.js\";\nimport { extractMipmapImages } from \"../utils/extract-mipmap-images.js\";\nconst DDS_CONSTANTS = {\n    MAGIC_NUMBER: 0x20534444,\n    HEADER_LENGTH: 31,\n    MAGIC_NUMBER_INDEX: 0,\n    HEADER_SIZE_INDEX: 1,\n    HEADER_FLAGS_INDEX: 2,\n    HEADER_HEIGHT_INDEX: 3,\n    HEADER_WIDTH_INDEX: 4,\n    MIPMAPCOUNT_INDEX: 7,\n    HEADER_PF_FLAGS_INDEX: 20,\n    HEADER_PF_FOURCC_INDEX: 21,\n    DDSD_MIPMAPCOUNT: 0x20000,\n    DDPF_FOURCC: 0x4\n};\nconst DDS_PIXEL_FORMATS = {\n    DXT1: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT,\n    DXT3: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n    DXT5: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n    'ATC ': GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ATC_WEBGL,\n    ATCA: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,\n    ATCI: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL\n};\nconst getATCLevelSize = getDxt1LevelSize;\nconst getATCALevelSize = getDxtXLevelSize;\nconst getATCILevelSize = getDxtXLevelSize;\nconst DDS_SIZE_FUNCTIONS = {\n    DXT1: getDxt1LevelSize,\n    DXT3: getDxtXLevelSize,\n    DXT5: getDxtXLevelSize,\n    'ATC ': getATCLevelSize,\n    ATCA: getATCALevelSize,\n    ATCI: getATCILevelSize\n};\n/**\n * Check if data is in \"DDS\" format by its magic number\n * @param data - binary data of compressed texture\n * @returns true - data in \"DDS\" format, else - false\n */\nexport function isDDS(data) {\n    const header = new Uint32Array(data, 0, DDS_CONSTANTS.HEADER_LENGTH);\n    const magic = header[DDS_CONSTANTS.MAGIC_NUMBER_INDEX];\n    return magic === DDS_CONSTANTS.MAGIC_NUMBER;\n}\n/**\n * Parse texture data as \"DDS\" format\n * @param data - binary data of compressed texture\n * @returns Array of the texture levels\n */\nexport function parseDDS(data) {\n    const header = new Int32Array(data, 0, DDS_CONSTANTS.HEADER_LENGTH);\n    const pixelFormatNumber = header[DDS_CONSTANTS.HEADER_PF_FOURCC_INDEX];\n    assert(Boolean(header[DDS_CONSTANTS.HEADER_PF_FLAGS_INDEX] & DDS_CONSTANTS.DDPF_FOURCC), 'DDS: Unsupported format, must contain a FourCC code');\n    const fourCC = int32ToFourCC(pixelFormatNumber);\n    const internalFormat = DDS_PIXEL_FORMATS[fourCC];\n    const sizeFunction = DDS_SIZE_FUNCTIONS[fourCC];\n    assert(internalFormat && sizeFunction, `DDS: Unknown pixel format ${pixelFormatNumber}`);\n    let mipMapLevels = 1;\n    if (header[DDS_CONSTANTS.HEADER_FLAGS_INDEX] & DDS_CONSTANTS.DDSD_MIPMAPCOUNT) {\n        mipMapLevels = Math.max(1, header[DDS_CONSTANTS.MIPMAPCOUNT_INDEX]);\n    }\n    const width = header[DDS_CONSTANTS.HEADER_WIDTH_INDEX];\n    const height = header[DDS_CONSTANTS.HEADER_HEIGHT_INDEX];\n    const dataOffset = header[DDS_CONSTANTS.HEADER_SIZE_INDEX] + 4;\n    const image = new Uint8Array(data, dataOffset);\n    return extractMipmapImages(image, {\n        mipMapLevels,\n        width,\n        height,\n        sizeFunction,\n        internalFormat\n    });\n}\n/**\n * DXT1 applicable function to calculate level size\n * @param width - level width\n * @param height - level height\n * @returns level size in bytes\n */\nexport function getDxt1LevelSize(width, height) {\n    return ((width + 3) >> 2) * ((height + 3) >> 2) * 8;\n}\n/**\n * DXT3 & DXT5 applicable function to calculate level size\n * @param width - level width\n * @param height - level height\n * @returns level size in bytes\n */\nexport function getDxtXLevelSize(width, height) {\n    return ((width + 3) >> 2) * ((height + 3) >> 2) * 16;\n}\n/**\n * Convert every byte of Int32 value to char\n * @param value - Int32 number\n * @returns string of 4 characters\n */\nfunction int32ToFourCC(value) {\n    return String.fromCharCode(value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff);\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { GL_EXTENSIONS_CONSTANTS } from \"../gl-extensions.js\";\nimport { extractMipmapImages } from \"../utils/extract-mipmap-images.js\";\nconst PVR_CONSTANTS = {\n    MAGIC_NUMBER: 0x03525650,\n    MAGIC_NUMBER_EXTRA: 0x50565203,\n    HEADER_LENGTH: 13,\n    HEADER_SIZE: 52,\n    MAGIC_NUMBER_INDEX: 0,\n    PIXEL_FORMAT_INDEX: 2,\n    COLOUR_SPACE_INDEX: 4,\n    HEIGHT_INDEX: 6,\n    WIDTH_INDEX: 7,\n    MIPMAPCOUNT_INDEX: 11,\n    METADATA_SIZE_INDEX: 12\n};\nconst PVR_PIXEL_FORMATS = {\n    0: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG],\n    1: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG],\n    2: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG],\n    3: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG],\n    6: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL],\n    7: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT],\n    9: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT],\n    11: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT],\n    22: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_ETC2],\n    23: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA8_ETC2_EAC],\n    24: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2],\n    25: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_R11_EAC],\n    26: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RG11_EAC],\n    27: [\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR,\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR\n    ],\n    28: [\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5X4_KHR,\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR\n    ],\n    29: [\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5X5_KHR,\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR\n    ],\n    30: [\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6X5_KHR,\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR\n    ],\n    31: [\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6X6_KHR,\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR\n    ],\n    32: [\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8X5_KHR,\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR\n    ],\n    33: [\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8X6_KHR,\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR\n    ],\n    34: [\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8X8_KHR,\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR\n    ],\n    35: [\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X5_KHR,\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR\n    ],\n    36: [\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X6_KHR,\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR\n    ],\n    37: [\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X8_KHR,\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR\n    ],\n    38: [\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X10_KHR,\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR\n    ],\n    39: [\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12X10_KHR,\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR\n    ],\n    40: [\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12X12_KHR,\n        GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR\n    ]\n};\nconst PVR_SIZE_FUNCTIONS = {\n    0: pvrtc2bppSize,\n    1: pvrtc2bppSize,\n    2: pvrtc4bppSize,\n    3: pvrtc4bppSize,\n    6: dxtEtcSmallSize,\n    7: dxtEtcSmallSize,\n    9: dxtEtcAstcBigSize,\n    11: dxtEtcAstcBigSize,\n    22: dxtEtcSmallSize,\n    23: dxtEtcAstcBigSize,\n    24: dxtEtcSmallSize,\n    25: dxtEtcSmallSize,\n    26: dxtEtcAstcBigSize,\n    27: dxtEtcAstcBigSize,\n    28: atc5x4Size,\n    29: atc5x5Size,\n    30: atc6x5Size,\n    31: atc6x6Size,\n    32: atc8x5Size,\n    33: atc8x6Size,\n    34: atc8x8Size,\n    35: atc10x5Size,\n    36: atc10x6Size,\n    37: atc10x8Size,\n    38: atc10x10Size,\n    39: atc12x10Size,\n    40: atc12x12Size\n};\n/**\n * Check if data is in \"PVR\" format by its magic number\n * @param data - binary data of compressed texture\n * @returns true - data in \"PVR\" format, else - false\n */\nexport function isPVR(data) {\n    const header = new Uint32Array(data, 0, PVR_CONSTANTS.HEADER_LENGTH);\n    const version = header[PVR_CONSTANTS.MAGIC_NUMBER_INDEX];\n    return version === PVR_CONSTANTS.MAGIC_NUMBER || version === PVR_CONSTANTS.MAGIC_NUMBER_EXTRA;\n}\n/**\n * Parse texture data as \"PVR\" format\n * @param data - binary data of compressed texture\n * @returns Array of the texture levels\n * @see http://cdn.imgtec.com/sdk-documentation/PVR+File+Format.Specification.pdf\n */\nexport function parsePVR(data) {\n    const header = new Uint32Array(data, 0, PVR_CONSTANTS.HEADER_LENGTH);\n    const pvrFormat = header[PVR_CONSTANTS.PIXEL_FORMAT_INDEX];\n    const colourSpace = header[PVR_CONSTANTS.COLOUR_SPACE_INDEX];\n    const pixelFormats = PVR_PIXEL_FORMATS[pvrFormat] || [];\n    const internalFormat = pixelFormats.length > 1 && colourSpace ? pixelFormats[1] : pixelFormats[0];\n    const sizeFunction = PVR_SIZE_FUNCTIONS[pvrFormat];\n    const mipMapLevels = header[PVR_CONSTANTS.MIPMAPCOUNT_INDEX];\n    const width = header[PVR_CONSTANTS.WIDTH_INDEX];\n    const height = header[PVR_CONSTANTS.HEIGHT_INDEX];\n    const dataOffset = PVR_CONSTANTS.HEADER_SIZE + header[PVR_CONSTANTS.METADATA_SIZE_INDEX];\n    const image = new Uint8Array(data, dataOffset);\n    return extractMipmapImages(image, {\n        mipMapLevels,\n        width,\n        height,\n        sizeFunction,\n        internalFormat\n    });\n}\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/\nfunction pvrtc2bppSize(width, height) {\n    width = Math.max(width, 16);\n    height = Math.max(height, 8);\n    return (width * height) / 4;\n}\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/\nfunction pvrtc4bppSize(width, height) {\n    width = Math.max(width, 8);\n    height = Math.max(height, 8);\n    return (width * height) / 2;\n}\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc/\n// Size for:\n// COMPRESSED_RGB_S3TC_DXT1_EXT\n// COMPRESSED_R11_EAC\n// COMPRESSED_SIGNED_R11_EAC\n// COMPRESSED_RGB8_ETC2\n// COMPRESSED_SRGB8_ETC2\n// COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2\n// COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2\nfunction dxtEtcSmallSize(width, height) {\n    return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;\n}\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc/\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\n// Size for:\n// COMPRESSED_RGBA_S3TC_DXT3_EXT\n// COMPRESSED_RGBA_S3TC_DXT5_EXT\n// COMPRESSED_RG11_EAC\n// COMPRESSED_SIGNED_RG11_EAC\n// COMPRESSED_RGBA8_ETC2_EAC\n// COMPRESSED_SRGB8_ALPHA8_ETC2_EAC\n// COMPRESSED_RGBA_ASTC_4x4_KHR\nfunction dxtEtcAstcBigSize(width, height) {\n    return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;\n}\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc5x4Size(width, height) {\n    return Math.floor((width + 4) / 5) * Math.floor((height + 3) / 4) * 16;\n}\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc5x5Size(width, height) {\n    return Math.floor((width + 4) / 5) * Math.floor((height + 4) / 5) * 16;\n}\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc6x5Size(width, height) {\n    return Math.floor((width + 5) / 6) * Math.floor((height + 4) / 5) * 16;\n}\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc6x6Size(width, height) {\n    return Math.floor((width + 5) / 6) * Math.floor((height + 5) / 6) * 16;\n}\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc8x5Size(width, height) {\n    return Math.floor((width + 7) / 8) * Math.floor((height + 4) / 5) * 16;\n}\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc8x6Size(width, height) {\n    return Math.floor((width + 7) / 8) * Math.floor((height + 5) / 6) * 16;\n}\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc8x8Size(width, height) {\n    return Math.floor((width + 7) / 8) * Math.floor((height + 7) / 8) * 16;\n}\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc10x5Size(width, height) {\n    return Math.floor((width + 9) / 10) * Math.floor((height + 4) / 5) * 16;\n}\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc10x6Size(width, height) {\n    return Math.floor((width + 9) / 10) * Math.floor((height + 5) / 6) * 16;\n}\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc10x8Size(width, height) {\n    return Math.floor((width + 9) / 10) * Math.floor((height + 7) / 8) * 16;\n}\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc10x10Size(width, height) {\n    return Math.floor((width + 9) / 10) * Math.floor((height + 9) / 10) * 16;\n}\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc12x10Size(width, height) {\n    return Math.floor((width + 11) / 12) * Math.floor((height + 9) / 10) * 16;\n}\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc12x12Size(width, height) {\n    return Math.floor((width + 11) / 12) * Math.floor((height + 11) / 12) * 16;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { isKTX, parseKTX } from \"./parse-ktx.js\";\nimport { isDDS, parseDDS } from \"./parse-dds.js\";\nimport { isPVR, parsePVR } from \"./parse-pvr.js\";\n/**\n * Deduces format and parses compressed texture loaded in ArrayBuffer\n * @param data - binary data of compressed texture\n * @returns Array of the texture levels\n */\nexport function parseCompressedTexture(data) {\n    if (isKTX(data)) {\n        // TODO: remove @ts-ignore when `parseKTX` output is normalized to loaders.gl texture format\n        // @ts-ignore\n        return parseKTX(data);\n    }\n    if (isDDS(data)) {\n        return parseDDS(data);\n    }\n    if (isPVR(data)) {\n        return parsePVR(data);\n    }\n    throw new Error('Texture container format not recognized');\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { VERSION } from \"./lib/utils/version.js\";\nimport { parseCompressedTexture } from \"./lib/parsers/parse-compressed-texture.js\";\nimport { parseBasis } from \"./lib/parsers/parse-basis.js\";\n/**\n * Worker Loader for KTX, DDS, and PVR texture container formats\n */\nexport const CompressedTextureWorkerLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'Texture Containers',\n    id: 'compressed-texture',\n    module: 'textures',\n    version: VERSION,\n    worker: true,\n    extensions: [\n        'ktx',\n        'ktx2',\n        'dds', // WEBGL_compressed_texture_s3tc, WEBGL_compressed_texture_atc\n        'pvr' // WEBGL_compressed_texture_pvrtc\n    ],\n    mimeTypes: [\n        'image/ktx2',\n        'image/ktx',\n        'image/vnd-ms.dds',\n        'image/x-dds',\n        'application/octet-stream'\n    ],\n    binary: true,\n    options: {\n        'compressed-texture': {\n            libraryPath: 'libs/',\n            useBasis: false\n        }\n    }\n};\n/**\n * Loader for KTX, DDS, and PVR texture container formats\n */\nexport const CompressedTextureLoader = {\n    ...CompressedTextureWorkerLoader,\n    parse: async (arrayBuffer, options) => {\n        if (options?.['compressed-texture']?.useBasis) {\n            // @ts-expect-error TODO not allowed to modify inputs\n            options.basis = {\n                format: {\n                    alpha: 'BC3',\n                    noAlpha: 'BC1'\n                },\n                // @ts-expect-error TODO not allowed to modify inputs\n                ...options.basis,\n                containerFormat: 'ktx2',\n                module: 'encoder'\n            };\n            const result = await parseBasis(arrayBuffer, options);\n            return result[0];\n        }\n        return parseCompressedTexture(arrayBuffer);\n    }\n};\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst a = new Uint32Array([0x12345678]);\nconst b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\nconst isLittleEndian = !(b[0] === 0x12);\nconst LITTLE_ENDIAN_OS = isLittleEndian;\n/**\n * The basic string format consists of 3 characters:\n * 1. a character describing the byteorder of the data (<: little-endian, >: big-endian, |: not-relevant)\n * 2. a character code giving the basic type of the array\n * 3. an integer providing the number of bytes the type uses.\n * https://numpy.org/doc/stable/reference/arrays.interface.html\n *\n * Here I only include the second and third characters, and check endianness separately\n */\nconst DTYPES = {\n    u1: Uint8Array,\n    i1: Int8Array,\n    u2: Uint16Array,\n    i2: Int16Array,\n    u4: Uint32Array,\n    i4: Int32Array,\n    f4: Float32Array,\n    f8: Float64Array\n};\nexport function parseNPY(arrayBuffer, options) {\n    const view = new DataView(arrayBuffer);\n    const { header, headerEndOffset } = parseHeader(view);\n    const numpyType = header.descr;\n    const ArrayType = DTYPES[numpyType.slice(1, 3)];\n    if (!ArrayType) {\n        throw new Error(`Unimplemented type ${numpyType}`);\n    }\n    const nArrayElements = header.shape?.reduce((a, b) => a * b);\n    const arrayByteLength = nArrayElements * ArrayType.BYTES_PER_ELEMENT;\n    if (arrayBuffer.byteLength < headerEndOffset + arrayByteLength) {\n        throw new Error('Buffer overflow');\n    }\n    const data = new ArrayType(arrayBuffer.slice(headerEndOffset, headerEndOffset + arrayByteLength));\n    // Swap endianness if needed\n    if ((numpyType[0] === '>' && LITTLE_ENDIAN_OS) || (numpyType[0] === '<' && !LITTLE_ENDIAN_OS)) {\n        throw new Error('Incorrect endianness');\n    }\n    return {\n        data,\n        header\n    };\n}\n/**\n * Parse NPY header\n *\n * @param  view\n * @return\n */\nfunction parseHeader(view) {\n    const majorVersion = view.getUint8(6);\n    // const minorVersion = view.getUint8(7);\n    let offset = 8;\n    let headerLength;\n    if (majorVersion >= 2) {\n        headerLength = view.getUint32(offset, true);\n        offset += 4;\n    }\n    else {\n        headerLength = view.getUint16(offset, true);\n        offset += 2;\n    }\n    const encoding = majorVersion <= 2 ? 'latin1' : 'utf-8';\n    const decoder = new TextDecoder(encoding);\n    const headerArray = new Uint8Array(view.buffer, offset, headerLength);\n    const headerText = decoder.decode(headerArray);\n    offset += headerLength;\n    const header = JSON.parse(headerText\n        .replace(/'/g, '\"')\n        .replace('False', 'false')\n        .replace('(', '[')\n        .replace(/,*\\),*/g, ']'));\n    return { header, headerEndOffset: offset };\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { VERSION } from \"./lib/utils/version.js\";\nimport { parseNPY } from \"./lib/parsers/parse-npy.js\";\n// \\x93NUMPY\nconst NPY_MAGIC_NUMBER = new Uint8Array([147, 78, 85, 77, 80, 89]);\n/**\n * Worker loader for numpy \"tiles\"\n */\nexport const NPYWorkerLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'NPY',\n    id: 'npy',\n    module: 'textures',\n    version: VERSION,\n    worker: true,\n    extensions: ['npy'],\n    mimeTypes: [],\n    tests: [NPY_MAGIC_NUMBER.buffer],\n    options: {\n        npy: {}\n    }\n};\n/**\n * Loader for numpy \"tiles\"\n */\nexport const NPYLoader = {\n    ...NPYWorkerLoader,\n    parseSync: parseNPY,\n    parse: async (arrayBuffer, options) => parseNPY(arrayBuffer, options)\n};\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// TODO: convert in loaders.gl?\n\nimport type {SamplerProps} from '@luma.gl/core';\nimport {GL} from '@luma.gl/constants';\n\ntype GLTFSampler = {\n  wrapS?: GL.CLAMP_TO_EDGE | GL.REPEAT | GL.MIRRORED_REPEAT;\n  wrapT?: GL.CLAMP_TO_EDGE | GL.REPEAT | GL.MIRRORED_REPEAT;\n  magFilter?: GL.NEAREST | GL.LINEAR;\n  minFilter?:\n    | GL.NEAREST\n    | GL.LINEAR\n    | GL.NEAREST_MIPMAP_NEAREST\n    | GL.LINEAR_MIPMAP_NEAREST\n    | GL.NEAREST_MIPMAP_LINEAR\n    | GL.LINEAR_MIPMAP_LINEAR;\n};\n\nexport function convertSampler(gltfSampler: GLTFSampler): SamplerProps {\n  return {\n    addressModeU: convertSamplerWrapMode(gltfSampler.wrapS),\n    addressModeV: convertSamplerWrapMode(gltfSampler.wrapT),\n    magFilter: convertSamplerMagFilter(gltfSampler.magFilter),\n    ...convertSamplerMinFilter(gltfSampler.minFilter)\n  };\n}\n\nfunction convertSamplerWrapMode(\n  mode: GL.CLAMP_TO_EDGE | GL.REPEAT | GL.MIRRORED_REPEAT | undefined\n): 'clamp-to-edge' | 'repeat' | 'mirror-repeat' | undefined {\n  switch (mode) {\n    case GL.CLAMP_TO_EDGE:\n      return 'clamp-to-edge';\n    case GL.REPEAT:\n      return 'repeat';\n    case GL.MIRRORED_REPEAT:\n      return 'mirror-repeat';\n    default:\n      return undefined;\n  }\n}\n\nfunction convertSamplerMagFilter(\n  mode: GL.NEAREST | GL.LINEAR | undefined\n): 'nearest' | 'linear' | undefined {\n  switch (mode) {\n    case GL.NEAREST:\n      return 'nearest';\n    case GL.LINEAR:\n      return 'linear';\n    default:\n      return undefined;\n  }\n}\n\nfunction convertSamplerMinFilter(\n  mode:\n    | GL.NEAREST\n    | GL.LINEAR\n    | GL.NEAREST_MIPMAP_NEAREST\n    | GL.LINEAR_MIPMAP_NEAREST\n    | GL.NEAREST_MIPMAP_LINEAR\n    | GL.LINEAR_MIPMAP_LINEAR\n    | undefined\n): {minFilter?: 'nearest' | 'linear'; mipmapFilter?: 'nearest' | 'linear'} {\n  switch (mode) {\n    case GL.NEAREST:\n      return {minFilter: 'nearest'};\n    case GL.LINEAR:\n      return {minFilter: 'linear'};\n    case GL.NEAREST_MIPMAP_NEAREST:\n      return {minFilter: 'nearest', mipmapFilter: 'nearest'};\n    case GL.LINEAR_MIPMAP_NEAREST:\n      return {minFilter: 'linear', mipmapFilter: 'nearest'};\n    case GL.NEAREST_MIPMAP_LINEAR:\n      return {minFilter: 'nearest', mipmapFilter: 'linear'};\n    case GL.LINEAR_MIPMAP_LINEAR:\n      return {minFilter: 'linear', mipmapFilter: 'linear'};\n    default:\n      return {};\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device, Texture} from '@luma.gl/core';\nimport {GL} from '@luma.gl/constants';\n\nimport {log} from '@luma.gl/core';\nimport {type ParsedPBRMaterial} from '../pbr/pbr-material';\nimport {type PBREnvironment} from '../pbr/pbr-environment';\nimport {type PBRMaterialBindings} from '@luma.gl/shadertools';\nimport {convertSampler} from '../webgl-to-webgpu/convert-webgl-sampler';\n\n// TODO - synchronize the GLTF... types with loaders.gl\n// TODO - remove the glParameters, use only parameters\n\n/* eslint-disable camelcase */\n\ntype GLTFTexture = {\n  id: string;\n  texture: {source: {image: any}; sampler: {parameters: any}};\n  uniformName?: string;\n  // is this on all textures?\n  scale?: number;\n  // is this on all textures?\n  strength?: number;\n};\n\ntype GLTFPBRMetallicRoughness = {\n  baseColorTexture?: GLTFTexture;\n  baseColorFactor?: [number, number, number, number];\n  metallicRoughnessTexture?: GLTFTexture;\n  metallicFactor?: number;\n  roughnessFactor?: number;\n};\n\ntype GLTFPBRMaterial = {\n  unlit?: boolean;\n  pbrMetallicRoughness?: GLTFPBRMetallicRoughness;\n  normalTexture?: GLTFTexture;\n  occlusionTexture?: GLTFTexture;\n  emissiveTexture?: GLTFTexture;\n  emissiveFactor?: [number, number, number];\n  alphaMode?: 'MASK' | 'BLEND';\n  alphaCutoff?: number;\n};\n\nexport type ParsePBRMaterialOptions = {\n  /** Debug PBR shader */\n  pbrDebug?: boolean;\n  /** Enable lights */\n  lights?: any;\n  /** Use tangents */\n  useTangents?: boolean;\n  /** provide an image based (texture cube) lighting environment */\n  imageBasedLightingEnvironment?: PBREnvironment;\n};\n\n/**\n * Parses a GLTF material definition into uniforms and parameters for the PBR shader module\n */\nexport function parsePBRMaterial(\n  device: Device,\n  material: GLTFPBRMaterial,\n  attributes: Record<string, any>,\n  options: ParsePBRMaterialOptions\n): ParsedPBRMaterial {\n  const parsedMaterial: ParsedPBRMaterial = {\n    defines: {\n      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)\n      MANUAL_SRGB: true,\n      SRGB_FAST_APPROXIMATION: true\n    },\n    bindings: {},\n    uniforms: {\n      // TODO: find better values?\n      camera: [0, 0, 0], // Model should override\n\n      metallicRoughnessValues: [1, 1] // Default is 1 and 1\n    },\n    parameters: {},\n    glParameters: {},\n    generatedTextures: []\n  };\n\n  // TODO - always available\n  parsedMaterial.defines['USE_TEX_LOD'] = true;\n\n  const {imageBasedLightingEnvironment} = options;\n  if (imageBasedLightingEnvironment) {\n    parsedMaterial.bindings.pbr_diffuseEnvSampler =\n      imageBasedLightingEnvironment.diffuseEnvSampler.texture;\n    parsedMaterial.bindings.pbr_specularEnvSampler =\n      imageBasedLightingEnvironment.specularEnvSampler.texture;\n    parsedMaterial.bindings.pbr_BrdfLUT = imageBasedLightingEnvironment.brdfLutTexture.texture;\n    parsedMaterial.uniforms.scaleIBLAmbient = [1, 1];\n  }\n\n  if (options?.pbrDebug) {\n    parsedMaterial.defines['PBR_DEBUG'] = true;\n    // Override final color for reference app visualization of various parameters in the lighting equation.\n    parsedMaterial.uniforms.scaleDiffBaseMR = [0, 0, 0, 0];\n    parsedMaterial.uniforms.scaleFGDSpec = [0, 0, 0, 0];\n  }\n\n  if (attributes['NORMAL']) parsedMaterial.defines['HAS_NORMALS'] = true;\n  if (attributes['TANGENT'] && options?.useTangents) parsedMaterial.defines['HAS_TANGENTS'] = true;\n  if (attributes['TEXCOORD_0']) parsedMaterial.defines['HAS_UV'] = true;\n\n  if (options?.imageBasedLightingEnvironment) parsedMaterial.defines['USE_IBL'] = true;\n  if (options?.lights) parsedMaterial.defines['USE_LIGHTS'] = true;\n\n  if (material) {\n    parseMaterial(device, material, parsedMaterial);\n  }\n\n  return parsedMaterial;\n}\n\n/** Parse GLTF material record */\nfunction parseMaterial(\n  device: Device,\n  material: GLTFPBRMaterial,\n  parsedMaterial: ParsedPBRMaterial\n): void {\n  parsedMaterial.uniforms.unlit = Boolean(material.unlit);\n\n  if (material.pbrMetallicRoughness) {\n    parsePbrMetallicRoughness(device, material.pbrMetallicRoughness, parsedMaterial);\n  }\n  if (material.normalTexture) {\n    addTexture(\n      device,\n      material.normalTexture,\n      'pbr_normalSampler',\n      'HAS_NORMALMAP',\n      parsedMaterial\n    );\n\n    const {scale = 1} = material.normalTexture;\n    parsedMaterial.uniforms.normalScale = scale;\n  }\n  if (material.occlusionTexture) {\n    addTexture(\n      device,\n      material.occlusionTexture,\n      'pbr_occlusionSampler',\n      'HAS_OCCLUSIONMAP',\n      parsedMaterial\n    );\n\n    const {strength = 1} = material.occlusionTexture;\n    parsedMaterial.uniforms.occlusionStrength = strength;\n  }\n  if (material.emissiveTexture) {\n    addTexture(\n      device,\n      material.emissiveTexture,\n      'pbr_emissiveSampler',\n      'HAS_EMISSIVEMAP',\n      parsedMaterial\n    );\n    parsedMaterial.uniforms.emissiveFactor = material.emissiveFactor || [0, 0, 0];\n  }\n\n  switch (material.alphaMode || 'MASK') {\n    case 'MASK':\n      const {alphaCutoff = 0.5} = material;\n      parsedMaterial.defines['ALPHA_CUTOFF'] = true;\n      parsedMaterial.uniforms.alphaCutoff = alphaCutoff;\n      break;\n    case 'BLEND':\n      log.warn('glTF BLEND alphaMode might not work well because it requires mesh sorting')();\n\n      // WebGPU style parameters\n      parsedMaterial.parameters.blend = true;\n\n      parsedMaterial.parameters.blendColorOperation = 'add';\n      parsedMaterial.parameters.blendColorSrcFactor = 'src-alpha';\n      parsedMaterial.parameters.blendColorDstFactor = 'one-minus-src-alpha';\n\n      parsedMaterial.parameters.blendAlphaOperation = 'add';\n      parsedMaterial.parameters.blendAlphaSrcFactor = 'one';\n      parsedMaterial.parameters.blendAlphaDstFactor = 'one-minus-src-alpha';\n\n      // GL parameters\n      // TODO - remove in favor of parameters\n      parsedMaterial.glParameters['blend'] = true;\n      parsedMaterial.glParameters['blendEquation'] = GL.FUNC_ADD;\n      parsedMaterial.glParameters['blendFunc'] = [\n        GL.SRC_ALPHA,\n        GL.ONE_MINUS_SRC_ALPHA,\n        GL.ONE,\n        GL.ONE_MINUS_SRC_ALPHA\n      ];\n\n      break;\n  }\n}\n\n/** Parse GLTF material sub record */\nfunction parsePbrMetallicRoughness(\n  device: Device,\n  pbrMetallicRoughness: GLTFPBRMetallicRoughness,\n  parsedMaterial: ParsedPBRMaterial\n): void {\n  if (pbrMetallicRoughness.baseColorTexture) {\n    addTexture(\n      device,\n      pbrMetallicRoughness.baseColorTexture,\n      'pbr_baseColorSampler',\n      'HAS_BASECOLORMAP',\n      parsedMaterial\n    );\n  }\n  parsedMaterial.uniforms.baseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];\n\n  if (pbrMetallicRoughness.metallicRoughnessTexture) {\n    addTexture(\n      device,\n      pbrMetallicRoughness.metallicRoughnessTexture,\n      'pbr_metallicRoughnessSampler',\n      'HAS_METALROUGHNESSMAP',\n      parsedMaterial\n    );\n  }\n  const {metallicFactor = 1, roughnessFactor = 1} = pbrMetallicRoughness;\n  parsedMaterial.uniforms.metallicRoughnessValues = [metallicFactor, roughnessFactor];\n}\n\n/** Create a texture from a glTF texture/sampler/image combo and add it to bindings */\nfunction addTexture(\n  device: Device,\n  gltfTexture: GLTFTexture,\n  uniformName: keyof PBRMaterialBindings,\n  define: string,\n  parsedMaterial: ParsedPBRMaterial\n): void {\n  const image = gltfTexture.texture.source.image;\n  let textureOptions;\n\n  if (image.compressed) {\n    textureOptions = image;\n  } else {\n    // Texture2D accepts a promise that returns an image as data (Async Textures)\n    textureOptions = {data: image};\n  }\n\n  const gltfSampler = {\n    wrapS: 10497, // default REPEAT S (U) wrapping mode.\n    wrapT: 10497, // default REPEAT T (V) wrapping mode.\n    ...gltfTexture?.texture?.sampler\n  } as any;\n\n  const texture: Texture = device.createTexture({\n    id: gltfTexture.uniformName || gltfTexture.id,\n    sampler: convertSampler(gltfSampler),\n    ...textureOptions\n  });\n\n  parsedMaterial.bindings[uniformName] = texture;\n  if (define) parsedMaterial.defines[define] = true;\n  parsedMaterial.generatedTextures.push(texture);\n}\n\n/*\n/**\n * Parses a GLTF material definition into uniforms and parameters for the PBR shader module\n *\nexport class PBRMaterialParser {\n  readonly device: Device;\n\n  readonly defines: Record<string, boolean>;\n  readonly bindings: Record<string, Binding>;\n  readonly uniforms: Record<string, any>;\n  readonly parameters: Record<string, any>;\n\n  /** Hold on to generated textures, we destroy them in the destroy method *\n  readonly generatedTextures: Texture[];\n\n  constructor(device: Device, props: PBRMaterialParserProps) {\n    const {attributes, material, pbrDebug, imageBasedLightingEnvironment, lights, useTangents} =\n      props;\n    this.device = device;\n\n    this.defines = {\n      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)\n      MANUAL_SRGB: true,\n      SRGB_FAST_APPROXIMATION: true\n    };\n\n    if (this.device.features.has('glsl-texture-lod')) {\n      this.defines.USE_TEX_LOD = true;\n    }\n\n    this.uniforms = {\n      // TODO: find better values?\n      camera: [0, 0, 0], // Model should override\n\n      metallicRoughnessValues: [1, 1] // Default is 1 and 1\n    };\n\n    this.bindings = {};\n\n    this.parameters = {};\n    this.generatedTextures = [];\n\n    if (imageBasedLightingEnvironment) {\n      this.bindings.pbr_diffuseEnvSampler = imageBasedLightingEnvironment.getDiffuseEnvSampler();\n      this.bindings.pbr_specularEnvSampler = imageBasedLightingEnvironment.getSpecularEnvSampler();\n      this.bindings.pbr_BrdfLUT = imageBasedLightingEnvironment.getBrdfTexture();\n      this.uniforms.scaleIBLAmbient = [1, 1];\n    }\n\n    if (pbrDebug) {\n      // Override final color for reference app visualization\n      // of various parameters in the lighting equation.\n      this.uniforms.scaleDiffBaseMR = [0, 0, 0, 0];\n      this.uniforms.scaleFGDSpec = [0, 0, 0, 0];\n    }\n\n    this.defineIfPresent(attributes.NORMAL, 'HAS_NORMALS');\n    this.defineIfPresent(attributes.TANGENT && useTangents, 'HAS_TANGENTS');\n    this.defineIfPresent(attributes.TEXCOORD_0, 'HAS_UV');\n\n    this.defineIfPresent(imageBasedLightingEnvironment, 'USE_IBL');\n    this.defineIfPresent(lights, 'USE_LIGHTS');\n    this.defineIfPresent(pbrDebug, 'PBR_DEBUG');\n\n    if (material) {\n      this.parseMaterial(material);\n    }\n  }\n\n  /**\n   * Destroy all generated resources to release memory.\n   *\n  destroy(): void {\n    this.generatedTextures.forEach(texture => texture.destroy());\n  }\n\n  /** Add a define if the the value is non-nullish *\n  defineIfPresent(value: unknown, name: string): void {\n    if (value) {\n      this.defines[name] = 1;\n    }\n  }\n\n  /** Parse GLTF material record *\n  parseMaterial(material) {\n    this.uniforms.unlit = Boolean(material.unlit);\n\n    if (material.pbrMetallicRoughness) {\n      this.parsePbrMetallicRoughness(material.pbrMetallicRoughness);\n    }\n    if (material.normalTexture) {\n      this.addTexture(material.normalTexture, 'pbr_normalSampler', 'HAS_NORMALMAP');\n\n      const {scale = 1} = material.normalTexture;\n      this.uniforms.normalScale = scale;\n    }\n    if (material.occlusionTexture) {\n      this.addTexture(material.occlusionTexture, 'pbr_occlusionSampler', 'HAS_OCCLUSIONMAP');\n\n      const {strength = 1} = material.occlusionTexture;\n      this.uniforms.occlusionStrength = strength;\n    }\n    if (material.emissiveTexture) {\n      this.addTexture(material.emissiveTexture, 'pbr_emissiveSampler', 'HAS_EMISSIVEMAP');\n      this.uniforms.emissiveFactor = material.emissiveFactor || [0, 0, 0];\n    }\n    if (material.alphaMode === 'MASK') {\n      const {alphaCutoff = 0.5} = material;\n      this.defines.ALPHA_CUTOFF = true;\n      this.uniforms.u_AlphaCutoff = alphaCutoff;\n    } else if (material.alphaMode === 'BLEND') {\n      log.warn('BLEND alphaMode might not work well because it requires mesh sorting')();\n      Object.assign(this.parameters, {\n        blend: true,\n        blendEquation: GL.FUNC_ADD,\n        blendFunc: [GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA, GL.ONE, GL.ONE_MINUS_SRC_ALPHA]\n      });\n    }\n  }\n\n  /** Parse GLTF material sub record *\n  parsePbrMetallicRoughness(pbrMetallicRoughness) {\n    if (pbrMetallicRoughness.baseColorTexture) {\n      this.addTexture(\n        pbrMetallicRoughness.baseColorTexture,\n        'pbr_baseColorSampler',\n        'HAS_BASECOLORMAP'\n      );\n    }\n    this.uniforms.baseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];\n\n    if (pbrMetallicRoughness.metallicRoughnessTexture) {\n      this.addTexture(\n        pbrMetallicRoughness.metallicRoughnessTexture,\n        'pbr_metallicRoughnessSampler',\n        'HAS_METALROUGHNESSMAP'\n      );\n    }\n    const {metallicFactor = 1, roughnessFactor = 1} = pbrMetallicRoughness;\n    this.uniforms.metallicRoughnessValues = [metallicFactor, roughnessFactor];\n  }\n\n  /** Create a texture from a glTF texture/sampler/image combo and add it to bindings *\n  addTexture(gltfTexture, name, define = null) {\n    const parameters = gltfTexture?.texture?.sampler?.parameters || {};\n\n    const image = gltfTexture.texture.source.image;\n    let textureOptions;\n    let specialTextureParameters = {};\n    if (image.compressed) {\n      textureOptions = image;\n      specialTextureParameters = {\n        [GL.TEXTURE_MIN_FILTER]: image.data.length > 1 ? GL.LINEAR_MIPMAP_NEAREST : GL.LINEAR\n      };\n    } else {\n      // Texture2D accepts a promise that returns an image as data (Async Textures)\n      textureOptions = {data: image};\n    }\n\n    const texture: Texture = this.device.createTexture({\n      id: gltfTexture.name || gltfTexture.id,\n      parameters: {\n        ...parameters,\n        ...specialTextureParameters\n      },\n      pixelStore: {\n        [GL.UNPACK_FLIP_Y_WEBGL]: false\n      },\n      ...textureOptions\n    });\n    this.bindings[name] = texture;\n    this.defineIfPresent(define, define);\n    this.generatedTextures.push(texture);\n  }\n}\n*/\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {PrimitiveTopology} from '@luma.gl/core';\n\n// NOTE: Modules other than `@luma.gl/webgl` should not import `GL` from\n// `@luma.gl/constants`. Locally we use `GLEnum` instead of `GL` to avoid\n// conflicts with the `babel-plugin-inline-webgl-constants` plugin.\n// eslint-disable-next-line no-shadow\nexport enum GLEnum {\n  POINTS = 0x0,\n  LINES = 0x1,\n  LINE_LOOP = 0x2,\n  LINE_STRIP = 0x3,\n  TRIANGLES = 0x4,\n  TRIANGLE_STRIP = 0x5,\n  TRIANGLE_FAN = 0x6\n}\n\nexport function convertGLDrawModeToTopology(\n  drawMode:\n    | GLEnum.POINTS\n    | GLEnum.LINES\n    | GLEnum.LINE_STRIP\n    | GLEnum.LINE_LOOP\n    | GLEnum.TRIANGLES\n    | GLEnum.TRIANGLE_STRIP\n    | GLEnum.TRIANGLE_FAN\n): PrimitiveTopology {\n  // prettier-ignore\n  switch (drawMode) {\n    case GLEnum.POINTS: return 'point-list';\n    case GLEnum.LINES: return 'line-list';\n    case GLEnum.LINE_STRIP: return 'line-strip';\n    case GLEnum.TRIANGLES: return 'triangle-list';\n    case GLEnum.TRIANGLE_STRIP: return 'triangle-strip';\n    default: throw new Error(String(drawMode));\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, type RenderPipelineParameters, log} from '@luma.gl/core';\nimport {pbrMaterial, ShaderModule} from '@luma.gl/shadertools';\nimport {Geometry, Model, ModelNode, type ModelProps} from '@luma.gl/engine';\nimport {type ParsedPBRMaterial} from '../pbr/pbr-material';\n\nconst SHADER = /* WGSL */ `\nlayout(0) positions: vec4; // in vec4 POSITION;\n\n  #ifdef HAS_NORMALS\n    in vec4 normals; // in vec4 NORMAL;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    in vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    // in vec2 TEXCOORD_0;\n    in vec2 texCoords;\n  #endif\n\n@vertex\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = normals;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = texCoords;\n    #endif\n\n    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = u_MVPMatrix * positions;\n  }\n\n@fragment\n  out vec4 fragmentColor;\n\n  void main(void) {\n    vec3 pos = pbr_vPosition;\n    fragmentColor = pbr_filterColor(vec4(1.0));\n  }\n`;\n\n// TODO rename attributes to POSITION/NORMAL etc\n// See gpu-geometry.ts: getAttributeBuffersFromGeometry()\nconst vs = /* glsl */ `\\\n#version 300 es\n\n  // in vec4 POSITION;\n  in vec4 positions;\n\n  #ifdef HAS_NORMALS\n    // in vec4 NORMAL;\n    in vec4 normals;\n  #endif\n\n  #ifdef HAS_TANGENTS\n    in vec4 TANGENT;\n  #endif\n\n  #ifdef HAS_UV\n    // in vec2 TEXCOORD_0;\n    in vec2 texCoords;\n  #endif\n\n  void main(void) {\n    vec4 _NORMAL = vec4(0.);\n    vec4 _TANGENT = vec4(0.);\n    vec2 _TEXCOORD_0 = vec2(0.);\n\n    #ifdef HAS_NORMALS\n      _NORMAL = normals;\n    #endif\n\n    #ifdef HAS_TANGENTS\n      _TANGENT = TANGENT;\n    #endif\n\n    #ifdef HAS_UV\n      _TEXCOORD_0 = texCoords;\n    #endif\n\n    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);\n    gl_Position = pbrProjection.modelViewProjectionMatrix * positions;\n  }\n`;\n\nconst fs = /* glsl */ `\\\n#version 300 es\n  out vec4 fragmentColor;\n\n  void main(void) {\n    vec3 pos = pbr_vPosition;\n    fragmentColor = pbr_filterColor(vec4(1.0));\n  }\n`;\n\nexport type CreateGLTFModelOptions = {\n  id?: string;\n  vertexCount?: number;\n  geometry: Geometry;\n  parsedPPBRMaterial: ParsedPBRMaterial;\n  modelOptions?: Partial<ModelProps>;\n};\n\n/** Creates a luma.gl Model from GLTF data*/\nexport function createGLTFModel(device: Device, options: CreateGLTFModelOptions): ModelNode {\n  const {id, geometry, parsedPPBRMaterial, vertexCount, modelOptions = {}} = options;\n\n  log.info(4, 'createGLTFModel defines: ', parsedPPBRMaterial.defines)();\n\n  // Calculate managedResources\n  // TODO: Implement resource management logic that will\n  // not deallocate resources/textures/buffers that are shared\n  const managedResources: any[] = [];\n  // managedResources.push(...parsedMaterial.generatedTextures);\n  // managedResources.push(...Object.values(attributes).map((attribute) => attribute.buffer));\n\n  const parameters: RenderPipelineParameters = {\n    depthWriteEnabled: true,\n    depthCompare: 'less',\n    depthFormat: 'depth24plus',\n    cullMode: 'back'\n  };\n\n  const modelProps: ModelProps = {\n    id,\n    source: SHADER,\n    vs,\n    fs,\n    geometry,\n    topology: geometry.topology,\n    vertexCount,\n    modules: [pbrMaterial as unknown as ShaderModule],\n    ...modelOptions,\n\n    defines: {...parsedPPBRMaterial.defines, ...modelOptions.defines},\n    parameters: {...parameters, ...parsedPPBRMaterial.parameters, ...modelOptions.parameters}\n  };\n\n  const model = new Model(device, modelProps);\n\n  const {camera, ...pbrMaterialProps} = {\n    ...parsedPPBRMaterial.uniforms,\n    ...modelOptions.uniforms,\n    ...parsedPPBRMaterial.bindings,\n    ...modelOptions.bindings\n  };\n\n  model.shaderInputs.setProps({pbrMaterial: pbrMaterialProps, pbrProjection: {camera}});\n  return new ModelNode({managedResources, model});\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device, type PrimitiveTopology} from '@luma.gl/core';\nimport {Geometry, GeometryAttribute, GroupNode, ModelNode, type ModelProps} from '@luma.gl/engine';\nimport {Matrix4} from '@math.gl/core';\nimport {\n  type GLTFMeshPostprocessed,\n  type GLTFNodePostprocessed,\n  type GLTFPostprocessed\n} from '@loaders.gl/gltf';\nimport {type GLTFScenePostprocessed} from '@loaders.gl/gltf/dist/lib/types/gltf-postprocessed-schema';\n\nimport {type PBREnvironment} from '../pbr/pbr-environment';\nimport {convertGLDrawModeToTopology} from '../webgl-to-webgpu/convert-webgl-topology';\nimport {createGLTFModel} from '../gltf/create-gltf-model';\n\nimport {parsePBRMaterial} from './parse-pbr-material';\n\nexport type ParseGLTFOptions = {\n  modelOptions?: Partial<ModelProps>;\n  pbrDebug?: boolean;\n  imageBasedLightingEnvironment?: PBREnvironment;\n  lights?: boolean;\n  useTangents?: boolean;\n};\n\nconst defaultOptions: Required<ParseGLTFOptions> = {\n  modelOptions: {},\n  pbrDebug: false,\n  imageBasedLightingEnvironment: undefined!,\n  lights: true,\n  useTangents: false\n};\n\n/**\n * GLTF instantiator for luma.gl\n * Walks the parsed and resolved glTF structure and builds a luma.gl scenegraph\n */\nexport function parseGLTF(\n  device: Device,\n  gltf: GLTFPostprocessed,\n  options_: ParseGLTFOptions = {}\n): GroupNode[] {\n  const options = {...defaultOptions, ...options_};\n  const sceneNodes = gltf.scenes.map(gltfScene =>\n    createScene(device, gltfScene, gltf.nodes, options)\n  );\n  return sceneNodes;\n}\n\nfunction createScene(\n  device: Device,\n  gltfScene: GLTFScenePostprocessed,\n  gltfNodes: GLTFNodePostprocessed[],\n  options: Required<ParseGLTFOptions>\n): GroupNode {\n  const gltfSceneNodes = gltfScene.nodes || [];\n  const nodes = gltfSceneNodes.map(node => createNode(device, node, gltfNodes, options));\n  const sceneNode = new GroupNode({\n    id: gltfScene.name || gltfScene.id,\n    children: nodes\n  });\n  return sceneNode;\n}\n\nfunction createNode(\n  device: Device,\n  gltfNode: GLTFNodePostprocessed & {_node?: GroupNode},\n  gltfNodes: GLTFNodePostprocessed[],\n  options: Required<ParseGLTFOptions>\n): GroupNode {\n  if (!gltfNode._node) {\n    const gltfChildren = gltfNode.children || [];\n    const children = gltfChildren.map(child => createNode(device, child, gltfNodes, options));\n\n    // Node can have children nodes and meshes at the same time\n    if (gltfNode.mesh) {\n      children.push(createMesh(device, gltfNode.mesh, options));\n    }\n\n    const node = new GroupNode({\n      id: gltfNode.name || gltfNode.id,\n      children\n    });\n\n    if (gltfNode.matrix) {\n      node.setMatrix(gltfNode.matrix);\n    } else {\n      node.matrix.identity();\n\n      if (gltfNode.translation) {\n        node.matrix.translate(gltfNode.translation);\n      }\n\n      if (gltfNode.rotation) {\n        const rotationMatrix = new Matrix4().fromQuaternion(gltfNode.rotation);\n        node.matrix.multiplyRight(rotationMatrix);\n      }\n\n      if (gltfNode.scale) {\n        node.matrix.scale(gltfNode.scale);\n      }\n    }\n    gltfNode._node = node;\n  }\n\n  // Copy _node so that gltf-animator can access\n  const topLevelNode = gltfNodes.find(node => node.id === gltfNode.id) as any;\n  topLevelNode._node = gltfNode._node;\n\n  return gltfNode._node;\n}\n\nfunction createMesh(\n  device: Device,\n  gltfMesh: GLTFMeshPostprocessed & {_mesh?: GroupNode},\n  options: Required<ParseGLTFOptions>\n): GroupNode {\n  // TODO: avoid changing the gltf\n  if (!gltfMesh._mesh) {\n    const gltfPrimitives = gltfMesh.primitives || [];\n    const primitives = gltfPrimitives.map((gltfPrimitive, i) =>\n      createPrimitive(device, gltfPrimitive, i, gltfMesh, options)\n    );\n    const mesh = new GroupNode({\n      id: gltfMesh.name || gltfMesh.id,\n      children: primitives\n    });\n    gltfMesh._mesh = mesh;\n  }\n\n  return gltfMesh._mesh;\n}\n\nfunction createPrimitive(\n  device: Device,\n  gltfPrimitive: any,\n  i: number,\n  gltfMesh: GLTFMeshPostprocessed,\n  options: Required<ParseGLTFOptions>\n): ModelNode {\n  const id = gltfPrimitive.name || `${gltfMesh.name || gltfMesh.id}-primitive-${i}`;\n  const topology = convertGLDrawModeToTopology(gltfPrimitive.mode || 4);\n  const vertexCount = gltfPrimitive.indices\n    ? gltfPrimitive.indices.count\n    : getVertexCount(gltfPrimitive.attributes);\n\n  const geometry = createGeometry(id, gltfPrimitive, topology);\n\n  const parsedPPBRMaterial = parsePBRMaterial(\n    device,\n    gltfPrimitive.material,\n    geometry.attributes,\n    options\n  );\n\n  const modelNode = createGLTFModel(device, {\n    id,\n    geometry: createGeometry(id, gltfPrimitive, topology),\n    parsedPPBRMaterial,\n    modelOptions: options.modelOptions,\n    vertexCount\n  });\n\n  modelNode.bounds = [gltfPrimitive.attributes.POSITION.min, gltfPrimitive.attributes.POSITION.max];\n  // TODO this holds on to all the CPU side texture and attribute data\n  // modelNode.material =  gltfPrimitive.material;\n\n  return modelNode;\n}\n\nfunction getVertexCount(attributes: any) {\n  throw new Error('getVertexCount not implemented');\n}\n\nfunction createGeometry(id: string, gltfPrimitive: any, topology: PrimitiveTopology): Geometry {\n  const attributes: Record<string, GeometryAttribute> = {};\n  for (const [attributeName, attribute] of Object.entries(gltfPrimitive.attributes)) {\n    const {components, size, value} = attribute as GeometryAttribute;\n\n    attributes[attributeName] = {size: size ?? components, value};\n  }\n\n  return new Geometry({\n    id,\n    topology,\n    indices: gltfPrimitive.indices.value,\n    attributes\n  });\n}\n", "import {GLTFNodePostprocessed} from '@loaders.gl/gltf';\nimport {log} from '@luma.gl/core';\nimport {Quaternion} from '@math.gl/core';\nimport {GLTFAnimationChannel, GLTFAnimationSampler} from './animations';\n\nconst scratchQuaternion = new Quaternion();\n\nexport function interpolate(\n  time: number,\n  {input, interpolation, output}: GLTFAnimationSampler,\n  target: GLTFNodePostprocessed,\n  path: GLTFAnimationChannel['path']\n) {\n  const maxTime = input[input.length - 1];\n  const animationTime = time % maxTime;\n\n  const nextIndex = input.findIndex(t => t >= animationTime);\n  const previousIndex = Math.max(0, nextIndex - 1);\n\n  if (!Array.isArray(target[path])) {\n    switch (path) {\n      case 'translation':\n        target[path] = [0, 0, 0];\n        break;\n\n      case 'rotation':\n        target[path] = [0, 0, 0, 1];\n        break;\n\n      case 'scale':\n        target[path] = [1, 1, 1];\n        break;\n\n      default:\n        log.warn(`Bad animation path ${path}`)();\n    }\n  }\n\n  // assert(target[path].length === output[previousIndex].length);\n  const previousTime = input[previousIndex];\n  const nextTime = input[nextIndex];\n\n  switch (interpolation) {\n    case 'STEP':\n      stepInterpolate(target, path, output[previousIndex] as number[]);\n      break;\n\n    case 'LINEAR':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        linearInterpolate(\n          target,\n          path,\n          output[previousIndex] as number[],\n          output[nextIndex] as number[],\n          ratio\n        );\n      }\n      break;\n\n    case 'CUBICSPLINE':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        const tDiff = nextTime - previousTime;\n\n        const p0 = output[3 * previousIndex + 1] as number[];\n        const outTangent0 = output[3 * previousIndex + 2] as number[];\n        const inTangent1 = output[3 * nextIndex + 0] as number[];\n        const p1 = output[3 * nextIndex + 1] as number[];\n\n        cubicsplineInterpolate(target, path, {p0, outTangent0, inTangent1, p1, tDiff, ratio});\n      }\n      break;\n\n    default:\n      log.warn(`Interpolation ${interpolation} not supported`)();\n      break;\n  }\n}\n\nfunction linearInterpolate(\n  target: GLTFNodePostprocessed,\n  path: GLTFAnimationChannel['path'],\n  start: number[],\n  stop: number[],\n  ratio: number\n) {\n  if (!target[path]) {\n    throw new Error();\n  }\n\n  if (path === 'rotation') {\n    // SLERP when path is rotation\n    scratchQuaternion.slerp({start, target: stop, ratio});\n    for (let i = 0; i < scratchQuaternion.length; i++) {\n      target[path][i] = scratchQuaternion[i];\n    }\n  } else {\n    // regular interpolation\n    for (let i = 0; i < start.length; i++) {\n      target[path][i] = ratio * stop[i] + (1 - ratio) * start[i];\n    }\n  }\n}\n\nfunction cubicsplineInterpolate(\n  target: GLTFNodePostprocessed,\n  path: GLTFAnimationChannel['path'],\n  {\n    p0,\n    outTangent0,\n    inTangent1,\n    p1,\n    tDiff,\n    ratio: t\n  }: {\n    p0: number[];\n    outTangent0: number[];\n    inTangent1: number[];\n    p1: number[];\n    tDiff: number;\n    ratio: number;\n  }\n) {\n  if (!target[path]) {\n    throw new Error();\n  }\n\n  // TODO: Quaternion might need normalization\n  for (let i = 0; i < target[path].length; i++) {\n    const m0 = outTangent0[i] * tDiff;\n    const m1 = inTangent1[i] * tDiff;\n    target[path][i] =\n      (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] +\n      (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 +\n      (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] +\n      (Math.pow(t, 3) - Math.pow(t, 2)) * m1;\n  }\n}\n\nfunction stepInterpolate(\n  target: GLTFNodePostprocessed,\n  path: GLTFAnimationChannel['path'],\n  value: number[]\n) {\n  if (!target[path]) {\n    throw new Error();\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    target[path][i] = value[i];\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {GLTFNodePostprocessed} from '@loaders.gl/gltf';\nimport {log} from '@luma.gl/core';\nimport {GroupNode} from '@luma.gl/engine';\nimport {Matrix4} from '@math.gl/core';\nimport {GLTFAnimation} from './animations/animations';\nimport {interpolate} from './animations/interpolate';\n\ntype GLTFSingleAnimatorProps = {\n  animation: GLTFAnimation;\n  startTime?: number;\n  playing?: boolean;\n  speed?: number;\n};\n\nclass GLTFSingleAnimator {\n  animation: GLTFAnimation;\n  startTime: number = 0;\n  playing: boolean = true;\n  speed: number = 1;\n\n  constructor(props: GLTFSingleAnimatorProps) {\n    this.animation = props.animation;\n    this.animation.name ||= 'unnamed';\n    Object.assign(this, props);\n  }\n\n  setTime(timeMs: number) {\n    if (!this.playing) {\n      return;\n    }\n\n    const absTime = timeMs / 1000;\n    const time = (absTime - this.startTime) * this.speed;\n\n    this.animation.channels.forEach(({sampler, target, path}) => {\n      interpolate(time, sampler, target, path);\n      applyTranslationRotationScale(target, (target as any)._node as GroupNode);\n    });\n  }\n}\n\nexport type GLTFAnimatorProps = {\n  animations: GLTFAnimation[];\n};\n\nexport class GLTFAnimator {\n  animations: GLTFSingleAnimator[];\n\n  constructor(props: GLTFAnimatorProps) {\n    this.animations = props.animations.map((animation, index) => {\n      const name = animation.name || `Animation-${index}`;\n      return new GLTFSingleAnimator({\n        animation: {name, channels: animation.channels}\n      });\n    });\n  }\n\n  /** @deprecated Use .setTime(). Will be removed (deck.gl is using this) */\n  animate(time: number): void {\n    log.warn('GLTFAnimator#animate is deprecated. Use GLTFAnimator#setTime instead')();\n    this.setTime(time);\n  }\n\n  setTime(time: number): void {\n    this.animations.forEach(animation => animation.setTime(time));\n  }\n\n  getAnimations() {\n    return this.animations;\n  }\n}\n\n// TODO: share with GLTFInstantiator\nconst scratchMatrix = new Matrix4();\n\nfunction applyTranslationRotationScale(gltfNode: GLTFNodePostprocessed, node: GroupNode) {\n  node.matrix.identity();\n\n  if (gltfNode.translation) {\n    node.matrix.translate(gltfNode.translation);\n  }\n\n  if (gltfNode.rotation) {\n    const rotationMatrix = scratchMatrix.fromQuaternion(gltfNode.rotation);\n    node.matrix.multiplyRight(rotationMatrix);\n  }\n\n  if (gltfNode.scale) {\n    node.matrix.scale(gltfNode.scale);\n  }\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// TODO: convert in loaders.gl?\nimport type {TypedArray} from '@math.gl/types';\n\nexport const ATTRIBUTE_TYPE_TO_COMPONENTS: Record<string, number> = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nexport const ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY: Record<number, any> = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n\ntype GLTFAccessor = {\n  componentType: number;\n  type: string;\n  count: number;\n  bufferView?: {data: {buffer: ArrayBuffer; byteOffset?: number}};\n  byteOffset?: number;\n};\n\nexport function accessorToTypedArray(accessor: GLTFAccessor): {\n  typedArray: TypedArray;\n  components: number;\n} {\n  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n  const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n  const length = components * accessor.count;\n  const {buffer, byteOffset = 0} = accessor.bufferView?.data ?? {};\n\n  const typedArray = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);\n\n  return {typedArray, components};\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {type GLTFAccessorPostprocessed, type GLTFPostprocessed} from '@loaders.gl/gltf';\nimport {\n  type GLTFAnimation,\n  type GLTFAnimationChannel,\n  type GLTFAnimationSampler\n} from '../gltf/animations/animations';\n\nimport {accessorToTypedArray} from '..//webgl-to-webgpu/convert-webgl-attribute';\n\nexport function parseGLTFAnimations(gltf: GLTFPostprocessed): GLTFAnimation[] {\n  const gltfAnimations = gltf.animations || [];\n  return gltfAnimations.map((animation, index) => {\n    const name = animation.name || `Animation-${index}`;\n    const samplers: GLTFAnimationSampler[] = animation.samplers.map(\n      ({input, interpolation = 'LINEAR', output}) => ({\n        input: accessorToJsArray(gltf.accessors[input]) as number[],\n        interpolation,\n        output: accessorToJsArray(gltf.accessors[output])\n      })\n    );\n    const channels: GLTFAnimationChannel[] = animation.channels.map(({sampler, target}) => ({\n      sampler: samplers[sampler],\n      target: gltf.nodes[target.node ?? 0],\n      path: target.path as GLTFAnimationChannel['path']\n    }));\n    return {name, channels};\n  });\n}\n\n//\n\nfunction accessorToJsArray(\n  accessor: GLTFAccessorPostprocessed & {_animation?: number[] | number[][]}\n): number[] | number[][] {\n  if (!accessor._animation) {\n    const {typedArray: array, components} = accessorToTypedArray(accessor);\n\n    if (components === 1) {\n      accessor._animation = Array.from(array);\n    } else {\n      // Slice array\n      const slicedArray: number[][] = [];\n      for (let i = 0; i < array.length; i += components) {\n        slicedArray.push(Array.from(array.slice(i, i + components)));\n      }\n      accessor._animation = slicedArray;\n    }\n  }\n\n  return accessor._animation;\n}\n", "/** Deeply copies a JS data structure */\nexport function deepCopy(object: any): any {\n  // don't copy binary data\n  if (\n    ArrayBuffer.isView(object) ||\n    object instanceof ArrayBuffer ||\n    object instanceof ImageBitmap\n  ) {\n    return object;\n  }\n  if (Array.isArray(object)) {\n    return object.map(deepCopy);\n  }\n  if (object && typeof object === 'object') {\n    const result: typeof object = {};\n    for (const key in object) {\n      result[key] = deepCopy(object[key]);\n    }\n    return result;\n  }\n  return object;\n}\n", "// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Device} from '@luma.gl/core';\nimport {GroupNode} from '@luma.gl/engine';\nimport {GLTFPostprocessed} from '@loaders.gl/gltf';\nimport {parseGLTF, type ParseGLTFOptions} from '../parsers/parse-gltf';\nimport {GLTFAnimator} from './gltf-animator';\nimport {parseGLTFAnimations} from '../parsers/parse-gltf-animations';\nimport {deepCopy} from '../utils/deep-copy';\n\nexport function createScenegraphsFromGLTF(\n  device: Device,\n  gltf: GLTFPostprocessed,\n  options?: ParseGLTFOptions\n): {\n  scenes: GroupNode[];\n  animator: GLTFAnimator;\n} {\n  gltf = deepCopy(gltf);\n  const scenes = parseGLTF(device, gltf, options);\n  // Note: There is a nasty dependency on injected nodes in the glTF\n  const animations = parseGLTFAnimations(gltf);\n  const animator = new GLTFAnimator({animations});\n  return {scenes, animator};\n}\n", "import { GLTFScenegraph } from \"../api/gltf-scenegraph.js\";\nimport { getPrimitiveTextureData } from \"./utils/3d-tiles-utils.js\";\nimport { getComponentTypeFromArray } from \"../gltf-utils/gltf-utils.js\";\nconst EXT_MESH_FEATURES_NAME = 'EXT_mesh_features';\nexport const name = EXT_MESH_FEATURES_NAME;\nexport async function decode(gltfData, options) {\n    const scenegraph = new GLTFScenegraph(gltfData);\n    decodeExtMeshFeatures(scenegraph, options);\n}\nexport function encode(gltfData, options) {\n    const scenegraph = new GLTFScenegraph(gltfData);\n    encodeExtMeshFeatures(scenegraph, options);\n    scenegraph.createBinaryChunk();\n    return scenegraph.gltf;\n}\n/**\n * Decodes feature metadata from extension.\n * @param {GLTFScenegraph} scenegraph - Instance of the class for structured access to GLTF data.\n * @param {GLTFLoaderOptions} options - GLTFLoader options.\n */\nfunction decodeExtMeshFeatures(scenegraph, options) {\n    const json = scenegraph.gltf.json;\n    if (!json.meshes) {\n        return;\n    }\n    // Iterate through all meshes/primitives.\n    for (const mesh of json.meshes) {\n        for (const primitive of mesh.primitives) {\n            processMeshPrimitiveFeatures(scenegraph, primitive, options);\n        }\n    }\n}\n/**\n * Takes data from EXT_mesh_features and store it in 'data' property of featureIds.\n * If combined with EXT_structural_metadata, corresponding data are taken from the property tables of that extension.\n * @param {GLTFScenegraph} scenegraph - Instance of the class for structured access to GLTF data.\n * @param {GLTFMeshPrimitive} primitive - Primitive that contains extensions.\n * @param {GLTFLoaderOptions} options - GLTFLoader options.\n */\nfunction processMeshPrimitiveFeatures(scenegraph, primitive, options) {\n    // Processing of mesh primitive features requires buffers to be loaded.\n    if (!options?.gltf?.loadBuffers) {\n        return;\n    }\n    const extension = primitive.extensions?.[EXT_MESH_FEATURES_NAME];\n    const featureIds = extension?.featureIds;\n    if (!featureIds) {\n        return;\n    }\n    for (const featureId of featureIds) {\n        let featureIdData;\n        // Process \"Feature ID by Vertex\"\n        if (typeof featureId.attribute !== 'undefined') {\n            const accessorKey = `_FEATURE_ID_${featureId.attribute}`;\n            const accessorIndex = primitive.attributes[accessorKey];\n            featureIdData = scenegraph.getTypedArrayForAccessor(accessorIndex);\n        }\n        // Process \"Feature ID by Texture Coordinates\"\n        else if (typeof featureId.texture !== 'undefined' && options?.gltf?.loadImages) {\n            featureIdData = getPrimitiveTextureData(scenegraph, featureId.texture, primitive);\n        }\n        // Process \"Feature ID by Index\"\n        else {\n            /*\n            When both featureId.attribute and featureId.texture are undefined,\n            then the feature ID value for each vertex is given implicitly, via the index of the vertex.\n            In this case, the featureCount must match the number of vertices of the mesh primitive.\n            */\n            // TODO: At the moment of writing we don't have a tileset with the data of that kind. Implement it later.\n            featureIdData = [];\n        }\n        featureId.data = featureIdData;\n    }\n}\n/*\n  Encoding data\n*/\nfunction encodeExtMeshFeatures(scenegraph, options) {\n    const meshes = scenegraph.gltf.json.meshes;\n    if (!meshes) {\n        return;\n    }\n    // Iterate through all meshes/primitives.\n    for (const mesh of meshes) {\n        for (const primitive of mesh.primitives) {\n            encodeExtMeshFeaturesForPrimitive(scenegraph, primitive);\n        }\n    }\n}\n/**\n * Creates ExtMeshFeatures, creates a featureId containing feature ids provided.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param primitive - target primitive instance that will contain the extension\n * @param featureIdArray - Array of feature id\n * @param propertyTableIndex - index of the property table created by the ExtStructuralMetadata (optional).\n */\nexport function createExtMeshFeatures(scenegraph, primitive, featureIdArray, propertyTableIndex) {\n    if (!primitive.extensions) {\n        primitive.extensions = {};\n    }\n    let extension = primitive.extensions[EXT_MESH_FEATURES_NAME];\n    if (!extension) {\n        extension = { featureIds: [] };\n        primitive.extensions[EXT_MESH_FEATURES_NAME] = extension;\n    }\n    const { featureIds } = extension;\n    const featureId = {\n        featureCount: featureIdArray.length,\n        propertyTable: propertyTableIndex,\n        data: featureIdArray\n    };\n    featureIds.push(featureId);\n    scenegraph.addObjectExtension(primitive, EXT_MESH_FEATURES_NAME, extension);\n}\n/**\n * Encodes a feature ID set to extension.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param primitive - Primitive that the data encoded belongs to.\n * @see https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_mesh_features\n */\nfunction encodeExtMeshFeaturesForPrimitive(scenegraph, primitive) {\n    const extension = primitive.extensions?.[EXT_MESH_FEATURES_NAME];\n    if (!extension) {\n        return;\n    }\n    const featureIds = extension.featureIds;\n    featureIds.forEach((featureId, elementIndex) => {\n        if (featureId.data) {\n            const { accessorKey, index } = createAccessorKey(primitive.attributes);\n            const typedArray = new Uint32Array(featureId.data);\n            // Clean up featureId object.\n            // Everything that could come from the original extension in case of round-trip decode/encode operations should be deleted.\n            // We need make sure the featureId object is clean.\n            featureIds[elementIndex] = {\n                featureCount: typedArray.length,\n                propertyTable: featureId.propertyTable,\n                attribute: index\n            };\n            scenegraph.gltf.buffers.push({\n                arrayBuffer: typedArray.buffer,\n                byteOffset: typedArray.byteOffset,\n                byteLength: typedArray.byteLength\n            });\n            const bufferViewIndex = scenegraph.addBufferView(typedArray);\n            const accessorIndex = scenegraph.addAccessor(bufferViewIndex, {\n                size: 1,\n                componentType: getComponentTypeFromArray(typedArray),\n                count: typedArray.length\n            });\n            primitive.attributes[accessorKey] = accessorIndex;\n        }\n    });\n}\n/**\n * Creates an accessor key for the attribute array provided.\n * The generated key has a suffix (number) that is the next consequtive in the list of existing accessors.\n * @param attributes - attribute array\n * @returns accessor key and the key suffix (number) used in the key.\n */\nfunction createAccessorKey(attributes) {\n    const prefix = '_FEATURE_ID_';\n    // Search for all \"_FEATURE_ID_n\" attribures in the primitive provided if any.\n    // If there are some, e.g. \"_FEATURE_ID_0\", \"_FEATURE_ID_1\",\n    // we will add a new one with the name \"_FEATURE_ID_2\"\n    const attrs = Object.keys(attributes).filter((item) => item.indexOf(prefix) === 0);\n    let max = -1;\n    for (const a of attrs) {\n        const n = Number(a.substring(prefix.length));\n        if (n > max) {\n            max = n;\n        }\n    }\n    max++;\n    const accessorKey = `${prefix}${max}`;\n    return { accessorKey, index: max };\n}\n", "// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\nexport function assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || 'assert failed: gltf');\n    }\n}\n", "export const COMPONENTS = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16\n};\nexport const BYTES = {\n    5120: 1, // BYTE\n    5121: 1, // UNSIGNED_BYTE\n    5122: 2, // SHORT\n    5123: 2, // UNSIGNED_SHORT\n    5125: 4, // UNSIGNED_INT\n    5126: 4 // FLOAT\n};\n// ENUM LOOKUP\nexport function getBytesFromComponentType(componentType) {\n    return BYTES[componentType];\n}\nexport function getSizeFromAccessorType(type) {\n    return COMPONENTS[type];\n}\nexport function getGLEnumFromSamplerParameter(parameter) {\n    const GL_TEXTURE_MAG_FILTER = 0x2800;\n    const GL_TEXTURE_MIN_FILTER = 0x2801;\n    const GL_TEXTURE_WRAP_S = 0x2802;\n    const GL_TEXTURE_WRAP_T = 0x2803;\n    const PARAMETER_MAP = {\n        magFilter: GL_TEXTURE_MAG_FILTER,\n        minFilter: GL_TEXTURE_MIN_FILTER,\n        wrapS: GL_TEXTURE_WRAP_S,\n        wrapT: GL_TEXTURE_WRAP_T\n    };\n    return PARAMETER_MAP[parameter];\n}\n", "import { assert } from \"../utils/assert.js\";\nimport { BYTES, COMPONENTS } from \"../gltf-utils/gltf-constants.js\";\n/**\n * Memory needed to store texture and all mipmap levels 1 + 1/4 + 1/16 + 1/64 + ...\n * Minimum 1.33, but due to GPU layout may be 1.5\n */\nconst MIPMAP_FACTOR = 1.33;\nconst TYPES = ['SCALAR', 'VEC2', 'VEC3', 'VEC4'];\nconst ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT = [\n    [Int8Array, 5120],\n    [Uint8Array, 5121],\n    [Int16Array, 5122],\n    [Uint16Array, 5123],\n    [Uint32Array, 5125],\n    [Float32Array, 5126],\n    [Float64Array, 5130]\n];\nconst ARRAY_TO_COMPONENT_TYPE = new Map(ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT);\nconst ATTRIBUTE_TYPE_TO_COMPONENTS = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16\n};\nconst ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {\n    5120: 1,\n    5121: 1,\n    5122: 2,\n    5123: 2,\n    5125: 4,\n    5126: 4\n};\nconst ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n};\nexport function getAccessorTypeFromSize(size) {\n    const type = TYPES[size - 1];\n    return type || TYPES[0];\n}\nexport function getComponentTypeFromArray(typedArray) {\n    const componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);\n    if (!componentType) {\n        throw new Error('Illegal typed array');\n    }\n    return componentType;\n}\nexport function getAccessorArrayTypeAndLength(accessor, bufferView) {\n    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n    const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];\n    const length = accessor.count * components;\n    const byteLength = accessor.count * components * bytesPerComponent;\n    assert(byteLength >= 0 && byteLength <= bufferView.byteLength);\n    const componentByteSize = BYTES[accessor.componentType];\n    const numberOfComponentsInElement = COMPONENTS[accessor.type];\n    return { ArrayType, length, byteLength, componentByteSize, numberOfComponentsInElement };\n}\n/**\n * Calculate the GPU memory used by a GLTF tile, for both buffer and texture memory\n * @param gltf - the gltf content of a GLTF tile\n * @returns - total memory usage in bytes\n */\nexport function getMemoryUsageGLTF(gltf) {\n    let { images, bufferViews } = gltf;\n    images = images || [];\n    bufferViews = bufferViews || [];\n    const imageBufferViews = images.map((i) => i.bufferView);\n    bufferViews = bufferViews.filter((view) => !imageBufferViews.includes(view));\n    const bufferMemory = bufferViews.reduce((acc, view) => acc + view.byteLength, 0);\n    // Assume each pixel of the texture is 4 channel with mimmaps (which add 33%)\n    // TODO correctly handle compressed textures\n    const pixelCount = images.reduce((acc, image) => {\n        // @ts-ignore\n        const { width, height } = image.image;\n        return acc + width * height;\n    }, 0);\n    return bufferMemory + Math.ceil(4 * pixelCount * MIPMAP_FACTOR);\n}\n", "// TODO - GLTFScenegraph should use these\nimport { assert } from \"../utils/assert.js\";\nimport { getAccessorArrayTypeAndLength } from \"./gltf-utils.js\";\n// accepts buffer view index or buffer view object\n// returns a `Uint8Array`\nexport function getTypedArrayForBufferView(json, buffers, bufferViewIndex) {\n    const bufferView = json.bufferViews[bufferViewIndex];\n    assert(bufferView);\n    // Get hold of the arrayBuffer\n    const bufferIndex = bufferView.buffer;\n    const binChunk = buffers[bufferIndex];\n    assert(binChunk);\n    const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;\n    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);\n}\n// accepts accessor index or accessor object\n// returns a `Uint8Array`\nexport function getTypedArrayForImageData(json, buffers, imageIndex) {\n    const image = json.images[imageIndex];\n    const bufferViewIndex = json.bufferViews[image.bufferView];\n    return getTypedArrayForBufferView(json, buffers, bufferViewIndex);\n}\n/**\n * Gets data pointed by the accessor.\n * @param json - json part of gltf content of a GLTF tile.\n * @param buffers - Array containing buffers of data.\n * @param accessor - accepts accessor index or accessor object.\n * @returns {TypedArray} Typed array with type matching the type of data poited by the accessor.\n */\n// eslint-disable-next-line complexity\nexport function getTypedArrayForAccessor(json, buffers, accessor) {\n    const gltfAccessor = typeof accessor === 'number' ? json.accessors?.[accessor] : accessor;\n    if (!gltfAccessor) {\n        throw new Error(`No gltf accessor ${JSON.stringify(accessor)}`);\n    }\n    const bufferView = json.bufferViews?.[gltfAccessor.bufferView || 0];\n    if (!bufferView) {\n        throw new Error(`No gltf buffer view for accessor ${bufferView}`);\n    }\n    // Get `arrayBuffer` the `bufferView` looks at\n    const { arrayBuffer, byteOffset: bufferByteOffset } = buffers[bufferView.buffer];\n    // Resulting byteOffset is sum of the buffer, accessor and bufferView byte offsets\n    const byteOffset = (bufferByteOffset || 0) + (gltfAccessor.byteOffset || 0) + (bufferView.byteOffset || 0);\n    // Deduce TypedArray type and its length from `accessor` and `bufferView` data\n    const { ArrayType, length, componentByteSize, numberOfComponentsInElement } = getAccessorArrayTypeAndLength(gltfAccessor, bufferView);\n    // 'length' is a whole number of components of all elements in the buffer pointed by the accessor\n    // Multiplier to calculate the address of the element in the arrayBuffer\n    const elementByteSize = componentByteSize * numberOfComponentsInElement;\n    const elementAddressScale = bufferView.byteStride || elementByteSize;\n    // Creare an array of component's type where all components (not just elements) will reside\n    if (typeof bufferView.byteStride === 'undefined' || bufferView.byteStride === elementByteSize) {\n        // No iterleaving\n        const result = new ArrayType(arrayBuffer, byteOffset, length);\n        return result;\n    }\n    // Iterleaving\n    const result = new ArrayType(length);\n    for (let i = 0; i < gltfAccessor.count; i++) {\n        const values = new ArrayType(arrayBuffer, byteOffset + i * elementAddressScale, numberOfComponentsInElement);\n        result.set(values, i * numberOfComponentsInElement);\n    }\n    return result;\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getBinaryImageMetadata } from '@loaders.gl/images';\nimport { padToNBytes, copyToArray } from '@loaders.gl/loader-utils';\nimport { assert } from \"../utils/assert.js\";\nimport { getAccessorTypeFromSize, getComponentTypeFromArray } from \"../gltf-utils/gltf-utils.js\";\nimport { getTypedArrayForAccessor as _getTypedArrayForAccessor } from \"../gltf-utils/get-typed-array.js\";\nfunction makeDefaultGLTFJson() {\n    return {\n        asset: {\n            version: '2.0',\n            generator: 'loaders.gl'\n        },\n        buffers: [],\n        extensions: {},\n        extensionsRequired: [],\n        extensionsUsed: []\n    };\n}\n/**\n * Class for structured access to GLTF data\n */\nexport class GLTFScenegraph {\n    // internal\n    gltf;\n    sourceBuffers;\n    byteLength;\n    // TODO - why is this not GLTFWithBuffers - what happens to images?\n    constructor(gltf) {\n        // Declare locally so\n        this.gltf = {\n            json: gltf?.json || makeDefaultGLTFJson(),\n            buffers: gltf?.buffers || [],\n            images: gltf?.images || []\n        };\n        this.sourceBuffers = [];\n        this.byteLength = 0;\n        // Initialize buffers\n        if (this.gltf.buffers && this.gltf.buffers[0]) {\n            this.byteLength = this.gltf.buffers[0].byteLength;\n            this.sourceBuffers = [this.gltf.buffers[0]];\n        }\n    }\n    // Accessors\n    get json() {\n        return this.gltf.json;\n    }\n    getApplicationData(key) {\n        // TODO - Data is already unpacked by GLBParser\n        const data = this.json[key];\n        return data;\n    }\n    getExtraData(key) {\n        // TODO - Data is already unpacked by GLBParser\n        const extras = (this.json.extras || {});\n        return extras[key];\n    }\n    hasExtension(extensionName) {\n        const isUsedExtension = this.getUsedExtensions().find((name) => name === extensionName);\n        const isRequiredExtension = this.getRequiredExtensions().find((name) => name === extensionName);\n        return typeof isUsedExtension === 'string' || typeof isRequiredExtension === 'string';\n    }\n    getExtension(extensionName) {\n        const isExtension = this.getUsedExtensions().find((name) => name === extensionName);\n        const extensions = this.json.extensions || {};\n        return isExtension ? extensions[extensionName] : null;\n    }\n    getRequiredExtension(extensionName) {\n        const isRequired = this.getRequiredExtensions().find((name) => name === extensionName);\n        return isRequired ? this.getExtension(extensionName) : null;\n    }\n    getRequiredExtensions() {\n        return this.json.extensionsRequired || [];\n    }\n    getUsedExtensions() {\n        return this.json.extensionsUsed || [];\n    }\n    getRemovedExtensions() {\n        return (this.json.extensionsRemoved || []);\n    }\n    getObjectExtension(object, extensionName) {\n        const extensions = object.extensions || {};\n        return extensions[extensionName];\n    }\n    getScene(index) {\n        return this.getObject('scenes', index);\n    }\n    getNode(index) {\n        return this.getObject('nodes', index);\n    }\n    getSkin(index) {\n        return this.getObject('skins', index);\n    }\n    getMesh(index) {\n        return this.getObject('meshes', index);\n    }\n    getMaterial(index) {\n        return this.getObject('materials', index);\n    }\n    getAccessor(index) {\n        return this.getObject('accessors', index);\n    }\n    // getCamera(index: number): object | null {\n    //   return null; // TODO: fix thi: object  as null;\n    // }\n    getTexture(index) {\n        return this.getObject('textures', index);\n    }\n    getSampler(index) {\n        return this.getObject('samplers', index);\n    }\n    getImage(index) {\n        return this.getObject('images', index);\n    }\n    getBufferView(index) {\n        return this.getObject('bufferViews', index);\n    }\n    getBuffer(index) {\n        return this.getObject('buffers', index);\n    }\n    getObject(array, index) {\n        // check if already resolved\n        if (typeof index === 'object') {\n            return index;\n        }\n        const object = this.json[array] && this.json[array][index];\n        if (!object) {\n            throw new Error(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n        }\n        return object;\n    }\n    /**\n     * Accepts buffer view index or buffer view object\n     * @returns a `Uint8Array`\n     */\n    getTypedArrayForBufferView(bufferView) {\n        bufferView = this.getBufferView(bufferView);\n        // @ts-ignore\n        const bufferIndex = bufferView.buffer;\n        // Get hold of the arrayBuffer\n        // const buffer = this.getBuffer(bufferIndex);\n        const binChunk = this.gltf.buffers[bufferIndex];\n        assert(binChunk);\n        // @ts-ignore\n        const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;\n        // @ts-ignore\n        return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);\n    }\n    /** Accepts accessor index or accessor object\n     * @returns a typed array with type that matches the types\n     */\n    getTypedArrayForAccessor(accessor) {\n        // @ts-ignore\n        const gltfAccessor = this.getAccessor(accessor);\n        return _getTypedArrayForAccessor(this.gltf.json, this.gltf.buffers, gltfAccessor);\n    }\n    /** accepts accessor index or accessor object\n     * returns a `Uint8Array`\n     */\n    getTypedArrayForImageData(image) {\n        // @ts-ignore\n        image = this.getAccessor(image);\n        // @ts-ignore\n        const bufferView = this.getBufferView(image.bufferView);\n        const buffer = this.getBuffer(bufferView.buffer);\n        // @ts-ignore\n        const arrayBuffer = buffer.data;\n        const byteOffset = bufferView.byteOffset || 0;\n        return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n    }\n    // MODIFERS\n    /**\n     * Add an extra application-defined key to the top-level data structure\n     */\n    addApplicationData(key, data) {\n        this.json[key] = data;\n        return this;\n    }\n    /**\n     * `extras` - Standard GLTF field for storing application specific data\n     */\n    addExtraData(key, data) {\n        this.json.extras = this.json.extras || {};\n        this.json.extras[key] = data;\n        return this;\n    }\n    addObjectExtension(object, extensionName, data) {\n        // @ts-ignore\n        object.extensions = object.extensions || {};\n        // TODO - clobber or merge?\n        // @ts-ignore\n        object.extensions[extensionName] = data;\n        this.registerUsedExtension(extensionName);\n        return this;\n    }\n    setObjectExtension(object, extensionName, data) {\n        const extensions = object.extensions || {};\n        extensions[extensionName] = data;\n        // TODO - add to usedExtensions...\n    }\n    removeObjectExtension(object, extensionName) {\n        const extensions = object?.extensions || {};\n        if (extensions[extensionName]) {\n            this.json.extensionsRemoved = this.json.extensionsRemoved || [];\n            const extensionsRemoved = this.json.extensionsRemoved;\n            if (!extensionsRemoved.includes(extensionName)) {\n                extensionsRemoved.push(extensionName);\n            }\n        }\n        delete extensions[extensionName];\n    }\n    /**\n     * Add to standard GLTF top level extension object, mark as used\n     */\n    addExtension(extensionName, extensionData = {}) {\n        assert(extensionData);\n        this.json.extensions = this.json.extensions || {};\n        this.json.extensions[extensionName] = extensionData;\n        this.registerUsedExtension(extensionName);\n        return extensionData;\n    }\n    /**\n     * Standard GLTF top level extension object, mark as used and required\n     */\n    addRequiredExtension(extensionName, extensionData = {}) {\n        assert(extensionData);\n        this.addExtension(extensionName, extensionData);\n        this.registerRequiredExtension(extensionName);\n        return extensionData;\n    }\n    /**\n     * Add extensionName to list of used extensions\n     */\n    registerUsedExtension(extensionName) {\n        this.json.extensionsUsed = this.json.extensionsUsed || [];\n        if (!this.json.extensionsUsed.find((ext) => ext === extensionName)) {\n            this.json.extensionsUsed.push(extensionName);\n        }\n    }\n    /**\n     * Add extensionName to list of required extensions\n     */\n    registerRequiredExtension(extensionName) {\n        this.registerUsedExtension(extensionName);\n        this.json.extensionsRequired = this.json.extensionsRequired || [];\n        if (!this.json.extensionsRequired.find((ext) => ext === extensionName)) {\n            this.json.extensionsRequired.push(extensionName);\n        }\n    }\n    /**\n     * Removes an extension from the top-level list\n     */\n    removeExtension(extensionName) {\n        if (this.json.extensions?.[extensionName]) {\n            this.json.extensionsRemoved = this.json.extensionsRemoved || [];\n            const extensionsRemoved = this.json.extensionsRemoved;\n            if (!extensionsRemoved.includes(extensionName)) {\n                extensionsRemoved.push(extensionName);\n            }\n        }\n        if (this.json.extensions) {\n            delete this.json.extensions[extensionName];\n        }\n        if (this.json.extensionsRequired) {\n            this._removeStringFromArray(this.json.extensionsRequired, extensionName);\n        }\n        if (this.json.extensionsUsed) {\n            this._removeStringFromArray(this.json.extensionsUsed, extensionName);\n        }\n    }\n    /**\n     *  Set default scene which is to be displayed at load time\n     */\n    setDefaultScene(sceneIndex) {\n        this.json.scene = sceneIndex;\n    }\n    /**\n     * @todo: add more properties for scene initialization:\n     *   name`, `extensions`, `extras`\n     *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-scene\n     */\n    addScene(scene) {\n        const { nodeIndices } = scene;\n        this.json.scenes = this.json.scenes || [];\n        this.json.scenes.push({ nodes: nodeIndices });\n        return this.json.scenes.length - 1;\n    }\n    /**\n     * @todo: add more properties for node initialization:\n     *   `name`, `extensions`, `extras`, `camera`, `children`, `skin`, `rotation`, `scale`, `translation`, `weights`\n     *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#node\n     */\n    addNode(node) {\n        const { meshIndex, matrix } = node;\n        this.json.nodes = this.json.nodes || [];\n        const nodeData = { mesh: meshIndex };\n        if (matrix) {\n            // @ts-ignore\n            nodeData.matrix = matrix;\n        }\n        this.json.nodes.push(nodeData);\n        return this.json.nodes.length - 1;\n    }\n    /** Adds a mesh to the json part */\n    addMesh(mesh) {\n        const { attributes, indices, material, mode = 4 } = mesh;\n        const accessors = this._addAttributes(attributes);\n        const glTFMesh = {\n            primitives: [\n                {\n                    attributes: accessors,\n                    mode\n                }\n            ]\n        };\n        if (indices) {\n            const indicesAccessor = this._addIndices(indices);\n            // @ts-ignore\n            glTFMesh.primitives[0].indices = indicesAccessor;\n        }\n        if (Number.isFinite(material)) {\n            // @ts-ignore\n            glTFMesh.primitives[0].material = material;\n        }\n        this.json.meshes = this.json.meshes || [];\n        this.json.meshes.push(glTFMesh);\n        return this.json.meshes.length - 1;\n    }\n    addPointCloud(attributes) {\n        // @ts-ignore\n        const accessorIndices = this._addAttributes(attributes);\n        const glTFMesh = {\n            primitives: [\n                {\n                    attributes: accessorIndices,\n                    mode: 0 // GL.POINTS\n                }\n            ]\n        };\n        this.json.meshes = this.json.meshes || [];\n        this.json.meshes.push(glTFMesh);\n        return this.json.meshes.length - 1;\n    }\n    /**\n     * Adds a binary image. Builds glTF \"JSON metadata\" and saves buffer reference\n     * Buffer will be copied into BIN chunk during \"pack\"\n     * Currently encodes as glTF image\n     * @param imageData\n     * @param mimeType\n     */\n    addImage(imageData, mimeTypeOpt) {\n        // If image is referencing a bufferView instead of URI, mimeType must be defined:\n        //   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#images\n        //   \"a reference to a bufferView; in that case mimeType must be defined.\"\n        const metadata = getBinaryImageMetadata(imageData);\n        const mimeType = mimeTypeOpt || metadata?.mimeType;\n        const bufferViewIndex = this.addBufferView(imageData);\n        const glTFImage = {\n            bufferView: bufferViewIndex,\n            mimeType\n        };\n        this.json.images = this.json.images || [];\n        this.json.images.push(glTFImage);\n        return this.json.images.length - 1;\n    }\n    /**\n     * Add one untyped source buffer, create a matching glTF `bufferView`, and return its index\n     * @param buffer\n     */\n    addBufferView(buffer, bufferIndex = 0, byteOffset = this.byteLength) {\n        const byteLength = buffer.byteLength;\n        assert(Number.isFinite(byteLength));\n        // Add this buffer to the list of buffers to be written to the body.\n        this.sourceBuffers = this.sourceBuffers || [];\n        this.sourceBuffers.push(buffer);\n        const glTFBufferView = {\n            buffer: bufferIndex,\n            // Write offset from the start of the binary body\n            byteOffset,\n            byteLength\n        };\n        // We've now added the contents to the body, so update the total length\n        // Every sub-chunk needs to be 4-byte align ed\n        this.byteLength += padToNBytes(byteLength, 4);\n        // Add a bufferView indicating start and length of this binary sub-chunk\n        this.json.bufferViews = this.json.bufferViews || [];\n        this.json.bufferViews.push(glTFBufferView);\n        return this.json.bufferViews.length - 1;\n    }\n    /**\n     * Adds an accessor to a bufferView\n     * @param bufferViewIndex\n     * @param accessor\n     */\n    addAccessor(bufferViewIndex, accessor) {\n        const glTFAccessor = {\n            bufferView: bufferViewIndex,\n            // @ts-ignore\n            type: getAccessorTypeFromSize(accessor.size),\n            // @ts-ignore\n            componentType: accessor.componentType,\n            // @ts-ignore\n            count: accessor.count,\n            // @ts-ignore\n            max: accessor.max,\n            // @ts-ignore\n            min: accessor.min\n        };\n        this.json.accessors = this.json.accessors || [];\n        this.json.accessors.push(glTFAccessor);\n        return this.json.accessors.length - 1;\n    }\n    /**\n     * Add a binary buffer. Builds glTF \"JSON metadata\" and saves buffer reference\n     * Buffer will be copied into BIN chunk during \"pack\"\n     * Currently encodes buffers as glTF accessors, but this could be optimized\n     * @param sourceBuffer\n     * @param accessor\n     */\n    addBinaryBuffer(sourceBuffer, accessor = { size: 3 }) {\n        const bufferViewIndex = this.addBufferView(sourceBuffer);\n        // @ts-ignore\n        let minMax = { min: accessor.min, max: accessor.max };\n        if (!minMax.min || !minMax.max) {\n            // @ts-ignore\n            minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);\n        }\n        const accessorDefaults = {\n            // @ts-ignore\n            size: accessor.size,\n            componentType: getComponentTypeFromArray(sourceBuffer),\n            // @ts-ignore\n            count: Math.round(sourceBuffer.length / accessor.size),\n            min: minMax.min,\n            max: minMax.max\n        };\n        return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));\n    }\n    /**\n     * Adds a texture to the json part\n     * @todo: add more properties for texture initialization\n     * `sampler`, `name`, `extensions`, `extras`\n     * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\n     */\n    addTexture(texture) {\n        const { imageIndex } = texture;\n        const glTFTexture = {\n            source: imageIndex\n        };\n        this.json.textures = this.json.textures || [];\n        this.json.textures.push(glTFTexture);\n        return this.json.textures.length - 1;\n    }\n    /** Adds a material to the json part */\n    addMaterial(pbrMaterialInfo) {\n        this.json.materials = this.json.materials || [];\n        this.json.materials.push(pbrMaterialInfo);\n        return this.json.materials.length - 1;\n    }\n    /** Pack the binary chunk */\n    createBinaryChunk() {\n        // Allocate total array\n        const totalByteLength = this.byteLength;\n        const arrayBuffer = new ArrayBuffer(totalByteLength);\n        const targetArray = new Uint8Array(arrayBuffer);\n        // Copy each array into\n        let dstByteOffset = 0;\n        for (const sourceBuffer of this.sourceBuffers || []) {\n            dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);\n        }\n        // Update the glTF BIN CHUNK byte length\n        if (this.json?.buffers?.[0]) {\n            this.json.buffers[0].byteLength = totalByteLength;\n        }\n        else {\n            this.json.buffers = [{ byteLength: totalByteLength }];\n        }\n        // Save generated arrayBuffer\n        this.gltf.binary = arrayBuffer;\n        // Put arrayBuffer to sourceBuffers for possible additional writing data in the chunk\n        this.sourceBuffers = [arrayBuffer];\n        this.gltf.buffers = [{ arrayBuffer, byteOffset: 0, byteLength: arrayBuffer.byteLength }];\n    }\n    // PRIVATE\n    _removeStringFromArray(array, string) {\n        let found = true;\n        while (found) {\n            const index = array.indexOf(string);\n            if (index > -1) {\n                array.splice(index, 1);\n            }\n            else {\n                found = false;\n            }\n        }\n    }\n    /**\n     * Add attributes to buffers and create `attributes` object which is part of `mesh`\n     */\n    _addAttributes(attributes = {}) {\n        const result = {};\n        for (const attributeKey in attributes) {\n            const attributeData = attributes[attributeKey];\n            const attrName = this._getGltfAttributeName(attributeKey);\n            const accessor = this.addBinaryBuffer(attributeData.value, attributeData);\n            result[attrName] = accessor;\n        }\n        return result;\n    }\n    /**\n     * Add indices to buffers\n     */\n    _addIndices(indices) {\n        return this.addBinaryBuffer(indices, { size: 1 });\n    }\n    /**\n     * Deduce gltf specific attribue name from input attribute name\n     */\n    _getGltfAttributeName(attributeName) {\n        switch (attributeName.toLowerCase()) {\n            case 'position':\n            case 'positions':\n            case 'vertices':\n                return 'POSITION';\n            case 'normal':\n            case 'normals':\n                return 'NORMAL';\n            case 'color':\n            case 'colors':\n                return 'COLOR_0';\n            case 'texcoord':\n            case 'texcoords':\n                return 'TEXCOORD_0';\n            default:\n                return attributeName;\n        }\n    }\n    /**\n     * Calculate `min` and `max` arrays of accessor according to spec:\n     * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-accessor\n     */\n    _getAccessorMinMax(buffer, size) {\n        const result = { min: null, max: null };\n        if (buffer.length < size) {\n            return result;\n        }\n        // @ts-ignore\n        result.min = [];\n        // @ts-ignore\n        result.max = [];\n        const initValues = buffer.subarray(0, size);\n        for (const value of initValues) {\n            // @ts-ignore\n            result.min.push(value);\n            // @ts-ignore\n            result.max.push(value);\n        }\n        for (let index = size; index < buffer.length; index += size) {\n            for (let componentIndex = 0; componentIndex < size; componentIndex++) {\n                // @ts-ignore\n                result.min[0 + componentIndex] = Math.min(\n                // @ts-ignore\n                result.min[0 + componentIndex], buffer[index + componentIndex]);\n                // @ts-ignore\n                result.max[0 + componentIndex] = Math.max(\n                // @ts-ignore\n                result.max[0 + componentIndex], buffer[index + componentIndex]);\n            }\n        }\n        return result;\n    }\n}\n", "/**\n * loaders.gl, MIT license\n *\n * Shared code for 3DTiles extensions:\n * * EXT_feature_metadata\n * * EXT_mesh_features\n * * EXT_structural_metadata\n */\nimport { getComponentTypeFromArray } from \"../../gltf-utils/gltf-utils.js\";\nimport { getImageData } from '@loaders.gl/images';\nfunction emod(n) {\n    return ((n % 1) + 1) % 1;\n}\nconst ATTRIBUTE_TYPE_TO_COMPONENTS = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16,\n    BOOLEAN: 1,\n    STRING: 1,\n    ENUM: 1\n};\nconst ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n    INT8: Int8Array,\n    UINT8: Uint8Array,\n    INT16: Int16Array,\n    UINT16: Uint16Array,\n    INT32: Int32Array,\n    UINT32: Uint32Array,\n    INT64: BigInt64Array,\n    UINT64: BigUint64Array,\n    FLOAT32: Float32Array,\n    FLOAT64: Float64Array\n};\nconst ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {\n    INT8: 1,\n    UINT8: 1,\n    INT16: 2,\n    UINT16: 2,\n    INT32: 4,\n    UINT32: 4,\n    INT64: 8,\n    UINT64: 8,\n    FLOAT32: 4,\n    FLOAT64: 8\n};\nexport function getArrayElementByteSize(attributeType, componentType) {\n    return (ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[componentType] *\n        ATTRIBUTE_TYPE_TO_COMPONENTS[attributeType]);\n}\n/**\n * Gets offset array from `arrayOffsets` or `stringOffsets`.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param bufferViewIndex - Buffer view index\n * @param offsetType - The type of values in `arrayOffsets` or `stringOffsets`.\n * @param numberOfElements - The number of elements in each property array.\n * @returns Array of values offsets. The number of offsets in the array is equal to `numberOfElements` plus one.\n */\nexport function getOffsetsForProperty(scenegraph, bufferViewIndex, offsetType, numberOfElements) {\n    if (offsetType !== 'UINT8' &&\n        offsetType !== 'UINT16' &&\n        offsetType !== 'UINT32' &&\n        offsetType !== 'UINT64') {\n        return null;\n    }\n    const arrayOffsetsBytes = scenegraph.getTypedArrayForBufferView(bufferViewIndex);\n    const arrayOffsets = convertRawBufferToMetadataArray(arrayOffsetsBytes, 'SCALAR', // offsets consist of ONE component\n    offsetType, numberOfElements + 1 // The number of offsets is equal to the property table `count` plus one.\n    );\n    // We don't support BigInt offsets at the moment. It requires additional logic and potential issues in Safari\n    if (arrayOffsets instanceof BigInt64Array || arrayOffsets instanceof BigUint64Array) {\n        return null;\n    }\n    return arrayOffsets;\n}\n/**\n * Converts raw bytes that are in the buffer to an array of the type defined by the schema.\n * @param data - Raw bytes in the buffer.\n * @param attributeType - SCALAR, VECN, MATN.\n * @param componentType - Type of the component in elements, e.g. 'UINT8' or 'FLOAT32'.\n * @param elementCount - Number of elements in the array. Default value is 1.\n * @returns Data array\n */\nexport function convertRawBufferToMetadataArray(data, attributeType, componentType, elementCount = 1) {\n    const numberOfComponents = ATTRIBUTE_TYPE_TO_COMPONENTS[attributeType];\n    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[componentType];\n    const size = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[componentType];\n    const length = elementCount * numberOfComponents;\n    const byteLength = length * size;\n    let buffer = data.buffer;\n    let offset = data.byteOffset;\n    if (offset % size !== 0) {\n        const bufferArray = new Uint8Array(buffer);\n        buffer = bufferArray.slice(offset, offset + byteLength).buffer;\n        offset = 0;\n    }\n    return new ArrayType(buffer, offset, length);\n}\n/**\n * Processes data encoded in the texture associated with the primitive.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param textureInfo - Reference to the texture where extension data are stored.\n * @param primitive - Primitive object in the mesh.\n * @returns Array of data taken. Null if data can't be taken from the texture.\n */\nexport function getPrimitiveTextureData(scenegraph, textureInfo, primitive) {\n    /*\n      texture.index is an index for the \"textures\" array.\n      The texture object referenced by this index looks like this:\n      {\n      \"sampler\": 0,\n      \"source\": 0\n      }\n      \"sampler\" is an index for the \"samplers\" array\n      \"source\" is an index for the \"images\" array that contains data stored in rgba channels of the image.\n  \n      texture.texCoord is a number-suffix (like 1) for an attribute like \"TEXCOORD_1\" in meshes.primitives\n      The value of \"TEXCOORD_1\" is an accessor that is used to get coordinates.\n      These coordinates are being used to get data from the image.\n      \n      Default for texture.texCoord is 0\n      @see https://github.com/CesiumGS/glTF/blob/3d-tiles-next/specification/2.0/schema/textureInfo.schema.json\n    */\n    const texCoordAccessorKey = `TEXCOORD_${textureInfo.texCoord || 0}`;\n    const texCoordAccessorIndex = primitive.attributes[texCoordAccessorKey];\n    const textureCoordinates = scenegraph.getTypedArrayForAccessor(texCoordAccessorIndex);\n    const json = scenegraph.gltf.json;\n    const textureIndex = textureInfo.index;\n    const imageIndex = json.textures?.[textureIndex]?.source;\n    if (typeof imageIndex !== 'undefined') {\n        const mimeType = json.images?.[imageIndex]?.mimeType;\n        const parsedImage = scenegraph.gltf.images?.[imageIndex];\n        // Checking for width is to prevent handling Un-processed images (e.g. [analyze] stage, where loadImages option is set to false)\n        if (parsedImage && typeof parsedImage.width !== 'undefined') {\n            const textureData = [];\n            for (let index = 0; index < textureCoordinates.length; index += 2) {\n                const value = getImageValueByCoordinates(parsedImage, mimeType, textureCoordinates, index, textureInfo.channels);\n                textureData.push(value);\n            }\n            return textureData;\n        }\n    }\n    return [];\n}\n/**\n * Puts property data to attributes.\n * It creates corresponding buffer, bufferView and accessor\n * so the data can be accessed like regular data stored in buffers.\n * @param scenegraph - Scenegraph object.\n * @param attributeName - Name of the attribute.\n * @param propertyData - Property data to store.\n * @param featureTable - Array where unique data from the property data are being stored.\n * @param primitive - Primitive object.\n */\nexport function primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTable, primitive) {\n    // No reason to create an empty buffer if there is no property data to store.\n    if (!propertyData?.length) {\n        return;\n    }\n    /*\n      featureTable will contain unique values, e.g.\n      propertyData = [24, 35, 28, 24]\n      featureTable = [24, 35, 28]\n      featureIndices will contain indices that refer featureTextureTable, e.g.\n      featureIndices = [0, 1, 2, 0]\n    */\n    const featureIndices = [];\n    for (const texelData of propertyData) {\n        let index = featureTable.findIndex((item) => item === texelData);\n        if (index === -1) {\n            index = featureTable.push(texelData) - 1;\n        }\n        featureIndices.push(index);\n    }\n    const typedArray = new Uint32Array(featureIndices);\n    const bufferIndex = scenegraph.gltf.buffers.push({\n        arrayBuffer: typedArray.buffer,\n        byteOffset: typedArray.byteOffset,\n        byteLength: typedArray.byteLength\n    }) - 1;\n    const bufferViewIndex = scenegraph.addBufferView(typedArray, bufferIndex, 0);\n    const accessorIndex = scenegraph.addAccessor(bufferViewIndex, {\n        size: 1,\n        componentType: getComponentTypeFromArray(typedArray),\n        count: typedArray.length\n    });\n    primitive.attributes[attributeName] = accessorIndex;\n}\n/**\n * Gets the value from the texture by coordinates provided.\n * @param parsedImage - Image where the data are stored.\n * @param mimeType - MIME type.\n * @param textureCoordinates - uv coordinates to access data in the image.\n * @param index - Index of uv coordinates in the array textureCoordinates.\n * @param channels - Image channels where data are stored.\n *  Channels of an RGBA texture are numbered 0..3 respectively.\n *  For Ext_mesh_features and EXT_strucural_metadata the channels default is [0]\n *  @see https://github.com/CesiumGS/glTF/blob/3d-tiles-next/extensions/2.0/Vendor/EXT_mesh_features/schema/featureIdTexture.schema.json\n *  @see https://github.com/CesiumGS/glTF/blob/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata/schema/propertyTexture.property.schema.json\n * @returns Value taken from the image.\n */\nfunction getImageValueByCoordinates(parsedImage, mimeType, textureCoordinates, index, channels = [0]) {\n    const CHANNELS_MAP = {\n        r: { offset: 0, shift: 0 },\n        g: { offset: 1, shift: 8 },\n        b: { offset: 2, shift: 16 },\n        a: { offset: 3, shift: 24 }\n    };\n    const u = textureCoordinates[index];\n    const v = textureCoordinates[index + 1];\n    let components = 1;\n    if (mimeType && (mimeType.indexOf('image/jpeg') !== -1 || mimeType.indexOf('image/png') !== -1))\n        components = 4;\n    const offset = coordinatesToOffset(u, v, parsedImage, components);\n    let value = 0;\n    for (const c of channels) {\n        /*\n        According to the EXT_feature_metadata extension specification:\n          Channels are labeled by rgba and are swizzled with a string of 1-4 characters.\n        According to the EXT_mesh_features extension specification:\n          The channels array contains non-negative integer values corresponding to channels of the source texture that the feature ID consists of.\n          Channels of an RGBA texture are numbered 03 respectively.\n        Function getImageValueByCoordinates is used to process both extensions.\n        So, there should be possible to get the element of CHANNELS_MAP by either index (0, 1, 2, 3) or key (r, g, b, a).\n        */\n        const map = typeof c === 'number' ? Object.values(CHANNELS_MAP)[c] : CHANNELS_MAP[c];\n        const imageOffset = offset + map.offset;\n        const imageData = getImageData(parsedImage);\n        if (imageData.data.length <= imageOffset) {\n            throw new Error(`${imageData.data.length} <= ${imageOffset}`);\n        }\n        const imageValue = imageData.data[imageOffset];\n        value |= imageValue << map.shift;\n    }\n    return value;\n}\n/**\n * Retrieves the offset in the image where the data are stored.\n * @param u - u-coordinate.\n * @param v - v-coordinate.\n * @param parsedImage - Image where the data are stored.\n * @param componentsCount - Number of components the data consists of.\n * @returns Offset in the image where the data are stored.\n */\nfunction coordinatesToOffset(u, v, parsedImage, componentsCount = 1) {\n    const w = parsedImage.width;\n    const iX = emod(u) * (w - 1);\n    const indX = Math.round(iX);\n    const h = parsedImage.height;\n    const iY = emod(v) * (h - 1);\n    const indY = Math.round(iY);\n    const components = parsedImage.components ? parsedImage.components : componentsCount;\n    // components is a number of channels in the image\n    const offset = (indY * w + indX) * components;\n    return offset;\n}\n/**\n * Parses variable-length array data.\n * In this case every value of the property in the table will be an array\n * of arbitrary length.\n * @param valuesData - Values in a flat typed array.\n * @param numberOfElements - Number of rows in the property table.\n * @param arrayOffsets - Offsets of nested arrays in the flat values array.\n * @param valuesDataBytesLength - Data byte length.\n * @param valueSize - Value size in bytes.\n * @returns Array of typed arrays.\n */\nexport function parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytesLength, valueSize) {\n    const attributeValueArray = [];\n    for (let index = 0; index < numberOfElements; index++) {\n        const arrayOffset = arrayOffsets[index];\n        const arrayByteSize = arrayOffsets[index + 1] - arrayOffsets[index];\n        if (arrayByteSize + arrayOffset > valuesDataBytesLength) {\n            break;\n        }\n        const typedArrayOffset = arrayOffset / valueSize;\n        const elementCount = arrayByteSize / valueSize;\n        attributeValueArray.push(valuesData.slice(typedArrayOffset, typedArrayOffset + elementCount));\n    }\n    return attributeValueArray;\n}\n/**\n * Parses fixed-length array data.\n * In this case every value of the property in the table will be an array\n * of constant length equal to `arrayCount`.\n * @param valuesData - Values in a flat typed array.\n * @param numberOfElements - Number of rows in the property table.\n * @param arrayCount - Nested arrays length.\n * @returns Array of typed arrays.\n */\nexport function parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount) {\n    const attributeValueArray = [];\n    for (let index = 0; index < numberOfElements; index++) {\n        const elementOffset = index * arrayCount;\n        attributeValueArray.push(valuesData.slice(elementOffset, elementOffset + arrayCount));\n    }\n    return attributeValueArray;\n}\n/**\n * Decodes properties of string type from binary source.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param valuesDataBytes - Data taken from values property of the property table property.\n * @param arrayOffsets - Offsets for variable-length arrays. It's null for fixed-length arrays or scalar types.\n * @param stringOffsets - Index of the buffer view containing offsets for strings. It should be available for string type.\n * @returns String property values\n */\nexport function getPropertyDataString(numberOfElements, valuesDataBytes, arrayOffsets, stringOffsets) {\n    if (arrayOffsets) {\n        // TODO: implement it as soon as we have the corresponding tileset\n        throw new Error('Not implemented - arrayOffsets for strings is specified');\n    }\n    if (stringOffsets) {\n        const stringsArray = [];\n        const textDecoder = new TextDecoder('utf8');\n        let stringOffset = 0;\n        for (let index = 0; index < numberOfElements; index++) {\n            const stringByteSize = stringOffsets[index + 1] - stringOffsets[index];\n            if (stringByteSize + stringOffset <= valuesDataBytes.length) {\n                const stringData = valuesDataBytes.subarray(stringOffset, stringByteSize + stringOffset);\n                const stringAttribute = textDecoder.decode(stringData);\n                stringsArray.push(stringAttribute);\n                stringOffset += stringByteSize;\n            }\n        }\n        return stringsArray;\n    }\n    return [];\n}\n", "import { GLTFScenegraph } from \"../api/gltf-scenegraph.js\";\nimport { convertRawBufferToMetadataArray, getPrimitiveTextureData, primitivePropertyDataToAttributes, getArrayElementByteSize, getOffsetsForProperty, parseVariableLengthArrayNumeric, parseFixedLengthArrayNumeric, getPropertyDataString } from \"./utils/3d-tiles-utils.js\";\nconst EXT_STRUCTURAL_METADATA_NAME = 'EXT_structural_metadata';\nexport const name = EXT_STRUCTURAL_METADATA_NAME;\nexport async function decode(gltfData, options) {\n    const scenegraph = new GLTFScenegraph(gltfData);\n    decodeExtStructuralMetadata(scenegraph, options);\n}\nexport function encode(gltfData, options) {\n    const scenegraph = new GLTFScenegraph(gltfData);\n    encodeExtStructuralMetadata(scenegraph, options);\n    scenegraph.createBinaryChunk();\n    return scenegraph.gltf;\n}\n/*\n// Example of the extension.\n// See more info at https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata\nconst extensions = {\n  \"extensions\": {\n    \"EXT_structural_metadata\": {\n      \"schema\": {\n        \"classes\": {\n          \"tree\": {\n            \"name\": \"Tree\",\n            \"description\": \"Woody, perennial plant.\",\n            \"properties\": {\n              \"species\": {\n                \"description\": \"Type of tree.\",\n                \"type\": \"ENUM\",\n                \"enumType\": \"speciesEnum\",\n                \"required\": true\n              },\n              \"age\": {\n                \"description\": \"The age of the tree, in years\",\n                \"type\": \"SCALAR\",\n                \"componentType\": \"UINT8\",\n                \"required\": true\n              }\n            }\n          }\n        },\n        \"enums\": {\n          \"speciesEnum\": {\n            \"name\": \"Species\",\n            \"description\": \"An example enum for tree species.\",\n            // valueType is not defined here. Default is \"UINT16\"\n            \"values\": [\n              { \"name\": \"Unspecified\", \"value\": 0 },\n              { \"name\": \"Oak\", \"value\": 1 }\n            ]\n          }\n        }\n      },\n      \"propertyTables\": [{\n        \"name\": \"tree_survey_2021-09-29\",\n        \"class\": \"tree\",\n        \"count\": 10,  // The number of elements in each property array (in `species`, in `age`).\n        \"properties\": {\n          \"species\": {\n            \"values\": 0, // It's an index of the buffer view containing property values.\n          },\n          \"age\": {\n            \"values\": 1\n          }\n        }\n      }]\n    }\n  }\n}\n*/\n/**\n * Decodes feature metadata from extension.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param options - GLTFLoader options.\n */\nfunction decodeExtStructuralMetadata(scenegraph, options) {\n    // Decoding metadata involves buffers processing.\n    // So, if buffers have not been loaded, there is no reason to process metadata.\n    if (!options.gltf?.loadBuffers) {\n        return;\n    }\n    const extension = scenegraph.getExtension(EXT_STRUCTURAL_METADATA_NAME);\n    if (!extension) {\n        return;\n    }\n    if (options.gltf?.loadImages) {\n        decodePropertyTextures(scenegraph, extension);\n    }\n    decodePropertyTables(scenegraph, extension);\n}\n/**\n * Processes the data stored in the textures\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param extension - Top-level extension.\n */\nfunction decodePropertyTextures(scenegraph, extension) {\n    const propertyTextures = extension.propertyTextures;\n    const json = scenegraph.gltf.json;\n    if (propertyTextures && json.meshes) {\n        // Iterate through all meshes/primitives.\n        for (const mesh of json.meshes) {\n            for (const primitive of mesh.primitives) {\n                processPrimitivePropertyTextures(scenegraph, propertyTextures, primitive, extension);\n            }\n        }\n    }\n}\n/**\n * Processes the data stored in the property tables.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param extension - Top-level extension.\n */\nfunction decodePropertyTables(scenegraph, extension) {\n    const schema = extension.schema;\n    if (!schema) {\n        return;\n    }\n    const schemaClasses = schema.classes;\n    const propertyTables = extension.propertyTables;\n    if (schemaClasses && propertyTables) {\n        for (const schemaName in schemaClasses) {\n            const propertyTable = findPropertyTableByClass(propertyTables, schemaName);\n            if (propertyTable) {\n                processPropertyTable(scenegraph, schema, propertyTable);\n            }\n        }\n    }\n}\n/**\n * Finds the property table by class name.\n * @param propertyTables - propertyTable definition taken from the top-level extension.\n * @param schemaClassName - class name in the extension schema.\n */\nfunction findPropertyTableByClass(propertyTables, schemaClassName) {\n    for (const propertyTable of propertyTables) {\n        if (propertyTable.class === schemaClassName) {\n            return propertyTable;\n        }\n    }\n    return null;\n}\n/**\n * Takes data from property textures reffered by the primitive.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param propertyTextures - propertyTexture definition taken from the top-level extention.\n * @param primitive - Primitive object.\n * @param extension - Top-level extension.\n */\nfunction processPrimitivePropertyTextures(scenegraph, propertyTextures, primitive, extension) {\n    if (!propertyTextures) {\n        return;\n    }\n    const primitiveExtension = primitive.extensions?.[EXT_STRUCTURAL_METADATA_NAME];\n    const primitivePropertyTextureIndices = primitiveExtension?.propertyTextures;\n    if (!primitivePropertyTextureIndices) {\n        return;\n    }\n    for (const primitivePropertyTextureIndex of primitivePropertyTextureIndices) {\n        const propertyTexture = propertyTextures[primitivePropertyTextureIndex];\n        processPrimitivePropertyTexture(scenegraph, propertyTexture, primitive, extension);\n    }\n}\n/**\n * Takes property data from the texture pointed by the primitive and appends them to `exension.data`.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param propertyTexture - propertyTexture definition taken from the top-level extension.\n * @param primitive - Primitive object.\n * @param extension - Top-level extension.\n */\nfunction processPrimitivePropertyTexture(scenegraph, propertyTexture, primitive, extension) {\n    if (!propertyTexture.properties) {\n        return;\n    }\n    if (!extension.dataAttributeNames) {\n        extension.dataAttributeNames = [];\n    }\n    /* Iterate through all properties defined in propertyTexture, e.g. \"speed\" and \"direction\":\n      {\n        \"class\": \"wind\",\n        \"properties\": {\n          \"speed\": {\n            \"index\": 0,\n            \"texCoord\": 0,\n            \"channels\": [0]\n          },\n          \"direction\": {\n            \"index\": 0,\n            \"texCoord\": 0,\n            \"channels\": [1, 2]\n          }\n        }\n      }\n    */\n    const className = propertyTexture.class;\n    for (const propertyName in propertyTexture.properties) {\n        // propertyName has values like \"speed\", \"direction\"\n        // Make attributeName as a combination of the class name and the propertyName like \"wind_speed\" or \"wind_direction\"\n        const attributeName = `${className}_${propertyName}`;\n        const textureInfoTopLevel = propertyTexture.properties?.[propertyName];\n        if (!textureInfoTopLevel) {\n            // eslint-disable-next-line no-continue\n            continue;\n        }\n        // The data taken from all meshes/primitives (the same property, e.g. \"speed\" or \"direction\") will be combined into one array and saved in textureInfoTopLevel.data\n        // Initially textureInfoTopLevel.data will be initialized with an empty array.\n        if (!textureInfoTopLevel.data) {\n            textureInfoTopLevel.data = [];\n        }\n        const featureTextureTable = textureInfoTopLevel.data;\n        const propertyData = getPrimitiveTextureData(scenegraph, textureInfoTopLevel, primitive);\n        if (propertyData === null) {\n            // eslint-disable-next-line no-continue\n            continue;\n        }\n        primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTextureTable, primitive);\n        textureInfoTopLevel.data = featureTextureTable;\n        extension.dataAttributeNames.push(attributeName);\n    }\n}\n/**\n * Navigates through all properies in the property table, gets properties data,\n * and put the data to `propertyTable.data` as an array.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param schema - schema object.\n * @param propertyTable - propertyTable definition taken from the top-level extension.\n */\nfunction processPropertyTable(scenegraph, schema, propertyTable) {\n    const schemaClass = schema.classes?.[propertyTable.class];\n    if (!schemaClass) {\n        throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${propertyTable.class}`);\n    }\n    const numberOfElements = propertyTable.count; // `propertyTable.count` is a number of elements in each property array.\n    for (const propertyName in schemaClass.properties) {\n        const classProperty = schemaClass.properties[propertyName];\n        const propertyTableProperty = propertyTable.properties?.[propertyName];\n        if (propertyTableProperty) {\n            // Getting all elements (`numberOfElements`) of the array in the `propertyTableProperty`\n            const data = getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty);\n            propertyTableProperty.data = data;\n        }\n    }\n}\n/**\n * Decodes a propertyTable column from binary source based on property type.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param schema - Schema object.\n * @param classProperty - class property object.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param propertyTableProperty - propertyTable's property metadata.\n * @returns {string[] | number[] | string[][] | number[][]}\n */\nfunction getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty) {\n    let data = [];\n    const valuesBufferView = propertyTableProperty.values;\n    const valuesDataBytes = scenegraph.getTypedArrayForBufferView(valuesBufferView);\n    const arrayOffsets = getArrayOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements);\n    const stringOffsets = getStringOffsetsForProperty(scenegraph, propertyTableProperty, numberOfElements);\n    switch (classProperty.type) {\n        case 'SCALAR':\n        case 'VEC2':\n        case 'VEC3':\n        case 'VEC4':\n        case 'MAT2':\n        case 'MAT3':\n        case 'MAT4': {\n            data = getPropertyDataNumeric(classProperty, numberOfElements, valuesDataBytes, arrayOffsets);\n            break;\n        }\n        case 'BOOLEAN': {\n            // TODO: implement it as soon as we have the corresponding tileset\n            throw new Error(`Not implemented - classProperty.type=${classProperty.type}`);\n        }\n        case 'STRING': {\n            data = getPropertyDataString(numberOfElements, valuesDataBytes, arrayOffsets, stringOffsets);\n            break;\n        }\n        case 'ENUM': {\n            data = getPropertyDataENUM(schema, classProperty, numberOfElements, valuesDataBytes, arrayOffsets);\n            break;\n        }\n        default:\n            throw new Error(`Unknown classProperty type ${classProperty.type}`);\n    }\n    return data;\n}\n/**\n * Parses propertyTable.property.arrayOffsets that are offsets of sub-arrays in a flatten array of values.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param classProperty - class property object.\n * @param propertyTableProperty - propertyTable's property metadata.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @returns Typed array with offset values.\n * @see https://github.com/CesiumGS/glTF/blob/2976f1183343a47a29e4059a70961371cd2fcee8/extensions/2.0/Vendor/EXT_structural_metadata/schema/propertyTable.property.schema.json#L21\n */\nfunction getArrayOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements) {\n    if (classProperty.array &&\n        // `count` is a number of array elements. May only be defined when `array` is true.\n        // If `count` is NOT defined, it's a VARIABLE-length array\n        typeof classProperty.count === 'undefined' &&\n        // `arrayOffsets` is an index of the buffer view containing offsets for variable-length arrays.\n        typeof propertyTableProperty.arrayOffsets !== 'undefined') {\n        // Data are in a VARIABLE-length array\n        return getOffsetsForProperty(scenegraph, propertyTableProperty.arrayOffsets, propertyTableProperty.arrayOffsetType || 'UINT32', numberOfElements);\n    }\n    return null;\n}\n/**\n * Parses propertyTable.property.stringOffsets.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param propertyTableProperty - propertyTable's property metadata.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @returns Typed array with offset values.\n * @see https://github.com/CesiumGS/glTF/blob/2976f1183343a47a29e4059a70961371cd2fcee8/extensions/2.0/Vendor/EXT_structural_metadata/schema/propertyTable.property.schema.json#L29C10-L29C23\n */\nfunction getStringOffsetsForProperty(scenegraph, propertyTableProperty, numberOfElements) {\n    if (typeof propertyTableProperty.stringOffsets !== 'undefined' // `stringOffsets` is an index of the buffer view containing offsets for strings.\n    ) {\n        // Data are in a FIXED-length array\n        return getOffsetsForProperty(scenegraph, propertyTableProperty.stringOffsets, propertyTableProperty.stringOffsetType || 'UINT32', numberOfElements);\n    }\n    return null;\n}\n/**\n * Decodes properties of SCALAR, VEC-N, MAT-N types from binary sourse.\n * @param classProperty - class property object.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param valuesDataBytes - Data taken from values property of the property table property.\n * @param arrayOffsets - Offsets for variable-length arrays. It's null for fixed-length arrays or scalar types.\n * @returns Property values in a typed array or in an array of typed arrays.\n */\nfunction getPropertyDataNumeric(classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {\n    const isArray = classProperty.array;\n    const arrayCount = classProperty.count;\n    const elementSize = getArrayElementByteSize(classProperty.type, classProperty.componentType);\n    const elementCount = valuesDataBytes.byteLength / elementSize;\n    let valuesData;\n    if (classProperty.componentType) {\n        valuesData = convertRawBufferToMetadataArray(valuesDataBytes, classProperty.type, \n        // The datatype of the element's components. Only applicable to `SCALAR`, `VECN`, and `MATN` types.\n        classProperty.componentType, elementCount);\n    }\n    else {\n        // The spec doesn't provide any info what to do if componentType is not set.\n        valuesData = valuesDataBytes;\n    }\n    if (isArray) {\n        if (arrayOffsets) {\n            // VARIABLE-length array\n            return parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytes.length, elementSize);\n        }\n        if (arrayCount) {\n            // FIXED-length array\n            return parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount);\n        }\n        return [];\n    }\n    return valuesData;\n}\n/**\n * Decodes properties of enum type from binary source.\n * @param schema - Schema object.\n * @param classProperty - Class property object.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param valuesDataBytes - Data taken from values property of the property table property.\n * @param arrayOffsets - Offsets for variable-length arrays. It's null for fixed-length arrays or scalar types.\n * @returns Strings array of nested strings array.\n */\nfunction getPropertyDataENUM(schema, classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {\n    const enumType = classProperty.enumType;\n    // Enum ID as declared in the `enums` dictionary. Required when `type` is `ENUM`.\n    if (!enumType) {\n        throw new Error('Incorrect data in the EXT_structural_metadata extension: classProperty.enumType is not set for type ENUM');\n    }\n    const enumEntry = schema.enums?.[enumType];\n    if (!enumEntry) {\n        throw new Error(`Incorrect data in the EXT_structural_metadata extension: schema.enums does't contain ${enumType}`);\n    }\n    const enumValueType = enumEntry.valueType || 'UINT16';\n    const elementSize = getArrayElementByteSize(classProperty.type, enumValueType);\n    const elementCount = valuesDataBytes.byteLength / elementSize;\n    let valuesData = convertRawBufferToMetadataArray(valuesDataBytes, classProperty.type, enumValueType, elementCount);\n    if (!valuesData) {\n        valuesData = valuesDataBytes;\n    }\n    if (classProperty.array) {\n        if (arrayOffsets) {\n            // VARIABLE-length array\n            return parseVariableLengthArrayENUM({\n                valuesData,\n                numberOfElements,\n                arrayOffsets,\n                valuesDataBytesLength: valuesDataBytes.length,\n                elementSize,\n                enumEntry\n            });\n        }\n        const arrayCount = classProperty.count;\n        if (arrayCount) {\n            // FIXED-length array\n            return parseFixedLengthArrayENUM(valuesData, numberOfElements, arrayCount, enumEntry);\n        }\n        return [];\n    }\n    // Single value (not an array)\n    return getEnumsArray(valuesData, 0, numberOfElements, enumEntry);\n}\n/**\n * Parses variable length nested ENUM arrays.\n * @param params.valuesData - Values in a flat typed array.\n * @param params.numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param params.arrayOffsets - Offsets for variable-length arrays. It's null for fixed-length arrays or scalar types.\n * @param params.valuesDataBytesLength - Byte length of values array.\n * @param params.elementSize - Single element byte size.\n * @param params.enumEntry - Enums dictionary.\n * @returns Nested strings array.\n */\nfunction parseVariableLengthArrayENUM(params) {\n    const { valuesData, numberOfElements, arrayOffsets, valuesDataBytesLength, elementSize, enumEntry } = params;\n    const attributeValueArray = [];\n    for (let index = 0; index < numberOfElements; index++) {\n        const arrayOffset = arrayOffsets[index];\n        const arrayByteSize = arrayOffsets[index + 1] - arrayOffsets[index];\n        if (arrayByteSize + arrayOffset > valuesDataBytesLength) {\n            break;\n        }\n        const typedArrayOffset = arrayOffset / elementSize;\n        const elementCount = arrayByteSize / elementSize;\n        const array = getEnumsArray(valuesData, typedArrayOffset, elementCount, enumEntry);\n        attributeValueArray.push(array);\n    }\n    return attributeValueArray;\n}\n/**\n * Parses fixed length ENUM arrays.\n * @param valuesData - Values in a flat typed array.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param arrayCount - Nested arrays length.\n * @param enumEntry - Enums dictionary.\n * @returns Nested strings array.\n */\nfunction parseFixedLengthArrayENUM(valuesData, numberOfElements, arrayCount, enumEntry) {\n    const attributeValueArray = [];\n    for (let index = 0; index < numberOfElements; index++) {\n        const elementOffset = arrayCount * index;\n        const array = getEnumsArray(valuesData, elementOffset, arrayCount, enumEntry);\n        attributeValueArray.push(array);\n    }\n    return attributeValueArray;\n}\n/**\n * Parses ENUM values into a string array.\n * @param valuesData - Values in a flat typed array.\n * @param offset - Offset to start parse from.\n * @param count - Values length to parse.\n * @param enumEntry - Enums dictionary.\n * @returns Array of strings with parsed ENUM names.\n */\nfunction getEnumsArray(valuesData, offset, count, enumEntry) {\n    const array = [];\n    for (let i = 0; i < count; i++) {\n        // At the moment we don't support BigInt. It requires additional calculations logic\n        // and might be an issue in Safari\n        if (valuesData instanceof BigInt64Array || valuesData instanceof BigUint64Array) {\n            array.push('');\n        }\n        else {\n            const value = valuesData[offset + i];\n            const enumObject = getEnumByValue(enumEntry, value);\n            if (enumObject) {\n                array.push(enumObject.name);\n            }\n            else {\n                array.push('');\n            }\n        }\n    }\n    return array;\n}\n/**\n * Looks up ENUM whose `value` property matches the specified number in the parameter `value`.\n * @param {GLTF_EXT_structural_metadata_Enum} enumEntry - ENUM entry containing the array of possible enums.\n * @param {number} value - The value of the ENUM to locate.\n * @returns {GLTF_EXT_structural_metadata_EnumValue | null} ENUM matcihng the specified value or null of no ENUM object was found.\n */\nfunction getEnumByValue(enumEntry, value) {\n    for (const enumValue of enumEntry.values) {\n        if (enumValue.value === value) {\n            return enumValue;\n        }\n    }\n    return null;\n}\nconst SCHEMA_CLASS_ID_DEFAULT = 'schemaClassId';\nfunction encodeExtStructuralMetadata(scenegraph, options) {\n    const extension = scenegraph.getExtension(EXT_STRUCTURAL_METADATA_NAME);\n    if (!extension) {\n        return;\n    }\n    if (extension.propertyTables) {\n        for (const table of extension.propertyTables) {\n            const classId = table.class;\n            const schemaClass = extension.schema?.classes?.[classId];\n            if (table.properties && schemaClass) {\n                encodeProperties(table, schemaClass, scenegraph);\n            }\n        }\n    }\n}\nfunction encodeProperties(table, schemaClass, scenegraph) {\n    for (const propertyName in table.properties) {\n        const data = table.properties[propertyName].data;\n        if (data) {\n            const classProperty = schemaClass.properties[propertyName];\n            if (classProperty) {\n                const tableProperty = createPropertyTableProperty(data, classProperty, scenegraph);\n                // Override table property that came with \"data\"\n                table.properties[propertyName] = tableProperty;\n            }\n        }\n    }\n}\n/**\n * Creates ExtStructuralMetadata, creates the schema and creates a property table containing feature data provided.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param propertyAttributes - property attributes\n * @param classId - classId to use for encoding metadata.\n * @returns Index of the table created.\n */\nexport function createExtStructuralMetadata(scenegraph, propertyAttributes, classId = SCHEMA_CLASS_ID_DEFAULT) {\n    let extension = scenegraph.getExtension(EXT_STRUCTURAL_METADATA_NAME);\n    if (!extension) {\n        extension = scenegraph.addExtension(EXT_STRUCTURAL_METADATA_NAME);\n    }\n    extension.schema = createSchema(propertyAttributes, classId, extension.schema);\n    const table = createPropertyTable(propertyAttributes, classId, extension.schema);\n    if (!extension.propertyTables) {\n        extension.propertyTables = [];\n    }\n    return extension.propertyTables.push(table) - 1; // index of the table\n}\nfunction createSchema(propertyAttributes, classId, schemaToUpdate) {\n    const schema = schemaToUpdate ?? {\n        id: 'schema_id'\n    };\n    const schemaClass = {\n        properties: {}\n    };\n    for (const attribute of propertyAttributes) {\n        const classProperty = {\n            type: attribute.elementType,\n            componentType: attribute.componentType\n        };\n        schemaClass.properties[attribute.name] = classProperty;\n    }\n    schema.classes = {};\n    schema.classes[classId] = schemaClass;\n    return schema;\n}\nfunction createPropertyTable(propertyAttributes, classId, schema) {\n    const table = {\n        class: classId,\n        count: 0\n    };\n    // count is a number of rows in the table\n    let count = 0;\n    const schemaClass = schema.classes?.[classId];\n    for (const attribute of propertyAttributes) {\n        if (count === 0) {\n            count = attribute.values.length;\n        }\n        // The number of elements in all propertyAttributes must be the same\n        if (count !== attribute.values.length && attribute.values.length) {\n            throw new Error('Illegal values in attributes');\n        }\n        const classProperty = schemaClass?.properties[attribute.name];\n        if (classProperty) {\n            // const tableProperty = createPropertyTableProperty(attribute, classProperty, scenegraph);\n            if (!table.properties) {\n                table.properties = {};\n            }\n            // values is a required field. Its real value will be set while encoding data\n            table.properties[attribute.name] = { values: 0, data: attribute.values };\n        }\n    }\n    table.count = count;\n    return table;\n}\nfunction createPropertyTableProperty(\n// attribute: PropertyAttribute,\nvalues, classProperty, scenegraph) {\n    const prop = { values: 0 };\n    if (classProperty.type === 'STRING') {\n        const { stringData, stringOffsets } = createPropertyDataString(values);\n        prop.stringOffsets = createBufferView(stringOffsets, scenegraph);\n        prop.values = createBufferView(stringData, scenegraph);\n    }\n    else if (classProperty.type === 'SCALAR' && classProperty.componentType) {\n        const data = createPropertyDataScalar(values, classProperty.componentType);\n        prop.values = createBufferView(data, scenegraph);\n    }\n    return prop;\n}\nconst COMPONENT_TYPE_TO_ARRAY_CONSTRUCTOR = {\n    INT8: Int8Array,\n    UINT8: Uint8Array,\n    INT16: Int16Array,\n    UINT16: Uint16Array,\n    INT32: Int32Array,\n    UINT32: Uint32Array,\n    INT64: Int32Array,\n    UINT64: Uint32Array,\n    FLOAT32: Float32Array,\n    FLOAT64: Float64Array\n};\nfunction createPropertyDataScalar(array, componentType) {\n    const numberArray = [];\n    for (const value of array) {\n        numberArray.push(Number(value));\n    }\n    const Construct = COMPONENT_TYPE_TO_ARRAY_CONSTRUCTOR[componentType];\n    if (!Construct) {\n        throw new Error('Illegal component type');\n    }\n    return new Construct(numberArray);\n}\nfunction createPropertyDataString(strings) {\n    const utf8Encode = new TextEncoder();\n    const arr = [];\n    let len = 0;\n    for (const str of strings) {\n        const uint8Array = utf8Encode.encode(str);\n        len += uint8Array.length;\n        arr.push(uint8Array);\n    }\n    const strArray = new Uint8Array(len);\n    const strOffsets = [];\n    let offset = 0;\n    for (const str of arr) {\n        strArray.set(str, offset);\n        strOffsets.push(offset);\n        offset += str.length;\n    }\n    strOffsets.push(offset); // The last offset represents the byte offset after the last string.\n    const stringOffsetsTypedArray = new Uint32Array(strOffsets); // Its length = len+1\n    return { stringData: strArray, stringOffsets: stringOffsetsTypedArray };\n}\nfunction createBufferView(typedArray, scenegraph) {\n    scenegraph.gltf.buffers.push({\n        arrayBuffer: typedArray.buffer,\n        byteOffset: typedArray.byteOffset,\n        byteLength: typedArray.byteLength\n    });\n    return scenegraph.addBufferView(typedArray);\n}\n", "import { GLTFScenegraph } from \"../../api/gltf-scenegraph.js\";\nimport { convertRawBufferToMetadataArray, getPrimitiveTextureData, primitivePropertyDataToAttributes, getArrayElementByteSize, getOffsetsForProperty, parseVariableLengthArrayNumeric, parseFixedLengthArrayNumeric, getPropertyDataString } from \"../utils/3d-tiles-utils.js\";\n/** Extension name */\nconst EXT_FEATURE_METADATA_NAME = 'EXT_feature_metadata';\nexport const name = EXT_FEATURE_METADATA_NAME;\nexport async function decode(gltfData, options) {\n    const scenegraph = new GLTFScenegraph(gltfData);\n    decodeExtFeatureMetadata(scenegraph, options);\n}\n/**\n * Decodes feature metadata from extension.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param options - GLTFLoader options.\n */\nfunction decodeExtFeatureMetadata(scenegraph, options) {\n    // Decoding metadata involves buffers processing.\n    // So, if buffers have not been loaded, there is no reason to process metadata.\n    if (!options.gltf?.loadBuffers) {\n        return;\n    }\n    const extension = scenegraph.getExtension(EXT_FEATURE_METADATA_NAME);\n    if (!extension) {\n        return;\n    }\n    if (options.gltf?.loadImages) {\n        decodePropertyTextures(scenegraph, extension);\n    }\n    decodePropertyTables(scenegraph, extension);\n}\n/**\n * Processes the data stored in the textures\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param extension - Top-level extension.\n */\nfunction decodePropertyTextures(scenegraph, extension) {\n    const schema = extension.schema;\n    if (!schema) {\n        return;\n    }\n    const schemaClasses = schema.classes;\n    const { featureTextures } = extension;\n    if (schemaClasses && featureTextures) {\n        for (const schemaName in schemaClasses) {\n            const schemaClass = schemaClasses[schemaName];\n            const featureTexture = findFeatureTextureByClass(featureTextures, schemaName);\n            if (featureTexture) {\n                handleFeatureTextureProperties(scenegraph, featureTexture, schemaClass);\n            }\n        }\n    }\n}\n/**\n * Processes the data stored in the property tables.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param extension - Top-level extension.\n */\nfunction decodePropertyTables(scenegraph, extension) {\n    const schema = extension.schema;\n    if (!schema) {\n        return;\n    }\n    const schemaClasses = schema.classes;\n    const propertyTables = extension.featureTables;\n    if (schemaClasses && propertyTables) {\n        for (const schemaName in schemaClasses) {\n            const propertyTable = findPropertyTableByClass(propertyTables, schemaName);\n            if (propertyTable) {\n                processPropertyTable(scenegraph, schema, propertyTable);\n            }\n        }\n    }\n}\n/**\n * Finds the property table by class name.\n * @param propertyTables - propertyTable definition taken from the top-level extension.\n * @param schemaClassName - class name in the extension schema.\n */\nfunction findPropertyTableByClass(propertyTables, schemaClassName) {\n    for (const propertyTableName in propertyTables) {\n        const propertyTable = propertyTables[propertyTableName];\n        if (propertyTable.class === schemaClassName) {\n            return propertyTable;\n        }\n    }\n    return null;\n}\nfunction findFeatureTextureByClass(featureTextures, schemaClassName) {\n    for (const featureTexturesName in featureTextures) {\n        const featureTable = featureTextures[featureTexturesName];\n        if (featureTable.class === schemaClassName) {\n            return featureTable;\n        }\n    }\n    return null;\n}\n/**\n * Navigates through all properies in the property table, gets properties data,\n * and put the data to `propertyTable.data` as an array.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param schema - schema object.\n * @param propertyTable - propertyTable definition taken from the top-level extension.\n */\nfunction processPropertyTable(scenegraph, schema, propertyTable) {\n    // Though 'class' is not required by spec, it doesn't make any scence when it's not provided.\n    // So, bale out here.\n    if (!propertyTable.class) {\n        return;\n    }\n    const schemaClass = schema.classes?.[propertyTable.class];\n    if (!schemaClass) {\n        throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${propertyTable.class}`);\n    }\n    const numberOfElements = propertyTable.count; // `propertyTable.count` is a number of elements in each property array.\n    for (const propertyName in schemaClass.properties) {\n        const classProperty = schemaClass.properties[propertyName];\n        const propertyTableProperty = propertyTable.properties?.[propertyName];\n        if (propertyTableProperty) {\n            // Getting all elements (`numberOfElements`) of the array in the `propertyTableProperty`\n            const data = getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty);\n            propertyTableProperty.data = data;\n        }\n    }\n}\n/**\n * Navigates through all properies in feature texture and gets properties data.\n * Data will be stored in featureTexture.properties[propertyName].data.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param featureTexture\n * @param schemaClass\n */\nfunction handleFeatureTextureProperties(scenegraph, featureTexture, schemaClass) {\n    const attributeName = featureTexture.class;\n    for (const propertyName in schemaClass.properties) {\n        const featureTextureProperty = featureTexture?.properties?.[propertyName];\n        if (featureTextureProperty) {\n            const data = getPropertyDataFromTexture(scenegraph, featureTextureProperty, attributeName);\n            featureTextureProperty.data = data;\n        }\n    }\n}\n/**\n * Decodes properties from binary sourse based on property type.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param schemaProperty\n * @param numberOfFeatures\n * @param featureTableProperty\n */\nfunction getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfFeatures, featureTableProperty) {\n    let data = [];\n    const bufferView = featureTableProperty.bufferView;\n    const dataArray = scenegraph.getTypedArrayForBufferView(bufferView);\n    const arrayOffsets = getArrayOffsetsForProperty(scenegraph, classProperty, featureTableProperty, numberOfFeatures);\n    const stringOffsets = getStringOffsetsForProperty(scenegraph, classProperty, featureTableProperty, numberOfFeatures);\n    if (classProperty.type === 'STRING' || classProperty.componentType === 'STRING') {\n        data = getPropertyDataString(numberOfFeatures, dataArray, arrayOffsets, stringOffsets);\n    }\n    else if (isNumericProperty(classProperty)) {\n        data = getPropertyDataNumeric(classProperty, numberOfFeatures, dataArray, arrayOffsets);\n    }\n    return data;\n}\n/**\n * Parses propertyTable.property.arrayOffsets that are offsets of sub-arrays in a flatten array of values.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param classProperty - class property object.\n * @param propertyTableProperty - propertyTable's property metadata.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @returns Typed array with offset values.\n * @see https://github.com/CesiumGS/glTF/blob/2976f1183343a47a29e4059a70961371cd2fcee8/extensions/2.0/Vendor/EXT_structural_metadata/schema/propertyTable.property.schema.json#L21\n */\nfunction getArrayOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements) {\n    /*\n     If ARRAY is used, then componentType must also be specified.\n     ARRAY is a fixed-length array when componentCount is defined, and variable-length otherwise.\n  */\n    if (classProperty.type === 'ARRAY' &&\n        // `componentCount` is a number of fixed-length array elements.\n        // If `componentCount` is NOT defined, it's a VARIABLE-length array\n        typeof classProperty.componentCount === 'undefined' &&\n        // `arrayOffsetBufferView` is an index of the buffer view containing offsets for variable-length arrays.\n        typeof propertyTableProperty.arrayOffsetBufferView !== 'undefined') {\n        // Data are in a VARIABLE-length array\n        return getOffsetsForProperty(scenegraph, propertyTableProperty.arrayOffsetBufferView, propertyTableProperty.offsetType || 'UINT32', // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView\n        numberOfElements);\n    }\n    return null;\n}\n/**\n * Parses featureTable.property.stringOffsetBufferView.\n * String offsets is an array of offsets of strings in the united array of characters.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param propertyTableProperty - propertyTable's property metadata.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @returns Typed array of offset values. The number of offsets in the array is equal to `numberOfElements` plus one.\n * @see https://github.com/CesiumGS/glTF/blob/c38f7f37e894004353c15cd0481bc5b7381ce841/extensions/2.0/Vendor/EXT_feature_metadata/schema/featureTable.property.schema.json#L50C10-L50C32\n */\nfunction getStringOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements) {\n    if (typeof propertyTableProperty.stringOffsetBufferView !== 'undefined' // `stringOffsetBufferView` is an index of the buffer view containing offsets for strings.\n    ) {\n        // Data are in a FIXED-length array\n        return getOffsetsForProperty(scenegraph, propertyTableProperty.stringOffsetBufferView, propertyTableProperty.offsetType || 'UINT32', // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView\n        numberOfElements);\n    }\n    return null;\n}\n/**\n * Checks if the feature table property is of numeric type.\n * @param schemaPropertyType - feature table property\n * @returns true if property is numeric, else - false\n */\nfunction isNumericProperty(schemaProperty) {\n    const types = [\n        'UINT8',\n        'INT16',\n        'UINT16',\n        'INT32',\n        'UINT32',\n        'INT64',\n        'UINT64',\n        'FLOAT32',\n        'FLOAT64'\n    ];\n    return (types.includes(schemaProperty.type) ||\n        (typeof schemaProperty.componentType !== 'undefined' &&\n            types.includes(schemaProperty.componentType)));\n}\n/**\n * Decodes properties of numeric types from binary sourse.\n * @param classProperty - class property object.\n * @param numberOfElements - The number of elements in each property array that propertyTableProperty contains. It's a number of rows in the table.\n * @param valuesDataBytes - Data taken from values property of the property table property.\n * @param arrayOffsets - Offsets for variable-length arrays. It's null for fixed-length arrays or scalar types.\n * @returns Property values in a typed array or in an array of typed arrays.\n */\nfunction getPropertyDataNumeric(classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {\n    const isArray = classProperty.type === 'ARRAY';\n    const arrayCount = classProperty.componentCount;\n    /*\n    We are getting Numeric data. So,\n      the component type can be one of NumericComponentType,\n      the attribute type should be 'SCALAR'\n    */\n    const attributeType = 'SCALAR';\n    const componentType = classProperty.componentType || classProperty.type;\n    const elementSize = getArrayElementByteSize(attributeType, componentType);\n    const elementCount = valuesDataBytes.byteLength / elementSize;\n    const valuesData = convertRawBufferToMetadataArray(valuesDataBytes, attributeType, componentType, elementCount);\n    if (isArray) {\n        if (arrayOffsets) {\n            // VARIABLE-length array\n            return parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytes.length, elementSize);\n        }\n        if (arrayCount) {\n            // FIXED-length array\n            return parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount);\n        }\n        return [];\n    }\n    return valuesData;\n}\n/**\n * Gets properties from texture associated with all mesh primitives.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param featureTextureProperty\n * @param attributeName\n * @returns Feature texture data\n */\nfunction getPropertyDataFromTexture(scenegraph, featureTextureProperty, attributeName) {\n    const json = scenegraph.gltf.json;\n    if (!json.meshes) {\n        return [];\n    }\n    const featureTextureTable = [];\n    for (const mesh of json.meshes) {\n        for (const primitive of mesh.primitives) {\n            processPrimitiveTextures(scenegraph, attributeName, featureTextureProperty, featureTextureTable, primitive);\n        }\n    }\n    return featureTextureTable;\n}\n/**\n * Processes data encoded in the texture associated with the primitive. This data will be accessible through the attributes.\n * @param scenegraph - Instance of the class for structured access to GLTF data.\n * @param attributeName\n * @param featureTextureProperty\n * @param featureTextureTable\n * @param primitive\n */\nfunction processPrimitiveTextures(scenegraph, attributeName, featureTextureProperty, featureTextureTable, primitive) {\n    const textureInfoTopLevel = {\n        channels: featureTextureProperty.channels,\n        ...featureTextureProperty.texture\n    };\n    const propertyData = getPrimitiveTextureData(scenegraph, textureInfoTopLevel, primitive);\n    if (!propertyData) {\n        return;\n    }\n    primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTextureTable, primitive);\n}\n", "// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof \"4.3.3\" !== 'undefined' ? \"4.3.3\" : 'latest';\n", "import { padToNBytes, assert } from '@loaders.gl/loader-utils';\n/** Binary GLTF is little endian. */\nconst LITTLE_ENDIAN = true;\n/** 'glTF' in Big-Endian ASCII */\nconst MAGIC_glTF = 0x676c5446;\nconst GLB_FILE_HEADER_SIZE = 12;\nconst GLB_CHUNK_HEADER_SIZE = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\nconst GLB_V1_CONTENT_FORMAT_JSON = 0x0;\n/** @deprecated - Backward compatibility for old xviz files */\nconst GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0;\n/** @deprecated - Backward compatibility for old xviz files */\nconst GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1;\nfunction getMagicString(dataView, byteOffset = 0) {\n    return `\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 0))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 1))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 2))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;\n}\n/** Check if the contents of an array buffer contains GLB byte markers */\nexport function isGLB(arrayBuffer, byteOffset = 0, options = {}) {\n    const dataView = new DataView(arrayBuffer);\n    // Check that GLB Header starts with the magic number\n    const { magic = MAGIC_glTF } = options;\n    const magic1 = dataView.getUint32(byteOffset, false);\n    return magic1 === magic || magic1 === MAGIC_glTF;\n}\n/**\n * Synchronously parse a GLB\n * @param glb - Target, Output is stored there\n * @param arrayBuffer - Input data\n * @param byteOffset - Offset into arrayBuffer to start parsing from (for \"embedded\" GLBs, e.g. in 3D tiles)\n * @param options\n * @returns\n */\nexport function parseGLBSync(glb, arrayBuffer, byteOffset = 0, options = {}) {\n    // Check that GLB Header starts with the magic number\n    const dataView = new DataView(arrayBuffer);\n    // Compare format with GLBLoader documentation\n    const type = getMagicString(dataView, byteOffset + 0);\n    const version = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN); // Version 2 of binary glTF container format\n    const byteLength = dataView.getUint32(byteOffset + 8, LITTLE_ENDIAN); // Total byte length of binary file\n    Object.assign(glb, {\n        // Put less important stuff in a header, to avoid clutter\n        header: {\n            byteOffset, // Byte offset into the initial arrayBuffer\n            byteLength,\n            hasBinChunk: false\n        },\n        type,\n        version,\n        json: {},\n        binChunks: []\n    });\n    byteOffset += GLB_FILE_HEADER_SIZE;\n    switch (glb.version) {\n        case 1:\n            return parseGLBV1(glb, dataView, byteOffset);\n        case 2:\n            return parseGLBV2(glb, dataView, byteOffset, (options = {}));\n        default:\n            throw new Error(`Invalid GLB version ${glb.version}. Only supports version 1 and 2.`);\n    }\n}\n/**\n * Parse a V1 GLB\n * @param glb - target, output is stored in this object\n * @param dataView - Input, memory to be parsed\n * @param byteOffset - Offset of first byte of GLB data in the data view\n * @returns Number of bytes parsed (there could be additional non-GLB data after the GLB)\n */\nfunction parseGLBV1(glb, dataView, byteOffset) {\n    // Sanity: ensure file is big enough to hold at least the headers\n    assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n    // Explanation of GLB structure:\n    // https://cloud.githubusercontent.com/assets/3479527/22600725/36b87122-ea55-11e6-9d40-6fd42819fcab.png\n    const contentLength = dataView.getUint32(byteOffset + 0, LITTLE_ENDIAN); // Byte length of chunk\n    const contentFormat = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN); // Chunk format as uint32\n    byteOffset += GLB_CHUNK_HEADER_SIZE;\n    // GLB v1 only supports a single chunk type\n    assert(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);\n    parseJSONChunk(glb, dataView, byteOffset, contentLength);\n    // No need to call the function padToBytes() from parseJSONChunk()\n    byteOffset += contentLength;\n    byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);\n    return byteOffset;\n}\n/**\n * Parse a V2 GLB\n * @param glb - target, output is stored in this object\n * @param dataView - Input, memory to be parsed\n * @param byteOffset - Offset of first byte of GLB data in the data view\n * @returns Number of bytes parsed (there could be additional non-GLB data after the GLB)\n */\nfunction parseGLBV2(glb, dataView, byteOffset, options) {\n    // Sanity: ensure file is big enough to hold at least the first chunk header\n    assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n    parseGLBChunksSync(glb, dataView, byteOffset, options);\n    return byteOffset + glb.header.byteLength;\n}\n/** Iterate over GLB chunks and parse them */\nfunction parseGLBChunksSync(glb, dataView, byteOffset, options) {\n    // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n    // Iterate as long as there is space left for another chunk header\n    while (byteOffset + 8 <= glb.header.byteLength) {\n        const chunkLength = dataView.getUint32(byteOffset + 0, LITTLE_ENDIAN); // Byte length of chunk\n        const chunkFormat = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN); // Chunk format as uint32\n        byteOffset += GLB_CHUNK_HEADER_SIZE;\n        // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n        switch (chunkFormat) {\n            case GLB_CHUNK_TYPE_JSON:\n                parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n                break;\n            case GLB_CHUNK_TYPE_BIN:\n                parseBINChunk(glb, dataView, byteOffset, chunkLength);\n                break;\n            // Backward compatibility for very old xviz files\n            case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:\n                if (!options.strict) {\n                    parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n                }\n                break;\n            case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:\n                if (!options.strict) {\n                    parseBINChunk(glb, dataView, byteOffset, chunkLength);\n                }\n                break;\n            default:\n                // Ignore, per spec\n                // console.warn(`Unknown GLB chunk type`); // eslint-disable-line\n                break;\n        }\n        byteOffset += padToNBytes(chunkLength, 4);\n    }\n    return byteOffset;\n}\n/* Parse a GLB JSON chunk */\nfunction parseJSONChunk(glb, dataView, byteOffset, chunkLength) {\n    // 1. Create a \"view\" of the binary encoded JSON data inside the GLB\n    const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);\n    // 2. Decode the JSON binary array into clear text\n    const textDecoder = new TextDecoder('utf8');\n    const jsonText = textDecoder.decode(jsonChunk);\n    // 3. Parse the JSON text into a JavaScript data structure\n    glb.json = JSON.parse(jsonText);\n    return padToNBytes(chunkLength, 4);\n}\n/** Parse a GLB BIN chunk */\nfunction parseBINChunk(glb, dataView, byteOffset, chunkLength) {\n    // Note: BIN chunk can be optional\n    glb.header.hasBinChunk = true;\n    glb.binChunks.push({\n        byteOffset,\n        byteLength: chunkLength,\n        arrayBuffer: dataView.buffer\n        // TODO - copy, or create typed array view?\n    });\n    return padToNBytes(chunkLength, 4);\n}\n", "// Resolves a relative url against a baseUrl\n// If url is absolute, return it unchanged\nexport function resolveUrl(url, options) {\n    // TODO: Use better logic to handle all protocols plus not delay on data\n    const absolute = url.startsWith('data:') || url.startsWith('http:') || url.startsWith('https:');\n    if (absolute) {\n        return url;\n    }\n    const baseUrl = options.baseUri || options.uri;\n    if (!baseUrl) {\n        throw new Error(`'baseUri' must be provided to resolve relative url ${url}`);\n    }\n    return baseUrl.substr(0, baseUrl.lastIndexOf('/') + 1) + url;\n}\n", "import { GLTFScenegraph } from \"../api/gltf-scenegraph.js\";\nimport { meshoptDecodeGltfBuffer } from \"../../meshopt/meshopt-decoder.js\";\n// @ts-ignore\n// eslint-disable-next-line\nconst DEFAULT_MESHOPT_OPTIONS = {\n    byteOffset: 0,\n    filter: 'NONE'\n};\n/** Extension name */\nconst EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';\nexport const name = EXT_MESHOPT_COMPRESSION;\nexport async function decode(gltfData, options) {\n    const scenegraph = new GLTFScenegraph(gltfData);\n    if (!options?.gltf?.decompressMeshes || !options.gltf?.loadBuffers) {\n        return;\n    }\n    const promises = [];\n    for (const bufferViewIndex of gltfData.json.bufferViews || []) {\n        promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));\n    }\n    // Decompress meshes in parallel\n    await Promise.all(promises);\n    // We have now decompressed all primitives, so remove the top-level extension\n    scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);\n}\n/** Decode one meshopt buffer view */\nasync function decodeMeshoptBufferView(scenegraph, bufferView) {\n    const meshoptExtension = scenegraph.getObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);\n    if (meshoptExtension) {\n        const { byteOffset = 0, byteLength = 0, byteStride, count, mode, filter = 'NONE', buffer: bufferIndex } = meshoptExtension;\n        const buffer = scenegraph.gltf.buffers[bufferIndex];\n        const source = new Uint8Array(buffer.arrayBuffer, buffer.byteOffset + byteOffset, byteLength);\n        const result = new Uint8Array(scenegraph.gltf.buffers[bufferView.buffer].arrayBuffer, bufferView.byteOffset, bufferView.byteLength);\n        await meshoptDecodeGltfBuffer(result, count, byteStride, source, mode, filter);\n        scenegraph.removeObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);\n    }\n}\n", "// This file is part of meshoptimizer library and is distributed under the terms of MIT License.\n// Copyright (C) 2016-2021, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)\n/* eslint-disable camelcase */\nconst isWebAssemblySupported = typeof WebAssembly !== 'object';\n// Built with clang version 11.0.0 (https://github.com/llvm/llvm-project.git 0160ad802e899c2922bc9b29564080c22eb0908c)\n// Built from meshoptimizer 0.16\nconst wasm_base = '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';\nconst wasm_simd = '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';\n// Uses bulk-memory and simd extensions\nconst detector = new Uint8Array([\n    0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2,\n    12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11\n]);\n// Used to unpack wasm\nconst wasmpack = new Uint8Array([\n    32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113,\n    127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101,\n    130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167\n]);\nconst FILTERS = {\n    // legacy index-based enums for glTF\n    0: '',\n    1: 'meshopt_decodeFilterOct',\n    2: 'meshopt_decodeFilterQuat',\n    3: 'meshopt_decodeFilterExp',\n    // string-based enums for glTF\n    NONE: '',\n    OCTAHEDRAL: 'meshopt_decodeFilterOct',\n    QUATERNION: 'meshopt_decodeFilterQuat',\n    EXPONENTIAL: 'meshopt_decodeFilterExp'\n};\nconst DECODERS = {\n    // legacy index-based enums for glTF\n    0: 'meshopt_decodeVertexBuffer',\n    1: 'meshopt_decodeIndexBuffer',\n    2: 'meshopt_decodeIndexSequence',\n    // string-based enums for glTF\n    ATTRIBUTES: 'meshopt_decodeVertexBuffer',\n    TRIANGLES: 'meshopt_decodeIndexBuffer',\n    INDICES: 'meshopt_decodeIndexSequence'\n};\nexport function isMeshoptSupported() {\n    return isWebAssemblySupported;\n}\nexport async function meshoptDecodeVertexBuffer(target, count, size, source, filter = 'NONE') {\n    const instance = await loadWasmInstance();\n    decode(instance, instance.exports.meshopt_decodeVertexBuffer, target, count, size, source, instance.exports[FILTERS[filter]]);\n}\nexport async function meshoptDecodeIndexBuffer(target, count, size, source) {\n    const instance = await loadWasmInstance();\n    decode(instance, instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);\n}\nexport async function meshoptDecodeIndexSequence(target, count, size, source) {\n    const instance = await loadWasmInstance();\n    decode(instance, instance.exports.meshopt_decodeIndexSequence, target, count, size, source);\n}\n// eslint-disable-next-line max-params\nexport async function meshoptDecodeGltfBuffer(target, count, size, source, mode, filter = 'NONE') {\n    const instance = await loadWasmInstance();\n    decode(instance, instance.exports[DECODERS[mode]], target, count, size, source, instance.exports[FILTERS[filter || 'NONE']]);\n}\nlet wasmPromise;\nasync function loadWasmInstance() {\n    // eslint-disable-next-line\n    if (!wasmPromise) {\n        wasmPromise = loadWasmModule();\n    }\n    return wasmPromise;\n}\nasync function loadWasmModule() {\n    let wasm = wasm_base;\n    if (WebAssembly.validate(detector)) {\n        wasm = wasm_simd;\n        // eslint-disable-next-line no-console\n        console.log('Warning: meshopt_decoder is using experimental SIMD support');\n    }\n    const result = await WebAssembly.instantiate(unpack(wasm), {});\n    await result.instance.exports.__wasm_call_ctors();\n    return result.instance;\n}\nfunction unpack(data) {\n    const result = new Uint8Array(data.length);\n    for (let i = 0; i < data.length; ++i) {\n        const ch = data.charCodeAt(i);\n        result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;\n    }\n    let write = 0;\n    for (let i = 0; i < data.length; ++i) {\n        result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];\n    }\n    return result.buffer.slice(0, write);\n}\n// eslint-disable-next-line max-params\nfunction decode(instance, fun, target, count, size, source, filter) {\n    const sbrk = instance.exports.sbrk;\n    const count4 = (count + 3) & ~3; // pad for SIMD filter\n    const tp = sbrk(count4 * size);\n    const sp = sbrk(source.length);\n    const heap = new Uint8Array(instance.exports.memory.buffer);\n    heap.set(source, sp);\n    const res = fun(tp, count, size, sp, source.length);\n    if (res === 0 && filter) {\n        filter(tp, count4, size);\n    }\n    target.set(heap.subarray(tp, tp + count * size));\n    sbrk(tp - sbrk(0));\n    if (res !== 0) {\n        throw new Error(`Malformed buffer data: ${res}`);\n    }\n}\n", "// GLTF EXTENSION: EXT_TEXTURE_WEBP\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_TEXTURE_WEBP\n/* eslint-disable camelcase */\nimport { isImageFormatSupported } from '@loaders.gl/images';\nimport { GLTFScenegraph } from \"../api/gltf-scenegraph.js\";\nconst EXT_TEXTURE_WEBP = 'EXT_texture_webp';\n/** Extension name */\nexport const name = EXT_TEXTURE_WEBP;\n/**\n * Replaces a texture source reference with the extension texture\n * Done in preprocess() to prevent load of default image\n */\nexport function preprocess(gltfData, options) {\n    const scenegraph = new GLTFScenegraph(gltfData);\n    if (!isImageFormatSupported('image/webp')) {\n        if (scenegraph.getRequiredExtensions().includes(EXT_TEXTURE_WEBP)) {\n            throw new Error(`gltf: Required extension ${EXT_TEXTURE_WEBP} not supported by browser`);\n        }\n        return;\n    }\n    const { json } = scenegraph;\n    for (const texture of json.textures || []) {\n        const extension = scenegraph.getObjectExtension(texture, EXT_TEXTURE_WEBP);\n        if (extension) {\n            // TODO - if multiple texture extensions are present which one wins?\n            texture.source = extension.source;\n        }\n        scenegraph.removeObjectExtension(texture, EXT_TEXTURE_WEBP);\n    }\n    // Remove the top-level extension\n    scenegraph.removeExtension(EXT_TEXTURE_WEBP);\n}\n", "// GLTF EXTENSION: KHR_texture_basisu\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_basisu\n/* eslint-disable camelcase */\nimport { GLTFScenegraph } from \"../api/gltf-scenegraph.js\";\nconst KHR_TEXTURE_BASISU = 'KHR_texture_basisu';\n/** Extension name */\nexport const name = KHR_TEXTURE_BASISU;\n/**\n * Replaces a texture source reference with the extension texture\n * Done in preprocess() to prevent load of default image\n */\nexport function preprocess(gltfData, options) {\n    const scene = new GLTFScenegraph(gltfData);\n    const { json } = scene;\n    for (const texture of json.textures || []) {\n        const extension = scene.getObjectExtension(texture, KHR_TEXTURE_BASISU);\n        if (extension) {\n            // TODO - if multiple texture extensions are present which one wins?\n            texture.source = extension.source;\n            scene.removeObjectExtension(texture, KHR_TEXTURE_BASISU);\n        }\n    }\n    // Remove the top-level extension\n    scene.removeExtension(KHR_TEXTURE_BASISU);\n}\n", "// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\n/* eslint-disable camelcase */\nimport { sliceArrayBuffer, parseFromContext } from '@loaders.gl/loader-utils';\nimport { DracoLoader } from '@loaders.gl/draco';\nimport { GLTFScenegraph } from \"../api/gltf-scenegraph.js\";\nimport { getGLTFAccessors, getGLTFAccessor } from \"../gltf-utils/gltf-attribute-utils.js\";\nconst KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';\n/** Extension name */\nexport const name = KHR_DRACO_MESH_COMPRESSION;\nexport function preprocess(gltfData, options, context) {\n    const scenegraph = new GLTFScenegraph(gltfData);\n    for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n        if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n            // TODO - Remove fallback accessors to make sure we don't load unnecessary buffers\n        }\n    }\n}\nexport async function decode(gltfData, options, context) {\n    if (!options?.gltf?.decompressMeshes) {\n        return;\n    }\n    const scenegraph = new GLTFScenegraph(gltfData);\n    const promises = [];\n    for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n        if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n            promises.push(decompressPrimitive(scenegraph, primitive, options, context));\n        }\n    }\n    // Decompress meshes in parallel\n    await Promise.all(promises);\n    // We have now decompressed all primitives, so remove the top-level extension\n    scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n}\nexport function encode(gltfData, options = {}) {\n    const scenegraph = new GLTFScenegraph(gltfData);\n    for (const mesh of scenegraph.json.meshes || []) {\n        // eslint-disable-next-line camelcase\n        // @ts-ignore\n        compressMesh(mesh, options);\n        // NOTE: Only add the extension if something was actually compressed\n        scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n    }\n}\n// DECODE\n// Unpacks one mesh primitive and removes the extension from the primitive\n// DracoDecoder needs to be imported and registered by app\n// Returns: Promise that resolves when all pending draco decoder jobs for this mesh complete\n// TODO - Implement fallback behavior per KHR_DRACO_MESH_COMPRESSION spec\nasync function decompressPrimitive(scenegraph, primitive, options, context) {\n    const dracoExtension = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);\n    if (!dracoExtension) {\n        return;\n    }\n    const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);\n    // TODO - parse does not yet deal well with byte offsets embedded in typed arrays. Copy buffer\n    // TODO - remove when `parse` is fixed to handle `byteOffset`s\n    const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset); // , buffer.byteLength);\n    const dracoOptions = { ...options };\n    // TODO - remove hack: The entire tileset might be included, too expensive to serialize\n    delete dracoOptions['3d-tiles'];\n    const decodedData = await parseFromContext(bufferCopy, DracoLoader, dracoOptions, context);\n    const decodedAttributes = getGLTFAccessors(decodedData.attributes);\n    // Restore min/max values\n    for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {\n        if (attributeName in primitive.attributes) {\n            const accessorIndex = primitive.attributes[attributeName];\n            const accessor = scenegraph.getAccessor(accessorIndex);\n            if (accessor?.min && accessor?.max) {\n                decodedAttribute.min = accessor.min;\n                decodedAttribute.max = accessor.max;\n            }\n        }\n    }\n    // @ts-ignore\n    primitive.attributes = decodedAttributes;\n    if (decodedData.indices) {\n        // @ts-ignore\n        primitive.indices = getGLTFAccessor(decodedData.indices);\n    }\n    // Extension has been processed, delete it\n    scenegraph.removeObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);\n    checkPrimitive(primitive);\n}\n// ENCODE\n// eslint-disable-next-line max-len\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\nfunction compressMesh(attributes, indices, mode = 4, options, context) {\n    if (!options.DracoWriter) {\n        throw new Error('options.gltf.DracoWriter not provided');\n    }\n    // TODO - use DracoWriter using encode w/ registered DracoWriter...\n    const compressedData = options.DracoWriter.encodeSync({ attributes });\n    // Draco compression may change the order and number of vertices in a mesh.\n    // To satisfy the requirement that accessors properties be correct for both\n    // compressed and uncompressed data, generators should create uncompressed\n    // attributes and indices using data that has been decompressed from the Draco buffer,\n    // rather than the original source data.\n    // @ts-ignore TODO this needs to be fixed\n    const decodedData = context?.parseSync?.({ attributes });\n    const fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n    const bufferViewIndex = options.addBufferView(compressedData);\n    const glTFMesh = {\n        primitives: [\n            {\n                attributes: fauxAccessors, // TODO - verify with spec\n                mode, // GL.POINTS\n                extensions: {\n                    [KHR_DRACO_MESH_COMPRESSION]: {\n                        bufferView: bufferViewIndex,\n                        attributes: fauxAccessors // TODO - verify with spec\n                    }\n                }\n            }\n        ]\n    };\n    return glTFMesh;\n}\n// UTILS\nfunction checkPrimitive(primitive) {\n    if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {\n        throw new Error('glTF: Empty primitive detected: Draco decompression failure?');\n    }\n}\nfunction* makeMeshPrimitiveIterator(scenegraph) {\n    for (const mesh of scenegraph.json.meshes || []) {\n        for (const primitive of mesh.primitives) {\n            yield primitive;\n        }\n    }\n}\n", "// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof \"4.3.3\" !== 'undefined' ? \"4.3.3\" : 'latest';\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { VERSION } from \"./lib/utils/version.js\";\n/**\n * Worker loader for Draco3D compressed geometries\n */\nexport const DracoLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'Draco',\n    id: 'draco',\n    module: 'draco',\n    // shapes: ['mesh'],\n    version: VERSION,\n    worker: true,\n    extensions: ['drc'],\n    mimeTypes: ['application/octet-stream'],\n    binary: true,\n    tests: ['DRACO'],\n    options: {\n        draco: {\n            decoderType: typeof WebAssembly === 'object' ? 'wasm' : 'js', // 'js' for IE11\n            libraryPath: 'libs/',\n            extraAttributes: {},\n            attributeNameEntry: undefined\n        }\n    }\n};\n", "import { deduceMeshField } from '@loaders.gl/schema';\n/** Extract an arrow-like schema from a Draco mesh */\nexport function getDracoSchema(attributes, loaderData, indices) {\n    const metadata = makeMetadata(loaderData.metadata);\n    const fields = [];\n    const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);\n    for (const attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        const field = getArrowFieldFromAttribute(attributeName, attribute, namedLoaderDataAttributes[attributeName]);\n        fields.push(field);\n    }\n    if (indices) {\n        const indicesField = getArrowFieldFromAttribute('indices', indices);\n        fields.push(indicesField);\n    }\n    return { fields, metadata };\n}\nfunction transformAttributesLoaderData(loaderData) {\n    const result = {};\n    for (const key in loaderData) {\n        const dracoAttribute = loaderData[key];\n        result[dracoAttribute.name || 'undefined'] = dracoAttribute;\n    }\n    return result;\n}\nfunction getArrowFieldFromAttribute(attributeName, attribute, loaderData) {\n    const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : undefined;\n    const field = deduceMeshField(attributeName, attribute, metadataMap);\n    return field;\n}\nfunction makeMetadata(metadata) {\n    Object.entries(metadata);\n    const serializedMetadata = {};\n    for (const key in metadata) {\n        serializedMetadata[`${key}.string`] = JSON.stringify(metadata[key]);\n    }\n    return serializedMetadata;\n}\n", "/* eslint-disable camelcase */\nimport { getMeshBoundingBox } from '@loaders.gl/schema';\nimport { getDracoSchema } from \"./utils/get-draco-schema.js\";\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst GEOMETRY_TYPE = {\n    TRIANGULAR_MESH: 0,\n    POINT_CLOUD: 1\n};\n// Native Draco attribute names to GLTF attribute names.\nconst DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n    POSITION: 'POSITION',\n    NORMAL: 'NORMAL',\n    COLOR: 'COLOR_0',\n    TEX_COORD: 'TEXCOORD_0'\n};\nconst DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n    1: Int8Array,\n    2: Uint8Array,\n    3: Int16Array,\n    4: Uint16Array,\n    5: Int32Array,\n    6: Uint32Array,\n    // 7: BigInt64Array,\n    // 8: BigUint64Array,\n    9: Float32Array\n    // 10: Float64Array\n    // 11: BOOL - What array type do we use for this?\n};\nconst INDEX_ITEM_SIZE = 4;\nexport default class DracoParser {\n    draco;\n    decoder;\n    metadataQuerier;\n    // draco - the draco decoder, either import `draco3d` or load dynamically\n    constructor(draco) {\n        this.draco = draco;\n        this.decoder = new this.draco.Decoder();\n        this.metadataQuerier = new this.draco.MetadataQuerier();\n    }\n    /**\n     * Destroy draco resources\n     */\n    destroy() {\n        this.draco.destroy(this.decoder);\n        this.draco.destroy(this.metadataQuerier);\n    }\n    /**\n     * NOTE: caller must call `destroyGeometry` on the return value after using it\n     * @param arrayBuffer\n     * @param options\n     */\n    parseSync(arrayBuffer, options = {}) {\n        const buffer = new this.draco.DecoderBuffer();\n        buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n        this._disableAttributeTransforms(options);\n        const geometry_type = this.decoder.GetEncodedGeometryType(buffer);\n        const dracoGeometry = geometry_type === this.draco.TRIANGULAR_MESH\n            ? new this.draco.Mesh()\n            : new this.draco.PointCloud();\n        try {\n            let dracoStatus;\n            switch (geometry_type) {\n                case this.draco.TRIANGULAR_MESH:\n                    dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry);\n                    break;\n                case this.draco.POINT_CLOUD:\n                    dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n                    break;\n                default:\n                    throw new Error('DRACO: Unknown geometry type.');\n            }\n            if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n                const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;\n                // console.error(message);\n                throw new Error(message);\n            }\n            const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);\n            const geometry = this._getMeshData(dracoGeometry, loaderData, options);\n            const boundingBox = getMeshBoundingBox(geometry.attributes);\n            const schema = getDracoSchema(geometry.attributes, loaderData, geometry.indices);\n            const data = {\n                loader: 'draco',\n                loaderData,\n                header: {\n                    vertexCount: dracoGeometry.num_points(),\n                    boundingBox\n                },\n                ...geometry,\n                schema\n            };\n            return data;\n        }\n        finally {\n            this.draco.destroy(buffer);\n            if (dracoGeometry) {\n                this.draco.destroy(dracoGeometry);\n            }\n        }\n    }\n    // Draco specific \"loader data\"\n    /**\n     * Extract\n     * @param dracoGeometry\n     * @param geometry_type\n     * @param options\n     * @returns\n     */\n    _getDracoLoaderData(dracoGeometry, geometry_type, options) {\n        const metadata = this._getTopLevelMetadata(dracoGeometry);\n        const attributes = this._getDracoAttributes(dracoGeometry, options);\n        return {\n            geometry_type,\n            num_attributes: dracoGeometry.num_attributes(),\n            num_points: dracoGeometry.num_points(),\n            num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,\n            metadata,\n            attributes\n        };\n    }\n    /**\n     * Extract all draco provided information and metadata for each attribute\n     * @param dracoGeometry\n     * @param options\n     * @returns\n     */\n    _getDracoAttributes(dracoGeometry, options) {\n        const dracoAttributes = {};\n        for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n            // Note: Draco docs do not seem clear on `GetAttribute` ids just being a zero-based index,\n            // but it does seems to work this way\n            const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n            const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);\n            dracoAttributes[dracoAttribute.unique_id()] = {\n                unique_id: dracoAttribute.unique_id(),\n                attribute_type: dracoAttribute.attribute_type(),\n                data_type: dracoAttribute.data_type(),\n                num_components: dracoAttribute.num_components(),\n                byte_offset: dracoAttribute.byte_offset(),\n                byte_stride: dracoAttribute.byte_stride(),\n                normalized: dracoAttribute.normalized(),\n                attribute_index: attributeId,\n                metadata\n            };\n            // Add transformation parameters for any attributes app wants untransformed\n            const quantization = this._getQuantizationTransform(dracoAttribute, options);\n            if (quantization) {\n                dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;\n            }\n            const octahedron = this._getOctahedronTransform(dracoAttribute, options);\n            if (octahedron) {\n                dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;\n            }\n        }\n        return dracoAttributes;\n    }\n    /**\n     * Get standard loaders.gl mesh category data\n     * Extracts the geometry from draco\n     * @param dracoGeometry\n     * @param options\n     */\n    _getMeshData(dracoGeometry, loaderData, options) {\n        const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);\n        const positionAttribute = attributes.POSITION;\n        if (!positionAttribute) {\n            throw new Error('DRACO: No position attribute found.');\n        }\n        // For meshes, we need indices to define the faces.\n        if (dracoGeometry instanceof this.draco.Mesh) {\n            switch (options.topology) {\n                case 'triangle-strip':\n                    return {\n                        topology: 'triangle-strip',\n                        mode: 4, // GL.TRIANGLES\n                        attributes,\n                        indices: {\n                            value: this._getTriangleStripIndices(dracoGeometry),\n                            size: 1\n                        }\n                    };\n                case 'triangle-list':\n                default:\n                    return {\n                        topology: 'triangle-list',\n                        mode: 5, // GL.TRIANGLE_STRIP\n                        attributes,\n                        indices: {\n                            value: this._getTriangleListIndices(dracoGeometry),\n                            size: 1\n                        }\n                    };\n            }\n        }\n        // PointCloud - must come last as Mesh inherits from PointCloud\n        return {\n            topology: 'point-list',\n            mode: 0, // GL.POINTS\n            attributes\n        };\n    }\n    _getMeshAttributes(loaderData, dracoGeometry, options) {\n        const attributes = {};\n        for (const loaderAttribute of Object.values(loaderData.attributes)) {\n            const attributeName = this._deduceAttributeName(loaderAttribute, options);\n            loaderAttribute.name = attributeName;\n            const values = this._getAttributeValues(dracoGeometry, loaderAttribute);\n            if (values) {\n                const { value, size } = values;\n                attributes[attributeName] = {\n                    value,\n                    size,\n                    byteOffset: loaderAttribute.byte_offset,\n                    byteStride: loaderAttribute.byte_stride,\n                    normalized: loaderAttribute.normalized\n                };\n            }\n        }\n        return attributes;\n    }\n    // MESH INDICES EXTRACTION\n    /**\n     * For meshes, we need indices to define the faces.\n     * @param dracoGeometry\n     */\n    _getTriangleListIndices(dracoGeometry) {\n        // Example on how to retrieve mesh and attributes.\n        const numFaces = dracoGeometry.num_faces();\n        const numIndices = numFaces * 3;\n        const byteLength = numIndices * INDEX_ITEM_SIZE;\n        const ptr = this.draco._malloc(byteLength);\n        try {\n            this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n            return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();\n        }\n        finally {\n            this.draco._free(ptr);\n        }\n    }\n    /**\n     * For meshes, we need indices to define the faces.\n     * @param dracoGeometry\n     */\n    _getTriangleStripIndices(dracoGeometry) {\n        const dracoArray = new this.draco.DracoInt32Array();\n        try {\n            /* const numStrips = */ this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n            return getUint32Array(dracoArray);\n        }\n        finally {\n            this.draco.destroy(dracoArray);\n        }\n    }\n    /**\n     *\n     * @param dracoGeometry\n     * @param dracoAttribute\n     * @param attributeName\n     */\n    _getAttributeValues(dracoGeometry, attribute) {\n        const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];\n        if (!TypedArrayCtor) {\n            // eslint-disable-next-line no-console\n            console.warn(`DRACO: Unsupported attribute type ${attribute.data_type}`);\n            return null;\n        }\n        const numComponents = attribute.num_components;\n        const numPoints = dracoGeometry.num_points();\n        const numValues = numPoints * numComponents;\n        const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;\n        const dataType = getDracoDataType(this.draco, TypedArrayCtor);\n        let value;\n        const ptr = this.draco._malloc(byteLength);\n        try {\n            const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);\n            this.decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, dracoAttribute, dataType, byteLength, ptr);\n            value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();\n        }\n        finally {\n            this.draco._free(ptr);\n        }\n        return { value, size: numComponents };\n    }\n    // Attribute names\n    /**\n     * DRACO does not store attribute names - We need to deduce an attribute name\n     * for each attribute\n    _getAttributeNames(\n      dracoGeometry: Mesh | PointCloud,\n      options: DracoParseOptions\n    ): {[unique_id: number]: string} {\n      const attributeNames: {[unique_id: number]: string} = {};\n      for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n        const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n        const attributeName = this._deduceAttributeName(dracoAttribute, options);\n        attributeNames[attributeName] = attributeName;\n      }\n      return attributeNames;\n    }\n     */\n    /**\n     * Deduce an attribute name.\n     * @note DRACO does not save attribute names, just general type (POSITION, COLOR)\n     * to help optimize compression. We generate GLTF compatible names for the Draco-recognized\n     * types\n     * @param attributeData\n     */\n    _deduceAttributeName(attribute, options) {\n        // Deduce name based on application provided map\n        const uniqueId = attribute.unique_id;\n        for (const [attributeName, attributeUniqueId] of Object.entries(options.extraAttributes || {})) {\n            if (attributeUniqueId === uniqueId) {\n                return attributeName;\n            }\n        }\n        // Deduce name based on attribute type\n        const thisAttributeType = attribute.attribute_type;\n        for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n            const attributeType = this.draco[dracoAttributeConstant];\n            if (attributeType === thisAttributeType) {\n                // TODO - Return unique names if there multiple attributes per type\n                // (e.g. multiple TEX_COORDS or COLORS)\n                return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n            }\n        }\n        // Look up in metadata\n        // TODO - shouldn't this have priority?\n        const entryName = options.attributeNameEntry || 'name';\n        if (attribute.metadata[entryName]) {\n            return attribute.metadata[entryName].string;\n        }\n        // Attribute of \"GENERIC\" type, we need to assign some name\n        return `CUSTOM_ATTRIBUTE_${uniqueId}`;\n    }\n    // METADATA EXTRACTION\n    /** Get top level metadata */\n    _getTopLevelMetadata(dracoGeometry) {\n        const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);\n        return this._getDracoMetadata(dracoMetadata);\n    }\n    /** Get per attribute metadata */\n    _getAttributeMetadata(dracoGeometry, attributeId) {\n        const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n        return this._getDracoMetadata(dracoMetadata);\n    }\n    /**\n     * Extract metadata field values\n     * @param dracoMetadata\n     * @returns\n     */\n    _getDracoMetadata(dracoMetadata) {\n        // The not so wonderful world of undocumented Draco APIs :(\n        if (!dracoMetadata || !dracoMetadata.ptr) {\n            return {};\n        }\n        const result = {};\n        const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n        for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n            const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n            result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);\n        }\n        return result;\n    }\n    /**\n     * Extracts possible values for one metadata entry by name\n     * @param dracoMetadata\n     * @param entryName\n     */\n    _getDracoMetadataField(dracoMetadata, entryName) {\n        const dracoArray = new this.draco.DracoInt32Array();\n        try {\n            // Draco metadata fields can hold int32 arrays\n            this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);\n            const intArray = getInt32Array(dracoArray);\n            return {\n                int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n                string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n                double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n                intArray\n            };\n        }\n        finally {\n            this.draco.destroy(dracoArray);\n        }\n    }\n    // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)\n    /** Skip transforms for specific attribute types */\n    _disableAttributeTransforms(options) {\n        const { quantizedAttributes = [], octahedronAttributes = [] } = options;\n        const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];\n        for (const dracoAttributeName of skipAttributes) {\n            this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);\n        }\n    }\n    /**\n     * Extract (and apply?) Position Transform\n     * @todo not used\n     */\n    _getQuantizationTransform(dracoAttribute, options) {\n        const { quantizedAttributes = [] } = options;\n        const attribute_type = dracoAttribute.attribute_type();\n        const skip = quantizedAttributes.map((type) => this.decoder[type]).includes(attribute_type);\n        if (skip) {\n            const transform = new this.draco.AttributeQuantizationTransform();\n            try {\n                if (transform.InitFromAttribute(dracoAttribute)) {\n                    return {\n                        quantization_bits: transform.quantization_bits(),\n                        range: transform.range(),\n                        min_values: new Float32Array([1, 2, 3]).map((i) => transform.min_value(i))\n                    };\n                }\n            }\n            finally {\n                this.draco.destroy(transform);\n            }\n        }\n        return null;\n    }\n    _getOctahedronTransform(dracoAttribute, options) {\n        const { octahedronAttributes = [] } = options;\n        const attribute_type = dracoAttribute.attribute_type();\n        const octahedron = octahedronAttributes\n            .map((type) => this.decoder[type])\n            .includes(attribute_type);\n        if (octahedron) {\n            const transform = new this.draco.AttributeQuantizationTransform();\n            try {\n                if (transform.InitFromAttribute(dracoAttribute)) {\n                    return {\n                        quantization_bits: transform.quantization_bits()\n                    };\n                }\n            }\n            finally {\n                this.draco.destroy(transform);\n            }\n        }\n        return null;\n    }\n}\n/**\n * Get draco specific data type by TypedArray constructor type\n * @param attributeType\n * @returns draco specific data type\n */\nfunction getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n        case Float32Array:\n            return draco.DT_FLOAT32;\n        case Int8Array:\n            return draco.DT_INT8;\n        case Int16Array:\n            return draco.DT_INT16;\n        case Int32Array:\n            return draco.DT_INT32;\n        case Uint8Array:\n            return draco.DT_UINT8;\n        case Uint16Array:\n            return draco.DT_UINT16;\n        case Uint32Array:\n            return draco.DT_UINT32;\n        default:\n            return draco.DT_INVALID;\n    }\n}\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getInt32Array(dracoArray) {\n    const numValues = dracoArray.size();\n    const intArray = new Int32Array(numValues);\n    for (let i = 0; i < numValues; i++) {\n        intArray[i] = dracoArray.GetValue(i);\n    }\n    return intArray;\n}\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getUint32Array(dracoArray) {\n    const numValues = dracoArray.size();\n    const intArray = new Int32Array(numValues);\n    for (let i = 0; i < numValues; i++) {\n        intArray[i] = dracoArray.GetValue(i);\n    }\n    return intArray;\n}\n", "// Dynamic DRACO module loading inspired by THREE.DRACOLoader\n// https://github.com/mrdoob/three.js/blob/398c4f39ebdb8b23eefd4a7a5ec49ec0c96c7462/examples/jsm/loaders/DRACOLoader.js\n// by Don McCurdy / https://www.donmccurdy.com / MIT license\nimport { loadLibrary } from '@loaders.gl/worker-utils';\nconst DRACO_DECODER_VERSION = '1.5.6';\nconst DRACO_ENCODER_VERSION = '1.4.1';\nconst STATIC_DECODER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_DECODER_VERSION}`;\nexport const DRACO_EXTERNAL_LIBRARIES = {\n    /** The primary Draco3D encoder, javascript wrapper part */\n    DECODER: 'draco_wasm_wrapper.js',\n    /** The primary draco decoder, compiled web assembly part */\n    DECODER_WASM: 'draco_decoder.wasm',\n    /** Fallback decoder for non-webassebly environments. Very big bundle, lower performance */\n    FALLBACK_DECODER: 'draco_decoder.js',\n    /** Draco encoder */\n    ENCODER: 'draco_encoder.js'\n};\nexport const DRACO_EXTERNAL_LIBRARY_URLS = {\n    [DRACO_EXTERNAL_LIBRARIES.DECODER]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.DECODER}`,\n    [DRACO_EXTERNAL_LIBRARIES.DECODER_WASM]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.DECODER_WASM}`,\n    [DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER}`,\n    [DRACO_EXTERNAL_LIBRARIES.ENCODER]: `https://raw.githubusercontent.com/google/draco/${DRACO_ENCODER_VERSION}/javascript/${DRACO_EXTERNAL_LIBRARIES.ENCODER}`\n};\nlet loadDecoderPromise;\nlet loadEncoderPromise;\nexport async function loadDracoDecoderModule(options) {\n    const modules = options.modules || {};\n    // Check if a bundled draco3d library has been supplied by application\n    if (modules.draco3d) {\n        loadDecoderPromise ||= modules.draco3d.createDecoderModule({}).then((draco) => {\n            return { draco };\n        });\n    }\n    else {\n        // If not, dynamically load the WASM script from our CDN\n        loadDecoderPromise ||= loadDracoDecoder(options);\n    }\n    return await loadDecoderPromise;\n}\nexport async function loadDracoEncoderModule(options) {\n    const modules = options.modules || {};\n    // Check if a bundled draco3d library has been supplied by application\n    if (modules.draco3d) {\n        loadEncoderPromise ||= modules.draco3d.createEncoderModule({}).then((draco) => {\n            return { draco };\n        });\n    }\n    else {\n        // If not, dynamically load the WASM script from our CDN\n        loadEncoderPromise ||= loadDracoEncoder(options);\n    }\n    return await loadEncoderPromise;\n}\n// DRACO DECODER LOADING\nasync function loadDracoDecoder(options) {\n    let DracoDecoderModule;\n    let wasmBinary;\n    switch (options.draco && options.draco.decoderType) {\n        case 'js':\n            DracoDecoderModule = await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER], 'draco', options, DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER);\n            break;\n        case 'wasm':\n        default:\n            [DracoDecoderModule, wasmBinary] = await Promise.all([\n                await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.DECODER], 'draco', options, DRACO_EXTERNAL_LIBRARIES.DECODER),\n                await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.DECODER_WASM], 'draco', options, DRACO_EXTERNAL_LIBRARIES.DECODER_WASM)\n            ]);\n    }\n    // Depends on how import happened...\n    // @ts-ignore\n    DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;\n    return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);\n}\nfunction initializeDracoDecoder(DracoDecoderModule, wasmBinary) {\n    const options = {};\n    if (wasmBinary) {\n        options.wasmBinary = wasmBinary;\n    }\n    return new Promise((resolve) => {\n        DracoDecoderModule({\n            ...options,\n            onModuleLoaded: (draco) => resolve({ draco }) // Module is Promise-like. Wrap in object to avoid loop.\n        });\n    });\n}\n// ENCODER\nasync function loadDracoEncoder(options) {\n    let DracoEncoderModule = await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.ENCODER], 'draco', options, DRACO_EXTERNAL_LIBRARIES.ENCODER);\n    // @ts-ignore\n    DracoEncoderModule = DracoEncoderModule || globalThis.DracoEncoderModule;\n    return new Promise((resolve) => {\n        DracoEncoderModule({\n            onModuleLoaded: (draco) => resolve({ draco }) // Module is Promise-like. Wrap in object to avoid loop.\n        });\n    });\n}\n", "import { DracoLoader as DracoWorkerLoader } from \"./draco-loader.js\";\nimport DracoParser from \"./lib/draco-parser.js\";\nimport { loadDracoDecoderModule } from \"./lib/draco-module-loader.js\";\nimport { VERSION } from \"./lib/utils/version.js\";\n// Module constants\nexport { DRACO_EXTERNAL_LIBRARIES, DRACO_EXTERNAL_LIBRARY_URLS } from \"./lib/draco-module-loader.js\";\nexport { DracoWriter } from \"./draco-writer.js\";\n/**\n * Browser worker doesn't work because of issue during \"draco_encoder.js\" loading.\n * Refused to execute script from 'https://raw.githubusercontent.com/google/draco/1.4.1/javascript/draco_encoder.js' because its MIME type ('') is not executable.\n */\nexport const DracoWriterWorker = {\n    id: 'draco-writer',\n    name: 'Draco compressed geometry writer',\n    module: 'draco',\n    version: VERSION,\n    worker: true,\n    options: {\n        draco: {},\n        source: null\n    }\n};\nexport { DracoWorkerLoader };\n/**\n * Loader for Draco3D compressed geometries\n */\nexport const DracoLoader = {\n    ...DracoWorkerLoader,\n    parse\n};\nasync function parse(arrayBuffer, options) {\n    const { draco } = await loadDracoDecoderModule(options);\n    const dracoParser = new DracoParser(draco);\n    try {\n        return dracoParser.parseSync(arrayBuffer, options?.draco);\n    }\n    finally {\n        dracoParser.destroy();\n    }\n}\n", "// TODO - remove\nimport { getAccessorTypeFromSize, getComponentTypeFromArray } from \"./gltf-utils.js\";\n// Returns a fresh attributes object with glTF-standardized attributes names\n// Attributes that cannot be identified will not be included\n// Removes `indices` if present, as it should be stored separately from the attributes\nexport function getGLTFAccessors(attributes) {\n    const accessors = {};\n    for (const name in attributes) {\n        const attribute = attributes[name];\n        if (name !== 'indices') {\n            const glTFAccessor = getGLTFAccessor(attribute);\n            accessors[name] = glTFAccessor;\n        }\n    }\n    return accessors;\n}\n// Fix up a single accessor.\n// Input: typed array or a partial accessor object\n// Return: accessor object\nexport function getGLTFAccessor(attribute) {\n    const { buffer, size, count } = getAccessorData(attribute);\n    const glTFAccessor = {\n        // glTF Accessor values\n        // TODO: Instead of a bufferView index we could have an actual buffer (typed array)\n        // bufferView: null,\n        // TODO: Deprecate `value` in favor of bufferView?\n        // @ts-ignore\n        value: buffer,\n        size, // Decoded `type` (e.g. SCALAR)\n        byteOffset: 0,\n        count,\n        type: getAccessorTypeFromSize(size),\n        componentType: getComponentTypeFromArray(buffer)\n    };\n    return glTFAccessor;\n}\n// export function getGLTFAttribute(data, gltfAttributeName): GLTFAccessor {\n//   return data.attributes[data.glTFAttributeMap[gltfAttributeName]];\n// }\nfunction getAccessorData(attribute) {\n    let buffer = attribute;\n    let size = 1;\n    let count = 0;\n    if (attribute && attribute.value) {\n        buffer = attribute.value;\n        size = attribute.size || 1;\n    }\n    if (buffer) {\n        if (!ArrayBuffer.isView(buffer)) {\n            buffer = toTypedArray(buffer, Float32Array);\n        }\n        count = buffer.length / size;\n    }\n    return { buffer, size, count };\n}\n// Convert non-typed arrays to arrays of specified format\nfunction toTypedArray(array, ArrayType, convertTypedArrays = false) {\n    if (!array) {\n        return null;\n    }\n    if (Array.isArray(array)) {\n        return new ArrayType(array);\n    }\n    if (convertTypedArrays && !(array instanceof ArrayType)) {\n        return new ArrayType(array);\n    }\n    return array;\n}\n", "/**\n * https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_texture_transform/README.md\n */\nimport { Vector3, Matrix3 } from '@math.gl/core';\nimport { getAccessorArrayTypeAndLength } from \"../gltf-utils/gltf-utils.js\";\nimport { BYTES, COMPONENTS } from \"../gltf-utils/gltf-constants.js\";\nimport { GLTFScenegraph } from \"../api/gltf-scenegraph.js\";\n/** Extension name */\nconst KHR_TEXTURE_TRANSFORM = 'KHR_texture_transform';\nexport const name = KHR_TEXTURE_TRANSFORM;\nconst scratchVector = new Vector3();\nconst scratchRotationMatrix = new Matrix3();\nconst scratchScaleMatrix = new Matrix3();\n/**\n * The extension entry to process the transformation\n * @param gltfData gltf buffers and json\n * @param options GLTFLoader options\n */\nexport async function decode(gltfData, options) {\n    const gltfScenegraph = new GLTFScenegraph(gltfData);\n    const hasExtension = gltfScenegraph.hasExtension(KHR_TEXTURE_TRANSFORM);\n    if (!hasExtension || !options.gltf?.loadBuffers) {\n        return;\n    }\n    const materials = gltfData.json.materials || [];\n    for (let i = 0; i < materials.length; i++) {\n        transformTexCoords(i, gltfData);\n    }\n}\n/**\n * Transform TEXCOORD by material\n * @param materialIndex processing material index\n * @param gltfData gltf buffers and json\n */\nfunction transformTexCoords(materialIndex, gltfData) {\n    const material = gltfData.json.materials?.[materialIndex];\n    const materialTextures = [\n        material?.pbrMetallicRoughness?.baseColorTexture,\n        material?.emissiveTexture,\n        material?.normalTexture,\n        material?.occlusionTexture,\n        material?.pbrMetallicRoughness?.metallicRoughnessTexture\n    ];\n    // Save processed texCoords in order no to process the same twice\n    const processedTexCoords = [];\n    for (const textureInfo of materialTextures) {\n        if (textureInfo && textureInfo?.extensions?.[KHR_TEXTURE_TRANSFORM]) {\n            transformPrimitives(gltfData, materialIndex, textureInfo, processedTexCoords);\n        }\n    }\n}\n/**\n * Transform primitives of the particular material\n * @param gltfData gltf data\n * @param materialIndex primitives with this material will be transformed\n * @param texture texture object\n * @param processedTexCoords storage to save already processed texCoords\n */\nfunction transformPrimitives(gltfData, materialIndex, texture, processedTexCoords) {\n    const transformParameters = getTransformParameters(texture, processedTexCoords);\n    if (!transformParameters) {\n        return;\n    }\n    const meshes = gltfData.json.meshes || [];\n    for (const mesh of meshes) {\n        for (const primitive of mesh.primitives) {\n            const material = primitive.material;\n            if (Number.isFinite(material) && materialIndex === material) {\n                transformPrimitive(gltfData, primitive, transformParameters);\n            }\n        }\n    }\n}\n/**\n * Get parameters for TEXCOORD transformation\n * @param texture texture object\n * @param processedTexCoords storage to save already processed texCoords\n * @returns texCoord couple and transformation matrix\n */\nfunction getTransformParameters(texture, processedTexCoords) {\n    const textureInfo = texture.extensions?.[KHR_TEXTURE_TRANSFORM];\n    const { texCoord: originalTexCoord = 0 } = texture;\n    // If texCoord is not set in the extension, original attribute data will be replaced\n    const { texCoord = originalTexCoord } = textureInfo;\n    // Make sure that couple [originalTexCoord, extensionTexCoord] is not processed twice\n    const isProcessed = processedTexCoords.findIndex(([original, newTexCoord]) => original === originalTexCoord && newTexCoord === texCoord) !== -1;\n    if (!isProcessed) {\n        const matrix = makeTransformationMatrix(textureInfo);\n        if (originalTexCoord !== texCoord) {\n            texture.texCoord = texCoord;\n        }\n        processedTexCoords.push([originalTexCoord, texCoord]);\n        return { originalTexCoord, texCoord, matrix };\n    }\n    return null;\n}\n/**\n * Transform `TEXCOORD_0` attribute in the primitive\n * @param gltfData gltf data\n * @param primitive primitive object\n * @param transformParameters texCoord couple and transformation matrix\n */\nfunction transformPrimitive(gltfData, primitive, transformParameters) {\n    const { originalTexCoord, texCoord, matrix } = transformParameters;\n    const texCoordAccessor = primitive.attributes[`TEXCOORD_${originalTexCoord}`];\n    if (Number.isFinite(texCoordAccessor)) {\n        // Get accessor of the `TEXCOORD_0` attribute\n        const accessor = gltfData.json.accessors?.[texCoordAccessor];\n        if (accessor && accessor.bufferView) {\n            // Get `bufferView` of the `accessor`\n            const bufferView = gltfData.json.bufferViews?.[accessor.bufferView];\n            if (bufferView) {\n                // Get `arrayBuffer` the `bufferView` look at\n                const { arrayBuffer, byteOffset: bufferByteOffset } = gltfData.buffers[bufferView.buffer];\n                // Resulting byteOffset is sum of the buffer, accessor and bufferView byte offsets\n                const byteOffset = (bufferByteOffset || 0) + (accessor.byteOffset || 0) + (bufferView.byteOffset || 0);\n                // Deduce TypedArray type and its length from `accessor` and `bufferView` data\n                const { ArrayType, length } = getAccessorArrayTypeAndLength(accessor, bufferView);\n                // Number of bytes each component occupies\n                const bytes = BYTES[accessor.componentType];\n                // Number of components. For the `TEXCOORD_0` with `VEC2` type, it must return 2\n                const components = COMPONENTS[accessor.type];\n                // Multiplier to calculate the address of the `TEXCOORD_0` element in the arrayBuffer\n                const elementAddressScale = bufferView.byteStride || bytes * components;\n                // Data transform to Float32Array\n                const result = new Float32Array(length);\n                for (let i = 0; i < accessor.count; i++) {\n                    // Take [u, v] couple from the arrayBuffer\n                    const uv = new ArrayType(arrayBuffer, byteOffset + i * elementAddressScale, 2);\n                    // Set and transform Vector3 per https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#overview\n                    scratchVector.set(uv[0], uv[1], 1);\n                    scratchVector.transformByMatrix3(matrix);\n                    // Save result in Float32Array\n                    result.set([scratchVector[0], scratchVector[1]], i * components);\n                }\n                // If texCoord the same, replace gltf structural data\n                if (originalTexCoord === texCoord) {\n                    updateGltf(accessor, bufferView, gltfData.buffers, result);\n                }\n                else {\n                    // If texCoord change, create new attribute\n                    createAttribute(texCoord, accessor, primitive, gltfData, result);\n                }\n            }\n        }\n    }\n}\n/**\n * Update GLTF structural objects with new data as we create new `Float32Array` for `TEXCOORD_0`.\n * @param accessor accessor to change\n * @param bufferView bufferView to change\n * @param buffers binary buffers\n * @param newTexcoordArray typed array with data after transformation\n */\nfunction updateGltf(accessor, bufferView, buffers, newTexCoordArray) {\n    accessor.componentType = 5126;\n    buffers.push({\n        arrayBuffer: newTexCoordArray.buffer,\n        byteOffset: 0,\n        byteLength: newTexCoordArray.buffer.byteLength\n    });\n    bufferView.buffer = buffers.length - 1;\n    bufferView.byteLength = newTexCoordArray.buffer.byteLength;\n    bufferView.byteOffset = 0;\n    delete bufferView.byteStride;\n}\n/**\n *\n * @param newTexCoord new `texCoord` value\n * @param originalAccessor original accessor object, that store data before transformation\n * @param primitive primitive object\n * @param gltfData gltf data\n * @param newTexCoordArray typed array with data after transformation\n * @returns\n */\nfunction createAttribute(newTexCoord, originalAccessor, primitive, gltfData, newTexCoordArray) {\n    gltfData.buffers.push({\n        arrayBuffer: newTexCoordArray.buffer,\n        byteOffset: 0,\n        byteLength: newTexCoordArray.buffer.byteLength\n    });\n    const bufferViews = gltfData.json.bufferViews;\n    if (!bufferViews) {\n        return;\n    }\n    bufferViews.push({\n        buffer: gltfData.buffers.length - 1,\n        byteLength: newTexCoordArray.buffer.byteLength,\n        byteOffset: 0\n    });\n    const accessors = gltfData.json.accessors;\n    if (!accessors) {\n        return;\n    }\n    accessors.push({\n        bufferView: bufferViews?.length - 1,\n        byteOffset: 0,\n        componentType: 5126,\n        count: originalAccessor.count,\n        type: 'VEC2'\n    });\n    primitive.attributes[`TEXCOORD_${newTexCoord}`] = accessors.length - 1;\n}\n/**\n * Construct transformation matrix from the extension data (transition, rotation, scale)\n * @param extensionData extension data\n * @returns transformation matrix\n */\nfunction makeTransformationMatrix(extensionData) {\n    const { offset = [0, 0], rotation = 0, scale = [1, 1] } = extensionData;\n    const translationMatrix = new Matrix3().set(1, 0, 0, 0, 1, 0, offset[0], offset[1], 1);\n    const rotationMatrix = scratchRotationMatrix.set(Math.cos(rotation), Math.sin(rotation), 0, -Math.sin(rotation), Math.cos(rotation), 0, 0, 0, 1);\n    const scaleMatrix = scratchScaleMatrix.set(scale[0], 0, 0, 0, scale[1], 0, 0, 0, 1);\n    return translationMatrix.multiplyRight(rotationMatrix).multiplyRight(scaleMatrix);\n}\n", "// GLTF EXTENSION: KHR_lights_punctual\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\nimport { assert } from \"../../utils/assert.js\";\nimport { GLTFScenegraph } from \"../../api/gltf-scenegraph.js\";\nconst KHR_LIGHTS_PUNCTUAL = 'KHR_lights_punctual';\nexport const name = KHR_LIGHTS_PUNCTUAL;\nexport async function decode(gltfData) {\n    const gltfScenegraph = new GLTFScenegraph(gltfData);\n    const { json } = gltfScenegraph;\n    // Move the light array out of the extension and remove the extension\n    const extension = gltfScenegraph.getExtension(KHR_LIGHTS_PUNCTUAL);\n    if (extension) {\n        // @ts-ignore\n        gltfScenegraph.json.lights = extension.lights;\n        gltfScenegraph.removeExtension(KHR_LIGHTS_PUNCTUAL);\n    }\n    // Any nodes that have the extension, add lights field pointing to light object\n    // and remove the extension\n    for (const node of json.nodes || []) {\n        const nodeExtension = gltfScenegraph.getObjectExtension(node, KHR_LIGHTS_PUNCTUAL);\n        if (nodeExtension) {\n            // @ts-ignore\n            node.light = nodeExtension.light;\n        }\n        gltfScenegraph.removeObjectExtension(node, KHR_LIGHTS_PUNCTUAL);\n    }\n}\n// Move the light ar ray out of the extension and remove the extension\nexport async function encode(gltfData) {\n    const gltfScenegraph = new GLTFScenegraph(gltfData);\n    const { json } = gltfScenegraph;\n    // @ts-ignore\n    if (json.lights) {\n        const extension = gltfScenegraph.addExtension(KHR_LIGHTS_PUNCTUAL);\n        // @ts-ignore\n        assert(!extension.lights);\n        // @ts-ignore\n        extension.lights = json.lights;\n        // @ts-ignore\n        delete json.lights;\n    }\n    // Any nodes that have lights field pointing to light object\n    // add the extension\n    // @ts-ignore\n    if (gltfScenegraph.json.lights) {\n        // @ts-ignore\n        for (const light of gltfScenegraph.json.lights) {\n            const node = light.node;\n            gltfScenegraph.addObjectExtension(node, KHR_LIGHTS_PUNCTUAL, light);\n        }\n        // @ts-ignore\n        delete gltfScenegraph.json.lights;\n    }\n}\n", "// GLTF EXTENSION: KHR_materials_unlit\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\nimport { GLTFScenegraph } from \"../../api/gltf-scenegraph.js\";\nconst KHR_MATERIALS_UNLIT = 'KHR_materials_unlit';\nexport const name = KHR_MATERIALS_UNLIT;\nexport async function decode(gltfData) {\n    const gltfScenegraph = new GLTFScenegraph(gltfData);\n    const { json } = gltfScenegraph;\n    // Any nodes that have the extension, add lights field pointing to light object\n    // and remove the extension\n    for (const material of json.materials || []) {\n        const extension = material.extensions && material.extensions.KHR_materials_unlit;\n        if (extension) {\n            // @ts-ignore TODO\n            material.unlit = true;\n        }\n        gltfScenegraph.removeObjectExtension(material, KHR_MATERIALS_UNLIT);\n    }\n    // Remove the top-level extension\n    gltfScenegraph.removeExtension(KHR_MATERIALS_UNLIT);\n}\nexport function encode(gltfData) {\n    const gltfScenegraph = new GLTFScenegraph(gltfData);\n    const { json } = gltfScenegraph;\n    // Any nodes that have lights field pointing to light object\n    // add the extension\n    // @ts-ignore\n    if (gltfScenegraph.materials) {\n        for (const material of json.materials || []) {\n            // @ts-ignore\n            if (material.unlit) {\n                // @ts-ignore\n                delete material.unlit;\n                gltfScenegraph.addObjectExtension(material, KHR_MATERIALS_UNLIT, {});\n                gltfScenegraph.addExtension(KHR_MATERIALS_UNLIT);\n            }\n        }\n    }\n}\n", "// GLTF EXTENSION: KHR_techniques_webgl\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_techniques_webgl\nimport { GLTFScenegraph } from \"../../api/gltf-scenegraph.js\";\nconst KHR_TECHNIQUES_WEBGL = 'KHR_techniques_webgl';\nexport const name = KHR_TECHNIQUES_WEBGL;\nexport async function decode(gltfData) {\n    const gltfScenegraph = new GLTFScenegraph(gltfData);\n    const { json } = gltfScenegraph;\n    const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);\n    if (extension) {\n        const techniques = resolveTechniques(extension, gltfScenegraph);\n        for (const material of json.materials || []) {\n            const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n            if (materialExtension) {\n                // @ts-ignore TODO\n                material.technique = Object.assign({}, materialExtension, \n                // @ts-ignore\n                techniques[materialExtension.technique]);\n                // @ts-ignore TODO\n                material.technique.values = resolveValues(material.technique, gltfScenegraph);\n            }\n            gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n        }\n        // Remove the top-level extension\n        gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);\n    }\n}\n// eslint-disable-next-line\nexport async function encode(gltfData, options) {\n    // TODO\n}\nfunction resolveTechniques(techniquesExtension, \n// programs: {[key: string]: any}[],\n// shaders: {[key: string]: any}[],\n// techniques: {[key: string]: any}[]\ngltfScenegraph) {\n    const { programs = [], shaders = [], techniques = [] } = techniquesExtension;\n    const textDecoder = new TextDecoder();\n    shaders.forEach((shader) => {\n        if (Number.isFinite(shader.bufferView)) {\n            shader.code = textDecoder.decode(gltfScenegraph.getTypedArrayForBufferView(shader.bufferView));\n        }\n        else {\n            // TODO: handle URI shader\n            throw new Error('KHR_techniques_webgl: no shader code');\n        }\n    });\n    programs.forEach((program) => {\n        program.fragmentShader = shaders[program.fragmentShader];\n        program.vertexShader = shaders[program.vertexShader];\n    });\n    techniques.forEach((technique) => {\n        technique.program = programs[technique.program];\n    });\n    return techniques;\n}\nfunction resolveValues(technique, gltfScenegraph) {\n    const values = Object.assign({}, technique.values);\n    // merge values from uniforms\n    Object.keys(technique.uniforms || {}).forEach((uniform) => {\n        if (technique.uniforms[uniform].value && !(uniform in values)) {\n            values[uniform] = technique.uniforms[uniform].value;\n        }\n    });\n    // resolve textures\n    Object.keys(values).forEach((uniform) => {\n        if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {\n            // Assume this is a texture\n            // TODO: find if there are any other types that can be referenced\n            values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);\n        }\n    });\n    return values;\n}\n", "// GLTF 1.0 extensions (decode only)\n// import * as KHR_binary_gltf from './KHR_draco_mesh_compression';\n// GLTF 2.0 Vendor extensions\nimport * as EXT_mesh_features from \"../extensions/EXT_mesh_features.js\";\nimport * as EXT_structural_metadata from \"../extensions/EXT_structural_metadata.js\";\n// GLTF 2.0 Khronos extensions (decode/encode)\nimport * as EXT_meshopt_compression from \"../extensions/EXT_meshopt_compression.js\";\nimport * as EXT_texture_webp from \"../extensions/EXT_texture_webp.js\";\nimport * as KHR_texture_basisu from \"../extensions/KHR_texture_basisu.js\";\nimport * as KHR_draco_mesh_compression from \"../extensions/KHR_draco_mesh_compression.js\";\nimport * as KHR_texture_transform from \"../extensions/KHR_texture_transform.js\";\n// Deprecated. These should be handled by rendering library (e.g. luma.gl), not the loader.\nimport * as KHR_lights_punctual from \"../extensions/deprecated/KHR_lights_punctual.js\";\nimport * as KHR_materials_unlit from \"../extensions/deprecated/KHR_materials_unlit.js\";\nimport * as KHR_techniques_webgl from \"../extensions/deprecated/KHR_techniques_webgl.js\";\nimport * as EXT_feature_metadata from \"../extensions/deprecated/EXT_feature_metadata.js\";\n/**\n * List of extensions processed by the GLTFLoader\n * Note that may extensions can only be handled on the rendering stage and are left out here\n * These are just extensions that can be handled fully or partially during loading.\n */\nexport const EXTENSIONS = [\n    // 1.0\n    // KHR_binary_gltf is handled separately - must be processed before other parsing starts\n    // KHR_binary_gltf,\n    // 2.0\n    EXT_structural_metadata,\n    EXT_mesh_features,\n    EXT_meshopt_compression,\n    EXT_texture_webp,\n    // Basisu should come after webp, we want basisu to be preferred if both are provided\n    KHR_texture_basisu,\n    KHR_draco_mesh_compression,\n    KHR_lights_punctual,\n    KHR_materials_unlit,\n    KHR_techniques_webgl,\n    KHR_texture_transform,\n    EXT_feature_metadata\n];\n/**\n * List of extensions processed by the GLTFWriter\n */\nconst EXTENSIONS_ENCODING = [EXT_structural_metadata, EXT_mesh_features];\n/** Call before any resource loading starts */\nexport function preprocessExtensions(gltf, options = {}, context) {\n    const extensions = EXTENSIONS.filter((extension) => useExtension(extension.name, options));\n    for (const extension of extensions) {\n        extension.preprocess?.(gltf, options, context);\n    }\n}\n/** Call after resource loading */\nexport async function decodeExtensions(gltf, options = {}, context) {\n    const extensions = EXTENSIONS.filter((extension) => useExtension(extension.name, options));\n    for (const extension of extensions) {\n        // Note: We decode async extensions sequentially, this might not be necessary\n        // Currently we only have Draco, but when we add Basis we may revisit\n        await extension.decode?.(gltf, options, context);\n    }\n}\n/** Call before resource writing */\nexport function encodeExtensions(gltf, options = {}) {\n    for (const extension of EXTENSIONS_ENCODING) {\n        gltf = extension.encode?.(gltf, options) ?? gltf;\n    }\n    return gltf;\n}\nfunction useExtension(extensionName, options) {\n    const excludes = options?.gltf?.excludeExtensions || {};\n    const exclude = extensionName in excludes && !excludes[extensionName];\n    return !exclude;\n}\n", "// GLTF 1.0 EXTENSION: KHR_binary_glTF\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\n/* eslint-disable camelcase */\nimport { GLTFScenegraph } from \"../api/gltf-scenegraph.js\";\nconst KHR_BINARY_GLTF = 'KHR_binary_glTF';\n/** Extension name */\nexport const name = KHR_BINARY_GLTF;\nexport function preprocess(gltfData) {\n    const gltfScenegraph = new GLTFScenegraph(gltfData);\n    const { json } = gltfScenegraph;\n    // Note: json.buffers.binary_glTF also needs to be replaced\n    // This is currently done during gltf normalization\n    // Image and shader nodes can have the extension\n    // https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/schema/image.KHR_binary_glTF.schema.json\n    for (const image of json.images || []) {\n        const extension = gltfScenegraph.getObjectExtension(image, KHR_BINARY_GLTF);\n        // The data in the extension is valid as glTF 2.0 data inside the object, so just copy it in\n        if (extension) {\n            Object.assign(image, extension);\n        }\n        gltfScenegraph.removeObjectExtension(image, KHR_BINARY_GLTF);\n    }\n    // TODO shaders - At least traverse and throw error if used?\n    // https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/schema/shader.KHR_binary_glTF.schema.json\n    // glTF v1 one files have a partially formed URI field that is not expected in (and causes problems in) 2.0\n    if (json.buffers && json.buffers[0]) {\n        delete json.buffers[0].uri;\n    }\n    // Remove the top-level extension as it has now been processed\n    gltfScenegraph.removeExtension(KHR_BINARY_GLTF);\n}\n// KHR_binary_gltf is a 1.0 extension that is supported natively by 2.0\n// export function encode() {\n//   throw new Error(KHR_BINARY_GLTF);\n// }\n", "/* eslint-disable camelcase */\nimport * as KHR_binary_glTF from \"../extensions/KHR_binary_gltf.js\";\n// Binary format changes (mainly implemented by GLBLoader)\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\n// JSON format changes:\n// https://github.com/khronosgroup/gltf/issues/605\n// - [x] Top-level JSON objects are arrays now\n// - [ ] Removed indirection from animation: sampler now refers directly to accessors, #712\n// - [ ] material.parameter.value and technique.parameter.value must be an array, #690\n// - [ ] Node can have only one mesh #821\n// - [ ] Added reqs on JSON encoding\n// - [ ] Added reqs on binary data alignment #802 (comment)\n// Additions:\n// - [ ] Added accessor.normalized, #691, #706\n// - [ ] Added glExtensionsUsed property and 5125 (UNSIGNED_INT) accessor.componentType value, #619\n// - [ ] Added extensionsRequired property, #720, #721\n// - [ ] Added \"STEP\" as valid animation.sampler.interpolation value, #712\n// Removals:\n// - [x] Removed buffer.type, #786, #629\n// - [ ] Removed revision number from profile.version, #709\n// - [ ] Removed technique.functions.scissor and removed 3089 (SCISSOR_TEST) as a valid value for technique.states.enable, #681\n// - [ ] Techniques, programs, and shaders were moved out to KHR_technique_webgl extension.\n// Other edits:\n// - [x] asset is now required, #642\n// - [ ] buffer.byteLength and bufferView.byteLength are now required, #560.\n// - [ ] accessor.min and accessor.max are now required, #593, and clarified that the JSON value and binary data must be the same, #628.\n// - [ ] Clarified animation.sampler and animation.channel restrictions, #712\n// - [ ] skin.inverseBindMatrices is now optional, #461.\n// - [ ] Attribute parameters can't have a value defined in the technique or parameter, #563 (comment).\n// - [ ] Only TEXCOORD and COLOR attribute semantics can be written in the form [semantic]_[set_index], #563 (comment).\n// - [ ] TEXCOORD and COLOR attribute semantics must be written in the form [semantic]_[set_index], e.g., just TEXCOORD should be TEXCOORD_0, and just COLOR should be COLOR_0, #649\n// - [ ] camera.perspective.aspectRatio and camera.perspective.yfov must now be > 0, not >= 0, #563 (comment).\n// - [ ] Application-specific parameter semantics must start with an underscore, e.g., _TEMPERATURE and _SIMULATION_TIME, #563 (comment).\n// - [ ] Properties in technique.parameters must be defined in technique.uniforms or technique.attributes,\n// #563 (comment).\n// - [ ] technique.parameter.count can only be defined when the semantic is JOINTMATRIX or an application-specific semantic is used. It can never be defined for attribute parameters; only uniforms, d2f6945\n// - [ ] technique.parameter.semantic is required when the parameter is an attribute, 28e113d\n// - [ ] Mesh-only models are allowed, e.g., without materials, #642\n// - [ ] Skeleton hierarchies (nodes containing jointName) must be separated from non-skeleton hierarchies., #647\n// - [ ] technique.states.functions.blendColor and technique.states.functions.depthRange parameters now must match WebGL function min/max, #707\nconst GLTF_ARRAYS = {\n    accessors: 'accessor',\n    animations: 'animation',\n    buffers: 'buffer',\n    bufferViews: 'bufferView',\n    images: 'image',\n    materials: 'material',\n    meshes: 'mesh',\n    nodes: 'node',\n    samplers: 'sampler',\n    scenes: 'scene',\n    skins: 'skin',\n    textures: 'texture'\n};\nconst GLTF_KEYS = {\n    accessor: 'accessors',\n    animations: 'animation',\n    buffer: 'buffers',\n    bufferView: 'bufferViews',\n    image: 'images',\n    material: 'materials',\n    mesh: 'meshes',\n    node: 'nodes',\n    sampler: 'samplers',\n    scene: 'scenes',\n    skin: 'skins',\n    texture: 'textures'\n};\n/**\n * Converts (normalizes) glTF v1 to v2\n */\nclass GLTFV1Normalizer {\n    idToIndexMap = {\n        animations: {},\n        accessors: {},\n        buffers: {},\n        bufferViews: {},\n        images: {},\n        materials: {},\n        meshes: {},\n        nodes: {},\n        samplers: {},\n        scenes: {},\n        skins: {},\n        textures: {}\n    };\n    json;\n    // constructor() {}\n    /**\n     * Convert (normalize) glTF < 2.0 to glTF 2.0\n     * @param gltf - object with json and binChunks\n     * @param options\n     * @param options normalize Whether to actually normalize\n     */\n    normalize(gltf, options) {\n        this.json = gltf.json;\n        const json = gltf.json;\n        // Check version\n        switch (json.asset && json.asset.version) {\n            // We are converting to v2 format. Return if there is nothing to do\n            case '2.0':\n                return;\n            // This class is written to convert 1.0\n            case undefined:\n            case '1.0':\n                break;\n            default:\n                // eslint-disable-next-line no-undef, no-console\n                console.warn(`glTF: Unknown version ${json.asset.version}`);\n                return;\n        }\n        if (!options.normalize) {\n            // We are still missing a few conversion tricks, remove once addressed\n            throw new Error('glTF v1 is not supported.');\n        }\n        // eslint-disable-next-line no-undef, no-console\n        console.warn('Converting glTF v1 to glTF v2 format. This is experimental and may fail.');\n        this._addAsset(json);\n        // In glTF2 top-level fields are Arrays not Object maps\n        this._convertTopLevelObjectsToArrays(json);\n        // Extract bufferView indices for images\n        // (this extension needs to be invoked early in the normalization process)\n        // TODO can this be handled by standard extension processing instead of called explicitly?\n        KHR_binary_glTF.preprocess(gltf);\n        // Convert object references from ids to indices\n        this._convertObjectIdsToArrayIndices(json);\n        this._updateObjects(json);\n        this._updateMaterial(json);\n    }\n    // asset is now required, #642 https://github.com/KhronosGroup/glTF/issues/639\n    _addAsset(json) {\n        json.asset = json.asset || {};\n        // We are normalizing to glTF v2, so change version to \"2.0\"\n        json.asset.version = '2.0';\n        json.asset.generator = json.asset.generator || 'Normalized to glTF 2.0 by loaders.gl';\n    }\n    _convertTopLevelObjectsToArrays(json) {\n        // TODO check that all arrays are covered\n        for (const arrayName in GLTF_ARRAYS) {\n            this._convertTopLevelObjectToArray(json, arrayName);\n        }\n    }\n    /** Convert one top level object to array */\n    _convertTopLevelObjectToArray(json, mapName) {\n        const objectMap = json[mapName];\n        if (!objectMap || Array.isArray(objectMap)) {\n            return;\n        }\n        // Rewrite the top-level field as an array\n        json[mapName] = [];\n        // Copy the map key into object.id\n        for (const id in objectMap) {\n            const object = objectMap[id];\n            object.id = object.id || id; // Mutates the loaded object\n            const index = json[mapName].length;\n            json[mapName].push(object);\n            this.idToIndexMap[mapName][id] = index;\n        }\n    }\n    /** Go through all objects in all top-level arrays and replace ids with indices */\n    _convertObjectIdsToArrayIndices(json) {\n        for (const arrayName in GLTF_ARRAYS) {\n            this._convertIdsToIndices(json, arrayName);\n        }\n        if ('scene' in json) {\n            json.scene = this._convertIdToIndex(json.scene, 'scene');\n        }\n        // Convert any index references that are not using array names\n        // texture.source (image)\n        for (const texture of json.textures) {\n            this._convertTextureIds(texture);\n        }\n        for (const mesh of json.meshes) {\n            this._convertMeshIds(mesh);\n        }\n        for (const node of json.nodes) {\n            this._convertNodeIds(node);\n        }\n        for (const node of json.scenes) {\n            this._convertSceneIds(node);\n        }\n    }\n    _convertTextureIds(texture) {\n        if (texture.source) {\n            texture.source = this._convertIdToIndex(texture.source, 'image');\n        }\n    }\n    _convertMeshIds(mesh) {\n        for (const primitive of mesh.primitives) {\n            const { attributes, indices, material } = primitive;\n            for (const attributeName in attributes) {\n                attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], 'accessor');\n            }\n            if (indices) {\n                primitive.indices = this._convertIdToIndex(indices, 'accessor');\n            }\n            if (material) {\n                primitive.material = this._convertIdToIndex(material, 'material');\n            }\n        }\n    }\n    _convertNodeIds(node) {\n        if (node.children) {\n            node.children = node.children.map((child) => this._convertIdToIndex(child, 'node'));\n        }\n        if (node.meshes) {\n            node.meshes = node.meshes.map((mesh) => this._convertIdToIndex(mesh, 'mesh'));\n        }\n    }\n    _convertSceneIds(scene) {\n        if (scene.nodes) {\n            scene.nodes = scene.nodes.map((node) => this._convertIdToIndex(node, 'node'));\n        }\n    }\n    /** Go through all objects in a top-level array and replace ids with indices */\n    _convertIdsToIndices(json, topLevelArrayName) {\n        if (!json[topLevelArrayName]) {\n            console.warn(`gltf v1: json doesn't contain attribute ${topLevelArrayName}`); // eslint-disable-line no-console, no-undef\n            json[topLevelArrayName] = [];\n        }\n        for (const object of json[topLevelArrayName]) {\n            for (const key in object) {\n                const id = object[key];\n                const index = this._convertIdToIndex(id, key);\n                object[key] = index;\n            }\n        }\n    }\n    _convertIdToIndex(id, key) {\n        const arrayName = GLTF_KEYS[key];\n        if (arrayName in this.idToIndexMap) {\n            const index = this.idToIndexMap[arrayName][id];\n            if (!Number.isFinite(index)) {\n                throw new Error(`gltf v1: failed to resolve ${key} with id ${id}`);\n            }\n            return index;\n        }\n        return id;\n    }\n    /**\n     *\n     * @param {*} json\n     */\n    _updateObjects(json) {\n        for (const buffer of this.json.buffers) {\n            // - [x] Removed buffer.type, #786, #629\n            delete buffer.type;\n        }\n    }\n    /**\n     * Update material (set pbrMetallicRoughness)\n     * @param {*} json\n     */\n    _updateMaterial(json) {\n        for (const material of json.materials) {\n            material.pbrMetallicRoughness = {\n                baseColorFactor: [1, 1, 1, 1],\n                metallicFactor: 1,\n                roughnessFactor: 1\n            };\n            const textureId = material.values?.tex || material.values?.texture2d_0 || material.values?.diffuseTex;\n            const textureIndex = json.textures.findIndex((texture) => texture.id === textureId);\n            if (textureIndex !== -1) {\n                material.pbrMetallicRoughness.baseColorTexture = { index: textureIndex };\n            }\n        }\n    }\n}\nexport function normalizeGLTFV1(gltf, options = {}) {\n    return new GLTFV1Normalizer().normalize(gltf, options);\n}\n", "import { parseJSON, sliceArrayBuffer, parseFromContext } from '@loaders.gl/loader-utils';\nimport { ImageLoader } from '@loaders.gl/images';\nimport { BasisLoader, selectSupportedBasisFormat } from '@loaders.gl/textures';\nimport { assert } from \"../utils/assert.js\";\nimport { isGLB, parseGLBSync } from \"./parse-glb.js\";\nimport { resolveUrl } from \"../gltf-utils/resolve-url.js\";\nimport { getTypedArrayForBufferView } from \"../gltf-utils/get-typed-array.js\";\nimport { preprocessExtensions, decodeExtensions } from \"../api/gltf-extensions.js\";\nimport { normalizeGLTFV1 } from \"../api/normalize-gltf-v1.js\";\n/** Check if an array buffer appears to contain GLTF data */\nexport function isGLTF(arrayBuffer, options) {\n    const byteOffset = 0;\n    return isGLB(arrayBuffer, byteOffset, options);\n}\nexport async function parseGLTF(gltf, arrayBufferOrString, byteOffset = 0, options, context) {\n    parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n    normalizeGLTFV1(gltf, { normalize: options?.gltf?.normalize });\n    preprocessExtensions(gltf, options, context);\n    // Load linked buffers asynchronously and decodes base64 buffers in parallel\n    if (options?.gltf?.loadBuffers && gltf.json.buffers) {\n        await loadBuffers(gltf, options, context);\n    }\n    // loadImages and decodeExtensions should not be running in parallel, because\n    // decodeExtensions uses data from images taken during the loadImages call.\n    if (options?.gltf?.loadImages) {\n        await loadImages(gltf, options, context);\n    }\n    await decodeExtensions(gltf, options, context);\n    return gltf;\n}\n/**\n *\n * @param gltf\n * @param data - can be ArrayBuffer (GLB), ArrayBuffer (Binary JSON), String (JSON), or Object (parsed JSON)\n * @param byteOffset\n * @param options\n */\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n    // Initialize gltf container\n    if (options.uri) {\n        gltf.baseUri = options.uri;\n    }\n    // If data is binary and starting with magic bytes, assume binary JSON text, convert to string\n    if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n        const textDecoder = new TextDecoder();\n        data = textDecoder.decode(data);\n    }\n    if (typeof data === 'string') {\n        // If string, try to parse as JSON\n        gltf.json = parseJSON(data);\n    }\n    else if (data instanceof ArrayBuffer) {\n        // If still ArrayBuffer, parse as GLB container\n        const glb = {};\n        byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);\n        assert(glb.type === 'glTF', `Invalid GLB magic string ${glb.type}`);\n        gltf._glb = glb;\n        gltf.json = glb.json;\n    }\n    else {\n        assert(false, 'GLTF: must be ArrayBuffer or string');\n    }\n    // Populate buffers\n    // Create an external buffers array to hold binary data\n    const buffers = gltf.json.buffers || [];\n    gltf.buffers = new Array(buffers.length).fill(null);\n    // Populates JSON and some bin chunk info\n    if (gltf._glb && gltf._glb.header.hasBinChunk) {\n        const { binChunks } = gltf._glb;\n        gltf.buffers[0] = {\n            arrayBuffer: binChunks[0].arrayBuffer,\n            byteOffset: binChunks[0].byteOffset,\n            byteLength: binChunks[0].byteLength\n        };\n        // TODO - this modifies JSON and is a post processing thing\n        // gltf.json.buffers[0].data = gltf.buffers[0].arrayBuffer;\n        // gltf.json.buffers[0].byteOffset = gltf.buffers[0].byteOffset;\n    }\n    // Populate images\n    const images = gltf.json.images || [];\n    gltf.images = new Array(images.length).fill({});\n}\n/** Asynchronously fetch and parse buffers, store in buffers array outside of json\n * TODO - traverse gltf and determine which buffers are actually needed\n */\nasync function loadBuffers(gltf, options, context) {\n    // TODO\n    const buffers = gltf.json.buffers || [];\n    for (let i = 0; i < buffers.length; ++i) {\n        const buffer = buffers[i];\n        if (buffer.uri) {\n            const { fetch } = context;\n            assert(fetch);\n            const uri = resolveUrl(buffer.uri, options);\n            const response = await context?.fetch?.(uri);\n            const arrayBuffer = await response?.arrayBuffer?.();\n            gltf.buffers[i] = {\n                arrayBuffer,\n                byteOffset: 0,\n                byteLength: arrayBuffer.byteLength\n            };\n            delete buffer.uri;\n        }\n        else if (gltf.buffers[i] === null) {\n            gltf.buffers[i] = {\n                arrayBuffer: new ArrayBuffer(buffer.byteLength),\n                byteOffset: 0,\n                byteLength: buffer.byteLength\n            };\n        }\n    }\n}\n/**\n * Loads all images\n * TODO - traverse gltf and determine which images are actually needed\n * @param gltf\n * @param options\n * @param context\n * @returns\n */\nasync function loadImages(gltf, options, context) {\n    const imageIndices = getReferencesImageIndices(gltf);\n    const images = gltf.json.images || [];\n    const promises = [];\n    for (const imageIndex of imageIndices) {\n        promises.push(loadImage(gltf, images[imageIndex], imageIndex, options, context));\n    }\n    return await Promise.all(promises);\n}\n/** Make sure we only load images that are actually referenced by textures */\nfunction getReferencesImageIndices(gltf) {\n    const imageIndices = new Set();\n    const textures = gltf.json.textures || [];\n    for (const texture of textures) {\n        if (texture.source !== undefined) {\n            imageIndices.add(texture.source);\n        }\n    }\n    return Array.from(imageIndices).sort();\n}\n/** Asynchronously fetches and parses one image, store in images array outside of json */\nasync function loadImage(gltf, image, index, options, context) {\n    let arrayBuffer;\n    if (image.uri && !image.hasOwnProperty('bufferView')) {\n        const uri = resolveUrl(image.uri, options);\n        const { fetch } = context;\n        const response = await fetch(uri);\n        arrayBuffer = await response.arrayBuffer();\n        image.bufferView = {\n            data: arrayBuffer\n        };\n    }\n    if (Number.isFinite(image.bufferView)) {\n        const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n        arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);\n    }\n    assert(arrayBuffer, 'glTF image has no data');\n    // Call `parse`\n    let parsedImage = (await parseFromContext(arrayBuffer, [ImageLoader, BasisLoader], {\n        ...options,\n        mimeType: image.mimeType,\n        basis: options.basis || { format: selectSupportedBasisFormat() }\n    }, context));\n    if (parsedImage && parsedImage[0]) {\n        parsedImage = {\n            compressed: true,\n            // @ts-expect-error\n            mipmaps: false,\n            width: parsedImage[0].width,\n            height: parsedImage[0].height,\n            data: parsedImage[0]\n        };\n    }\n    // TODO making sure ImageLoader is overridable by using array of loaders\n    // const parsedImage = await parse(arrayBuffer, [ImageLoader]);\n    // Store the loaded image\n    gltf.images = gltf.images || [];\n    // @ts-expect-error TODO - sort out image typing asap\n    gltf.images[index] = parsedImage;\n}\n", "import { VERSION } from \"./lib/utils/version.js\";\nimport { parseGLTF } from \"./lib/parsers/parse-gltf.js\";\n/**\n * GLTF loader\n */\nexport const GLTFLoader = {\n    dataType: null,\n    batchType: null,\n    name: 'glTF',\n    id: 'gltf',\n    module: 'gltf',\n    version: VERSION,\n    extensions: ['gltf', 'glb'],\n    mimeTypes: ['model/gltf+json', 'model/gltf-binary'],\n    text: true,\n    binary: true,\n    tests: ['glTF'],\n    parse,\n    options: {\n        gltf: {\n            normalize: true, // Normalize glTF v1 to glTF v2 format (not yet stable)\n            loadBuffers: true, // Fetch any linked .BIN buffers, decode base64\n            loadImages: true, // Create image objects\n            decompressMeshes: true // Decompress Draco encoded meshes\n        },\n        // common?\n        log: console // eslint-disable-line\n    }\n};\nexport async function parse(arrayBuffer, options = {}, context) {\n    // Apps can call the parse method directly, we so apply default options here\n    options = { ...GLTFLoader.options, ...options };\n    // @ts-ignore\n    options.gltf = { ...GLTFLoader.options.gltf, ...options.gltf };\n    const { byteOffset = 0 } = options;\n    const gltf = {};\n    return await parseGLTF(gltf, arrayBuffer, byteOffset, options, context);\n}\n", "// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { assert } from \"../utils/assert.js\";\nimport { getAccessorArrayTypeAndLength } from \"../gltf-utils/gltf-utils.js\";\n// This is a post processor for loaded glTF files\n// The goal is to make the loaded data easier to use in WebGL applications\n//\n// Functions:\n// * Resolve indexed arrays structure of glTF into a linked tree.\n// * Translate stringified enum keys and values into WebGL constants.\n// * Load images (optional)\n// ENUM LOOKUP\nconst COMPONENTS = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16\n};\nconst BYTES = {\n    5120: 1, // BYTE\n    5121: 1, // UNSIGNED_BYTE\n    5122: 2, // SHORT\n    5123: 2, // UNSIGNED_SHORT\n    5125: 4, // UNSIGNED_INT\n    5126: 4 // FLOAT\n};\nconst GL_SAMPLER = {\n    // Sampler parameters\n    TEXTURE_MAG_FILTER: 0x2800,\n    TEXTURE_MIN_FILTER: 0x2801,\n    TEXTURE_WRAP_S: 0x2802,\n    TEXTURE_WRAP_T: 0x2803,\n    // Sampler default values\n    REPEAT: 0x2901,\n    LINEAR: 0x2601,\n    NEAREST_MIPMAP_LINEAR: 0x2702\n};\nconst SAMPLER_PARAMETER_GLTF_TO_GL = {\n    magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,\n    minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,\n    wrapS: GL_SAMPLER.TEXTURE_WRAP_S,\n    wrapT: GL_SAMPLER.TEXTURE_WRAP_T\n};\n// When undefined, a sampler with repeat wrapping and auto filtering should be used.\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\nconst DEFAULT_SAMPLER_PARAMETERS = {\n    [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,\n    [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,\n    [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,\n    [GL_SAMPLER.TEXTURE_WRAP_T]: GL_SAMPLER.REPEAT\n};\nfunction makeDefaultSampler() {\n    return {\n        id: 'default-sampler',\n        parameters: DEFAULT_SAMPLER_PARAMETERS\n    };\n}\nfunction getBytesFromComponentType(componentType) {\n    return BYTES[componentType];\n}\nfunction getSizeFromAccessorType(type) {\n    return COMPONENTS[type];\n}\nclass GLTFPostProcessor {\n    baseUri = '';\n    // @ts-expect-error\n    jsonUnprocessed;\n    // @ts-expect-error\n    json;\n    buffers = [];\n    images = [];\n    postProcess(gltf, options = {}) {\n        const { json, buffers = [], images = [] } = gltf;\n        // @ts-expect-error\n        const { baseUri = '' } = gltf;\n        assert(json);\n        this.baseUri = baseUri;\n        this.buffers = buffers;\n        this.images = images;\n        this.jsonUnprocessed = json;\n        this.json = this._resolveTree(gltf.json, options);\n        return this.json;\n    }\n    // Convert indexed glTF structure into tree structure\n    // cross-link index resolution, enum lookup, convenience calculations\n    // eslint-disable-next-line complexity, max-statements\n    _resolveTree(gltf, options = {}) {\n        // @ts-expect-error\n        const json = { ...gltf };\n        this.json = json;\n        if (gltf.bufferViews) {\n            json.bufferViews = gltf.bufferViews.map((bufView, i) => this._resolveBufferView(bufView, i));\n        }\n        if (gltf.images) {\n            json.images = gltf.images.map((image, i) => this._resolveImage(image, i));\n        }\n        if (gltf.samplers) {\n            json.samplers = gltf.samplers.map((sampler, i) => this._resolveSampler(sampler, i));\n        }\n        if (gltf.textures) {\n            json.textures = gltf.textures.map((texture, i) => this._resolveTexture(texture, i));\n        }\n        if (gltf.accessors) {\n            json.accessors = gltf.accessors.map((accessor, i) => this._resolveAccessor(accessor, i));\n        }\n        if (gltf.materials) {\n            json.materials = gltf.materials.map((material, i) => this._resolveMaterial(material, i));\n        }\n        if (gltf.meshes) {\n            json.meshes = gltf.meshes.map((mesh, i) => this._resolveMesh(mesh, i));\n        }\n        if (gltf.nodes) {\n            json.nodes = gltf.nodes.map((node, i) => this._resolveNode(node, i));\n            json.nodes = json.nodes.map((node, i) => this._resolveNodeChildren(node));\n        }\n        if (gltf.skins) {\n            json.skins = gltf.skins.map((skin, i) => this._resolveSkin(skin, i));\n        }\n        if (gltf.scenes) {\n            json.scenes = gltf.scenes.map((scene, i) => this._resolveScene(scene, i));\n        }\n        if (typeof this.json.scene === 'number' && json.scenes) {\n            json.scene = json.scenes[this.json.scene];\n        }\n        return json;\n    }\n    getScene(index) {\n        return this._get(this.json.scenes, index);\n    }\n    getNode(index) {\n        return this._get(this.json.nodes, index);\n    }\n    getSkin(index) {\n        return this._get(this.json.skins, index);\n    }\n    getMesh(index) {\n        return this._get(this.json.meshes, index);\n    }\n    getMaterial(index) {\n        return this._get(this.json.materials, index);\n    }\n    getAccessor(index) {\n        return this._get(this.json.accessors, index);\n    }\n    getCamera(index) {\n        return this._get(this.json.cameras, index);\n    }\n    getTexture(index) {\n        return this._get(this.json.textures, index);\n    }\n    getSampler(index) {\n        return this._get(this.json.samplers, index);\n    }\n    getImage(index) {\n        return this._get(this.json.images, index);\n    }\n    getBufferView(index) {\n        return this._get(this.json.bufferViews, index);\n    }\n    getBuffer(index) {\n        return this._get(this.json.buffers, index);\n    }\n    _get(array, index) {\n        // check if already resolved\n        if (typeof index === 'object') {\n            return index;\n        }\n        const object = array && array[index];\n        if (!object) {\n            console.warn(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n        }\n        return object;\n    }\n    // PARSING HELPERS\n    _resolveScene(scene, index) {\n        return {\n            ...scene,\n            // @ts-ignore\n            id: scene.id || `scene-${index}`,\n            nodes: (scene.nodes || []).map((node) => this.getNode(node))\n        };\n    }\n    _resolveNode(gltfNode, index) {\n        // @ts-expect-error\n        const node = {\n            ...gltfNode,\n            // @ts-expect-error id could already be present, glTF standard does not prevent it\n            id: gltfNode?.id || `node-${index}`\n        };\n        if (gltfNode.mesh !== undefined) {\n            node.mesh = this.getMesh(gltfNode.mesh);\n        }\n        if (gltfNode.camera !== undefined) {\n            node.camera = this.getCamera(gltfNode.camera);\n        }\n        if (gltfNode.skin !== undefined) {\n            node.skin = this.getSkin(gltfNode.skin);\n        }\n        // TODO deprecated - Delete in v4.0?\n        // @ts-expect-error node.meshes does not seem to be part of the GLTF standard\n        if (gltfNode.meshes !== undefined && gltfNode.meshes.length) {\n            // @ts-expect-error\n            node.mesh = gltfNode.meshes.reduce((accum, meshIndex) => {\n                const mesh = this.getMesh(meshIndex);\n                accum.id = mesh.id;\n                accum.primitives = accum.primitives.concat(mesh.primitives);\n                return accum;\n            }, { primitives: [] });\n        }\n        return node;\n    }\n    _resolveNodeChildren(node) {\n        if (node.children) {\n            // @ts-expect-error node.children are numbers at this stage\n            node.children = node.children.map((child) => this.getNode(child));\n        }\n        return node;\n    }\n    _resolveSkin(gltfSkin, index) {\n        const inverseBindMatrices = typeof gltfSkin.inverseBindMatrices === 'number'\n            ? this.getAccessor(gltfSkin.inverseBindMatrices)\n            : undefined;\n        return {\n            ...gltfSkin,\n            id: gltfSkin.id || `skin-${index}`,\n            inverseBindMatrices\n        };\n    }\n    _resolveMesh(gltfMesh, index) {\n        const mesh = {\n            ...gltfMesh,\n            id: gltfMesh.id || `mesh-${index}`,\n            primitives: []\n        };\n        if (gltfMesh.primitives) {\n            mesh.primitives = gltfMesh.primitives.map((gltfPrimitive) => {\n                const primitive = {\n                    ...gltfPrimitive,\n                    attributes: {},\n                    indices: undefined,\n                    material: undefined\n                };\n                const attributes = gltfPrimitive.attributes;\n                for (const attribute in attributes) {\n                    primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);\n                }\n                if (gltfPrimitive.indices !== undefined) {\n                    primitive.indices = this.getAccessor(gltfPrimitive.indices);\n                }\n                if (gltfPrimitive.material !== undefined) {\n                    primitive.material = this.getMaterial(gltfPrimitive.material);\n                }\n                return primitive;\n            });\n        }\n        return mesh;\n    }\n    _resolveMaterial(gltfMaterial, index) {\n        // @ts-expect-error\n        const material = {\n            ...gltfMaterial,\n            // @ts-expect-error\n            id: gltfMaterial.id || `material-${index}`\n        };\n        if (material.normalTexture) {\n            material.normalTexture = { ...material.normalTexture };\n            material.normalTexture.texture = this.getTexture(material.normalTexture.index);\n        }\n        if (material.occlusionTexture) {\n            material.occlusionTexture = { ...material.occlusionTexture };\n            material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);\n        }\n        if (material.emissiveTexture) {\n            material.emissiveTexture = { ...material.emissiveTexture };\n            material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);\n        }\n        if (!material.emissiveFactor) {\n            material.emissiveFactor = material.emissiveTexture ? [1, 1, 1] : [0, 0, 0];\n        }\n        if (material.pbrMetallicRoughness) {\n            material.pbrMetallicRoughness = { ...material.pbrMetallicRoughness };\n            const mr = material.pbrMetallicRoughness;\n            if (mr.baseColorTexture) {\n                mr.baseColorTexture = { ...mr.baseColorTexture };\n                mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);\n            }\n            if (mr.metallicRoughnessTexture) {\n                mr.metallicRoughnessTexture = { ...mr.metallicRoughnessTexture };\n                mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);\n            }\n        }\n        return material;\n    }\n    _resolveAccessor(gltfAccessor, index) {\n        // Look up enums\n        const bytesPerComponent = getBytesFromComponentType(gltfAccessor.componentType);\n        const components = getSizeFromAccessorType(gltfAccessor.type);\n        const bytesPerElement = bytesPerComponent * components;\n        const accessor = {\n            ...gltfAccessor,\n            // @ts-expect-error\n            id: gltfAccessor.id || `accessor-${index}`,\n            bytesPerComponent,\n            components,\n            bytesPerElement,\n            value: undefined,\n            bufferView: undefined,\n            sparse: undefined\n        };\n        if (gltfAccessor.bufferView !== undefined) {\n            // Draco encoded meshes don't have bufferView\n            accessor.bufferView = this.getBufferView(gltfAccessor.bufferView);\n        }\n        // Create TypedArray for the accessor\n        // Note: The canonical way to instantiate is to ignore this array and create\n        // WebGLBuffer's using the bufferViews.\n        if (accessor.bufferView) {\n            const buffer = accessor.bufferView.buffer;\n            const { ArrayType, byteLength } = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);\n            const byteOffset = (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;\n            let cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n            if (accessor.bufferView.byteStride) {\n                cutBuffer = this._getValueFromInterleavedBuffer(buffer, byteOffset, accessor.bufferView.byteStride, accessor.bytesPerElement, accessor.count);\n            }\n            accessor.value = new ArrayType(cutBuffer);\n        }\n        return accessor;\n    }\n    /**\n     * Take values of particular accessor from interleaved buffer\n     * various parts of the buffer\n     * @param buffer\n     * @param byteOffset\n     * @param byteStride\n     * @param bytesPerElement\n     * @param count\n     * @returns\n     */\n    _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count) {\n        const result = new Uint8Array(count * bytesPerElement);\n        for (let i = 0; i < count; i++) {\n            const elementOffset = byteOffset + i * byteStride;\n            result.set(new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)), i * bytesPerElement);\n        }\n        return result.buffer;\n    }\n    _resolveTexture(gltfTexture, index) {\n        return {\n            ...gltfTexture,\n            // @ts-expect-error id could already be present, glTF standard does not prevent it\n            id: gltfTexture.id || `texture-${index}`,\n            sampler: typeof gltfTexture.sampler === 'number'\n                ? this.getSampler(gltfTexture.sampler)\n                : makeDefaultSampler(),\n            source: typeof gltfTexture.source === 'number' ? this.getImage(gltfTexture.source) : undefined\n        };\n    }\n    _resolveSampler(gltfSampler, index) {\n        const sampler = {\n            // @ts-expect-error id could already be present, glTF standard does not prevent it\n            id: gltfSampler.id || `sampler-${index}`,\n            ...gltfSampler,\n            parameters: {}\n        };\n        // Map textual parameters to GL parameter values\n        for (const key in sampler) {\n            const glEnum = this._enumSamplerParameter(key);\n            if (glEnum !== undefined) {\n                sampler.parameters[glEnum] = sampler[key];\n            }\n        }\n        return sampler;\n    }\n    _enumSamplerParameter(key) {\n        return SAMPLER_PARAMETER_GLTF_TO_GL[key];\n    }\n    _resolveImage(gltfImage, index) {\n        const image = {\n            ...gltfImage,\n            // @ts-expect-error id could already be present, glTF standard does not prevent it\n            id: gltfImage.id || `image-${index}`,\n            image: null,\n            bufferView: gltfImage.bufferView !== undefined ? this.getBufferView(gltfImage.bufferView) : undefined\n        };\n        // Check if image has been preloaded by the GLTFLoader\n        // If so, link it into the JSON and drop the URI\n        const preloadedImage = this.images[index];\n        if (preloadedImage) {\n            image.image = preloadedImage;\n        }\n        return image;\n    }\n    _resolveBufferView(gltfBufferView, index) {\n        const bufferIndex = gltfBufferView.buffer;\n        const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;\n        // Add offset of buffer, then offset of buffer view\n        let byteOffset = this.buffers[bufferIndex].byteOffset || 0;\n        if (gltfBufferView.byteOffset) {\n            byteOffset += gltfBufferView.byteOffset;\n        }\n        const bufferView = {\n            // // @ts-expect-error id could already be present, glTF standard does not prevent it\n            id: `bufferView-${index}`,\n            ...gltfBufferView,\n            // ...this.buffers[bufferIndex],\n            buffer: this.buffers[bufferIndex],\n            data: new Uint8Array(arrayBuffer, byteOffset, gltfBufferView.byteLength)\n        };\n        return bufferView;\n    }\n    _resolveCamera(gltfCamera, index) {\n        const camera = {\n            ...gltfCamera,\n            // @ts-expect-error id could already be present, glTF standard does not prevent it\n            id: gltfCamera.id || `camera-${index}`\n        };\n        // TODO - create 4x4 matrices\n        if (camera.perspective) {\n            // camera.matrix = createPerspectiveMatrix(camera.perspective);\n        }\n        if (camera.orthographic) {\n            // camera.matrix = createOrthographicMatrix(camera.orthographic);\n        }\n        return camera;\n    }\n}\nexport function postProcessGLTF(gltf, options) {\n    return new GLTFPostProcessor().postProcess(gltf, options);\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* global requestAnimationFrame */\nimport type {GroupNode, ScenegraphNode, ModelNode} from '@luma.gl/engine';\n\nexport async function waitForGLTFAssets(gltfObjects: {scenes: GroupNode[]}): Promise<void> {\n  const remaining: any[] = [];\n\n  gltfObjects.scenes.forEach(scene => {\n    scene.traverse((modelNode: ScenegraphNode) => {\n      // Not really clear how we can access the uniforms?\n      // TODO v9 getUnforms() was removed, hack it with props.uniforms\n      // Object.values((modelNode as ModelNode).model.uniforms).forEach((uniform: any) => {\n      //   if (uniform.loaded === false) {\n      //     remaining.push(uniform);\n      //   }\n      // });\n    });\n  });\n\n  return await waitWhileCondition(() => remaining.some(uniform => !uniform.loaded));\n}\n\nasync function waitWhileCondition(condition: () => boolean): Promise<void> {\n  while (condition()) {\n    await new Promise(resolve => requestAnimationFrame(resolve));\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Matrix4} from '@math.gl/core';\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\nconst uniformBlock = `\\\nuniform scenegraphUniforms {\n  float sizeScale;\n  float sizeMinPixels;\n  float sizeMaxPixels;\n  mat4 sceneModelMatrix;\n  bool composeModelMatrix;\n} scenegraph;\n`;\n\nexport type ScenegraphProps = {\n  sizeScale: number;\n  sizeMinPixels: number;\n  sizeMaxPixels: number;\n  sceneModelMatrix: Matrix4;\n  composeModelMatrix: boolean;\n};\n\nexport const scenegraphUniforms = {\n  name: 'scenegraph',\n  vs: uniformBlock,\n  fs: uniformBlock,\n  uniformTypes: {\n    sizeScale: 'f32',\n    sizeMinPixels: 'f32',\n    sizeMaxPixels: 'f32',\n    sceneModelMatrix: 'mat4x4<f32>',\n    composeModelMatrix: 'f32'\n  }\n} as const satisfies ShaderModule<ScenegraphProps>;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport default `\\\n#version 300 es\n\n#define SHADER_NAME scenegraph-layer-vertex-shader\n\n// Instance attributes\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin vec3 instanceModelMatrixCol0;\nin vec3 instanceModelMatrixCol1;\nin vec3 instanceModelMatrixCol2;\nin vec3 instanceTranslation;\n\n// Primitive attributes\nin vec3 positions;\n#ifdef HAS_UV\n  in vec2 texCoords;\n#endif\n#ifdef LIGHTING_PBR\n  #ifdef HAS_NORMALS\n    in vec3 normals;\n  #endif\n#endif\n\n// Varying\nout vec4 vColor;\n\n// pbrMaterial contains all the varying definitions needed\n#ifndef LIGHTING_PBR\n  #ifdef HAS_UV\n    out vec2 vTEXCOORD_0;\n  #endif\n#endif\n\n// Main\nvoid main(void) {\n  #if defined(HAS_UV) && !defined(LIGHTING_PBR)\n    vTEXCOORD_0 = texCoords;\n    geometry.uv = texCoords;\n  #endif\n\n  geometry.worldPosition = instancePositions;\n  geometry.pickingColor = instancePickingColors;\n\n  mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);\n\n  vec3 normal = vec3(0.0, 0.0, 1.0);\n  #ifdef LIGHTING_PBR\n    #ifdef HAS_NORMALS\n      normal = instanceModelMatrix * (scenegraph.sceneModelMatrix * vec4(normals, 0.0)).xyz;\n    #endif\n  #endif\n\n  float originalSize = project_size_to_pixel(scenegraph.sizeScale);\n  float clampedSize = clamp(originalSize, scenegraph.sizeMinPixels, scenegraph.sizeMaxPixels);\n\n  vec3 pos = (instanceModelMatrix * (scenegraph.sceneModelMatrix * vec4(positions, 1.0)).xyz) * scenegraph.sizeScale * (clampedSize / originalSize) + instanceTranslation;\n  if(scenegraph.composeModelMatrix) {\n    DECKGL_FILTER_SIZE(pos, geometry);\n    // using instancePositions as world coordinates\n    // when using globe mode, this branch does not re-orient the model to align with the surface of the earth\n    // call project_normal before setting position to avoid rotation\n    geometry.normal = project_normal(normal);\n    geometry.worldPosition += pos;\n    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n  }\n  else {\n    pos = project_size(pos);\n    DECKGL_FILTER_SIZE(pos, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);\n    geometry.normal = project_normal(normal);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  #ifdef LIGHTING_PBR\n    // set PBR data\n    pbr_vPosition = geometry.position.xyz;\n    #ifdef HAS_NORMALS\n      pbr_vNormal = geometry.normal;\n    #endif\n\n    #ifdef HAS_UV\n      pbr_vUV = texCoords;\n    #else\n      pbr_vUV = vec2(0., 0.);\n    #endif\n    geometry.uv = pbr_vUV;\n  #endif\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport default `\\\n#version 300 es\n\n#define SHADER_NAME scenegraph-layer-fragment-shader\n\n// Varying\nin vec4 vColor;\n\nout vec4 fragColor;\n\n// pbrMaterial contains all the varying definitions needed\n#ifndef LIGHTING_PBR\n  #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\n    in vec2 vTEXCOORD_0;\n    uniform sampler2D pbr_baseColorSampler;\n  #endif\n#endif\n\nvoid main(void) {\n  #ifdef LIGHTING_PBR\n    fragColor = vColor * pbr_filterColor(vec4(0));\n    geometry.uv = pbr_vUV;\n  #else\n    #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\n      fragColor = vColor * texture(pbr_baseColorSampler, vTEXCOORD_0);\n      geometry.uv = vTEXCOORD_0;\n    #else\n      fragColor = vColor;\n    #endif\n  #endif\n\n  fragColor.a *= layer.opacity;\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n`;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Layer, project32, picking, log} from '@deck.gl/core';\nimport type {Device} from '@luma.gl/core';\nimport {pbrMaterial} from '@luma.gl/shadertools';\nimport {ScenegraphNode, GroupNode, ModelNode, Model} from '@luma.gl/engine';\nimport {GLTFAnimator, PBREnvironment, createScenegraphsFromGLTF} from '@luma.gl/gltf';\nimport {GLTFLoader, postProcessGLTF} from '@loaders.gl/gltf';\nimport {waitForGLTFAssets} from './gltf-utils';\n\nimport {MATRIX_ATTRIBUTES, shouldComposeModelMatrix} from '../utils/matrix';\n\nimport {scenegraphUniforms, ScenegraphProps} from './scenegraph-layer-uniforms';\nimport vs from './scenegraph-layer-vertex.glsl';\nimport fs from './scenegraph-layer-fragment.glsl';\n\nimport {\n  UpdateParameters,\n  LayerContext,\n  LayerProps,\n  LayerDataSource,\n  Position,\n  Color,\n  Accessor,\n  DefaultProps\n} from '@deck.gl/core';\n\ntype GLTFInstantiatorOptions = Parameters<typeof createScenegraphsFromGLTF>[2];\n\nconst DEFAULT_COLOR: [number, number, number, number] = [255, 255, 255, 255];\n\nexport type ScenegraphLayerProps<DataT = unknown> = _ScenegraphLayerProps<DataT> & LayerProps;\n\ntype _ScenegraphLayerProps<DataT> = {\n  data: LayerDataSource<DataT>;\n  // TODO - define in luma.gl\n  /**\n   * A url for a glTF model or scenegraph loaded via a [scenegraph loader](https://loaders.gl/docs/specifications/category-scenegraph)\n   */\n  scenegraph: any;\n  /**\n   * Create a luma.gl GroupNode from the resolved scenegraph prop\n   */\n  getScene?: (\n    scenegraph: any,\n    context: {device?: Device; layer: ScenegraphLayer<DataT>}\n  ) => GroupNode;\n  /**\n   * Create a luma.gl GLTFAnimator from the resolved scenegraph prop\n   */\n  getAnimator?: (\n    scenegraph: any,\n    context: {device?: Device; layer: ScenegraphLayer<DataT>}\n  ) => GLTFAnimator;\n  /**\n   * (Experimental) animation configurations. Requires `_animate` on deck object.\n   */\n  _animations?: {\n    [name: number | string | '*']: {\n      /** If the animation is playing */\n      playing?: boolean;\n      /** Start time of the animation, default `0` */\n      startTime?: number;\n      /** Speed multiplier of the animation, default `1` */\n      speed?: number;\n    };\n  } | null;\n  /**\n   * (Experimental) lighting mode\n   * @default 'flat'\n   */\n  _lighting?: 'flat' | 'pbr';\n  /**\n   * (Experimental) lighting environment. Requires `_lighting` to be `'pbr'`.\n   */\n  _imageBasedLightingEnvironment?:\n    | PBREnvironment\n    | ((context: {gl: WebGL2RenderingContext; layer: ScenegraphLayer<DataT>}) => PBREnvironment);\n\n  /** Anchor position accessor. */\n  getPosition?: Accessor<DataT, Position>;\n  /** Color value or accessor.\n   * @default [255, 255, 255, 255]\n   */\n  getColor?: Accessor<DataT, Color>;\n  /**\n   * Orientation in [pitch, yaw, roll] in degrees.\n   * @see https://en.wikipedia.org/wiki/Euler_angles\n   * @default [0, 0, 0]\n   */\n  getOrientation?: Accessor<DataT, [number, number, number]>;\n  /**\n   * Scaling factor of the model along each axis.\n   * @default [1, 1, 1]\n   */\n  getScale?: Accessor<DataT, [number, number, number]>;\n  /**\n   * Translation from the anchor point, [x, y, z] in meters.\n   * @default [0, 0, 0]\n   */\n  getTranslation?: Accessor<DataT, [number, number, number]>;\n  /**\n   * TransformMatrix. If specified, `getOrientation`, `getScale` and `getTranslation` are ignored.\n   */\n  getTransformMatrix?: Accessor<DataT, number[]>;\n  /**\n   * Multiplier to scale each geometry by.\n   * @default 1\n   */\n  sizeScale?: number;\n  /**\n   * The minimum size in pixels for one unit of the scene.\n   * @default 0\n   */\n  sizeMinPixels?: number;\n  /**\n   * The maximum size in pixels for one unit of the scene.\n   * @default Number.MAX_SAFE_INTEGER\n   */\n  sizeMaxPixels?: number;\n};\n\nconst defaultProps: DefaultProps<ScenegraphLayerProps> = {\n  scenegraph: {type: 'object', value: null, async: true},\n  getScene: gltf => {\n    if (gltf && gltf.scenes) {\n      // gltf post processor replaces `gltf.scene` number with the scene `object`\n      return typeof gltf.scene === 'object' ? gltf.scene : gltf.scenes[gltf.scene || 0];\n    }\n    return gltf;\n  },\n  getAnimator: scenegraph => scenegraph && scenegraph.animator,\n  _animations: null,\n\n  sizeScale: {type: 'number', value: 1, min: 0},\n  sizeMinPixels: {type: 'number', min: 0, value: 0},\n  sizeMaxPixels: {type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER},\n\n  getPosition: {type: 'accessor', value: (x: any) => x.position},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n\n  // flat or pbr\n  _lighting: 'flat',\n  // _lighting must be pbr for this to work\n  _imageBasedLightingEnvironment: undefined,\n\n  // yaw, pitch and roll are in degrees\n  // https://en.wikipedia.org/wiki/Euler_angles\n  // [pitch, yaw, roll]\n  getOrientation: {type: 'accessor', value: [0, 0, 0]},\n  getScale: {type: 'accessor', value: [1, 1, 1]},\n  getTranslation: {type: 'accessor', value: [0, 0, 0]},\n  // 4x4 matrix\n  getTransformMatrix: {type: 'accessor', value: []},\n\n  loaders: [GLTFLoader]\n};\n\n/** Render a number of instances of a complete glTF scenegraph. */\nexport default class ScenegraphLayer<DataT = any, ExtraPropsT extends {} = {}> extends Layer<\n  ExtraPropsT & Required<_ScenegraphLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'ScenegraphLayer';\n\n  state!: {\n    scenegraph: GroupNode;\n    animator: GLTFAnimator;\n    models: Model[];\n  };\n\n  getShaders() {\n    const defines: {LIGHTING_PBR?: 1} = {};\n    let pbr;\n\n    if (this.props._lighting === 'pbr') {\n      pbr = pbrMaterial;\n      defines.LIGHTING_PBR = 1;\n    } else {\n      // Dummy shader module needed to handle\n      // pbrMaterial.pbr_baseColorSampler binding\n      pbr = {name: 'pbrMaterial'};\n    }\n\n    const modules = [project32, picking, scenegraphUniforms, pbr];\n    return super.getShaders({defines, vs, fs, modules});\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    // attributeManager is always defined for primitive layers\n    attributeManager!.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: 'float64',\n        fp64: this.use64bitPositions(),\n        accessor: 'getPosition',\n        transition: true\n      },\n      instanceColors: {\n        type: 'unorm8',\n        size: this.props.colorFormat.length,\n        accessor: 'getColor',\n        defaultValue: DEFAULT_COLOR,\n        transition: true\n      },\n      instanceModelMatrix: MATRIX_ATTRIBUTES\n    });\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    super.updateState(params);\n    const {props, oldProps} = params;\n\n    if (props.scenegraph !== oldProps.scenegraph) {\n      this._updateScenegraph();\n    } else if (props._animations !== oldProps._animations) {\n      this._applyAnimationsProp(this.state.animator, props._animations);\n    }\n  }\n\n  finalizeState(context: LayerContext) {\n    super.finalizeState(context);\n    this.state.scenegraph?.destroy();\n  }\n\n  get isLoaded(): boolean {\n    return Boolean(this.state?.scenegraph && super.isLoaded);\n  }\n\n  private _updateScenegraph(): void {\n    const props = this.props;\n    const {device} = this.context;\n    let scenegraphData: any = null;\n    if (props.scenegraph instanceof ScenegraphNode) {\n      // Signature 1: props.scenegraph is a proper luma.gl Scenegraph\n      scenegraphData = {scenes: [props.scenegraph]};\n    } else if (props.scenegraph && typeof props.scenegraph === 'object') {\n      // Converts loaders.gl gltf to luma.gl scenegraph using the undocumented @luma.gl/experimental function\n      const gltf = props.scenegraph;\n\n      // Tiles3DLoader already processes GLTF\n      const processedGLTF = gltf.json ? postProcessGLTF(gltf) : gltf;\n\n      const gltfObjects = createScenegraphsFromGLTF(device, processedGLTF, this._getModelOptions());\n      scenegraphData = {gltf: processedGLTF, ...gltfObjects};\n\n      waitForGLTFAssets(gltfObjects)\n        .then(() => {\n          this.setNeedsRedraw();\n        })\n        .catch(ex => {\n          this.raiseError(ex, 'loading glTF');\n        });\n    }\n\n    const options = {layer: this, device: this.context.device};\n    const scenegraph = props.getScene(scenegraphData, options);\n    const animator = props.getAnimator(scenegraphData, options);\n\n    if (scenegraph instanceof GroupNode) {\n      this.state.scenegraph?.destroy();\n\n      this._applyAnimationsProp(animator, props._animations);\n\n      const models: Model[] = [];\n      scenegraph.traverse(node => {\n        if (node instanceof ModelNode) {\n          models.push(node.model);\n        }\n      });\n\n      this.setState({scenegraph, animator, models});\n      this.getAttributeManager()!.invalidateAll();\n    } else if (scenegraph !== null) {\n      log.warn('invalid scenegraph:', scenegraph)();\n    }\n  }\n\n  private _applyAnimationsProp(animator: GLTFAnimator, animationsProp: any): void {\n    if (!animator || !animationsProp) {\n      return;\n    }\n\n    const animations = animator.getAnimations();\n\n    // sort() to ensure '*' comes first so that other values can override\n    Object.keys(animationsProp)\n      .sort()\n      .forEach(key => {\n        // Key can be:\n        //  - number for index number\n        //  - name for animation name\n        //  - * to affect all animations\n        const value = animationsProp[key];\n\n        if (key === '*') {\n          animations.forEach(animation => {\n            Object.assign(animation, value);\n          });\n        } else if (Number.isFinite(Number(key))) {\n          const number = Number(key);\n          if (number >= 0 && number < animations.length) {\n            Object.assign(animations[number], value);\n          } else {\n            log.warn(`animation ${key} not found`)();\n          }\n        } else {\n          const findResult = animations.find(({animation}) => animation.name === key);\n          if (findResult) {\n            Object.assign(findResult, value);\n          } else {\n            log.warn(`animation ${key} not found`)();\n          }\n        }\n      });\n  }\n\n  private _getModelOptions(): GLTFInstantiatorOptions {\n    const {_imageBasedLightingEnvironment} = this.props;\n\n    let env: PBREnvironment | undefined;\n    if (_imageBasedLightingEnvironment) {\n      if (typeof _imageBasedLightingEnvironment === 'function') {\n        env = _imageBasedLightingEnvironment({gl: this.context.gl, layer: this});\n      } else {\n        env = _imageBasedLightingEnvironment;\n      }\n    }\n\n    return {\n      imageBasedLightingEnvironment: env,\n      modelOptions: {\n        id: this.props.id,\n        isInstanced: true,\n        bufferLayout: this.getAttributeManager()!.getBufferLayouts(),\n        ...this.getShaders()\n      },\n      // tangents are not supported\n      useTangents: false\n    };\n  }\n\n  draw({context}) {\n    if (!this.state.scenegraph) return;\n\n    if (this.props._animations && this.state.animator) {\n      this.state.animator.animate(context.timeline.getTime());\n      this.setNeedsRedraw();\n    }\n\n    const {viewport, renderPass} = this.context;\n    const {sizeScale, sizeMinPixels, sizeMaxPixels, coordinateSystem} = this.props;\n    const pbrProjectionProps = {\n      camera: viewport.cameraPosition as [number, number, number]\n    };\n\n    const numInstances = this.getNumInstances();\n    this.state.scenegraph.traverse((node, {worldMatrix}) => {\n      if (node instanceof ModelNode) {\n        const {model} = node;\n        model.setInstanceCount(numInstances);\n\n        const scenegraphProps: ScenegraphProps = {\n          sizeScale,\n          sizeMinPixels,\n          sizeMaxPixels,\n          composeModelMatrix: shouldComposeModelMatrix(viewport, coordinateSystem),\n          sceneModelMatrix: worldMatrix\n        };\n\n        model.shaderInputs.setProps({\n          pbrProjection: pbrProjectionProps,\n          scenegraph: scenegraphProps\n        });\n        model.draw(renderPass);\n      }\n    });\n  }\n}\n"],
  "mappings": "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7B,KAAK,wBAAwB;AAAA,EAC7B,KAAK,wBAAwB;AAAA,EAC7B,KAAK,wBAAwB;AAAA,EAC7B,KAAK,wBAAwB;AAAA,EAC7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA;AAAA,EAE7B,KAAK,wBAAwB;AAAA,EAC7B,WAAY,wBAAwB;AAAA,EACpC,YAAY,wBAAwB;AAAA;AAAA,EAEpC,WAAY,wBAAwB;AAAA;AAAA,EAEpC,YAAY,wBAAwB;AAAA;AAAA,EAEpC,YAAY,wBAAwB;AAAA;AAAA,EAEpC,YAAY,wBAAwB;AAAA;AAAA,EAEpC,YAAY,wBAAwB;AAAA;AAAA,EAEpC,YAAY,wBAAwB;AAAA;AAAA,EAEpC,YAAY,wBAAwB;AAAA;AAAA,EAEpC,YAAY,wBAAwB;AAAA;AAAA,EAEpC,YAAY,wBAAwB;AAAA;AAAA,E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",
  "names": ["KHR_SUPERCOMPRESSION_NONE", "KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT", "KHR_DF_VENDORID_KHRONOS", "KHR_DF_VERSION", "KHR_DF_MODEL_UNSPECIFIED", "KHR_DF_FLAG_ALPHA_STRAIGHT", "KHR_DF_TRANSFER_SRGB", "KHR_DF_PRIMARIES_BT709", "KHR_DF_SAMPLE_DATATYPE_SIGNED", "VK_FORMAT_UNDEFINED", "KTX2Container", "constructor", "vkFormat", "VK_FORMAT_UNDEFINED", "typeSize", "pixelWidth", "pixelHeight", "pixelDepth", "layerCount", "faceCount", "supercompressionScheme", "KHR_SUPERCOMPRESSION_NONE", "levels", "dataFormatDescriptor", "vendorId", "KHR_DF_VENDORID_KHRONOS", "descriptorType", "KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT", "descriptorBlockSize", "versionNumber", "KHR_DF_VERSION", "colorModel", "KHR_DF_MODEL_UNSPECIFIED", "colorPrimaries", "KHR_DF_PRIMARIES_BT709", "transferFunction", "KHR_DF_TRANSFER_SRGB", "flags", "KHR_DF_FLAG_ALPHA_STRAIGHT", "texelBlockDimension", "bytesPlane", "samples", "keyValue", "globalData", "BufferReader", "data", "byteOffset", "byteLength", "littleEndian", "_dataView", "_littleEndian", "_offset", "DataView", "buffer", "_nextUint8", "value", "getUint8", "_nextUint16", "getUint16", "_nextUint32", "getUint32", "_nextUint64", "left", "right", "_nextInt32", "getInt32", "_nextUint8Array", "len", "Uint8Array", "_skip", "bytes", "_scan", "maxByteLength", "term", "NUL", "Uint8Array", "KTX2_ID", "decodeText", "buffer", "TextDecoder", "decode", "read", "data", "id", "Uint8Array", "buffer", "byteOffset", "KTX2_ID", "length", "Error", "container", "KTX2Container", "headerByteLength", "Uint32Array", "BYTES_PER_ELEMENT", "headerReader", "BufferReader", "vkFormat", "_nextUint32", "typeSize", "pixelWidth", "pixelHeight", "pixelDepth", "layerCount", "faceCount", "levelCount", "supercompressionScheme", "dfdByteOffset", "dfdByteLength", "kvdByteOffset", "kvdByteLength", "sgdByteOffset", "_nextUint64", "sgdByteLength", "levelByteLength", "levelReader", "i", "levels", "push", "levelData", "uncompressedByteLength", "dfdReader", "dfd", "vendorId", "_skip", "_nextUint16", "descriptorType", "versionNumber", "descriptorBlockSize", "colorModel", "_nextUint8", "colorPrimaries", "transferFunction", "flags", "texelBlockDimension", "bytesPlane", "samples", "sampleStart", "sampleWords", "numSamples", "sample", "bitOffset", "bitLength", "channelType", "samplePosition", "sampleLower", "sampleUpper", "Infinity", "KHR_DF_SAMPLE_DATATYPE_SIGNED", "_nextInt32", "dataFormatDescriptor", "kvdReader", "_offset", "keyValueByteLength", "keyData", "_scan", "key", "decodeText", "keyValue", "_nextUint8Array", "byteLength", "match", "text", "substring", "lastIndexOf", "kvPadding", "sgdReader", "endpointCount", "selectorCount", "endpointsByteLength", "selectorsByteLength", "tablesByteLength", "extendedByteLength", "imageDescs", "imageFlags", "rgbSliceByteOffset", "rgbSliceByteLength", "alphaSliceByteOffset", "alphaSliceByteLength", "endpointsByteOffset", "selectorsByteOffset", "tablesByteOffset", "extendedByteOffset", "endpointsData", "selectorsData", "tablesData", "extendedData", "globalData", "KTX2_ID", "a", "b", "GLEnum", "name", "name", "assert", "ATTRIBUTE_TYPE_TO_COMPONENTS", "ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY", "assert", "assert", "result", "name", "assert", "ATTRIBUTE_TYPE_TO_COMPONENTS", "ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY", "ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE", "a", "decode", "encode", "name", "name", "decode", "encode", "decode", "name", "name", "decode", "decodePropertyTextures", "decodePropertyTables", "findPropertyTableByClass", "processPropertyTable", "getPropertyDataFromBinarySource", "getArrayOffsetsForProperty", "getStringOffsetsForProperty", "getPropertyDataNumeric", "VERSION", "decode", "name", "decode", "name", "decode", "name", "name", "name", "preprocess", "name", "preprocess", "decode", "encode", "name", "preprocess", "VERSION", "VERSION", "DracoLoader", "name", "name", "preprocess", "decode", "encode", "DracoLoader", "decode", "name", "name", "decode", "decode", "encode", "name", "name", "decode", "encode", "assert", "decode", "encode", "name", "name", "decode", "encode", "decode", "encode", "name", "name", "decode", "encode", "preprocess", "preprocess", "parseGLTF", "assert", "fetch", "VERSION", "parse", "parseGLTF", "COMPONENTS", "BYTES", "assert", "uniformBlock", "DEFAULT_COLOR", "defaultProps"]
}
